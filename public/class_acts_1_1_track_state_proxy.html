<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_track_state_proxy.html','','class_acts_1_1_track_state_proxy-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Proxy object to access a single point on the trajectory.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_track_state_proxy_8hpp_source.html">Acts/EventData/TrackStateProxy.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_track_state_proxy__inherit__graph.svg" width="100%" height="521"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84a42178bff9f1910351298b15ccf4db" id="r_a84a42178bff9f1910351298b15ccf4db"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a84a42178bff9f1910351298b15ccf4db template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84a42178bff9f1910351298b15ccf4db">Calibrated</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, <a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>&gt;::Calibrated</td></tr>
<tr class="memdesc:a84a42178bff9f1910351298b15ccf4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a calibrated measurement vector, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:a03724890b6b3af53493fcf54884f02b7" id="r_a03724890b6b3af53493fcf54884f02b7"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a03724890b6b3af53493fcf54884f02b7 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03724890b6b3af53493fcf54884f02b7">CalibratedCovariance</a></td></tr>
<tr class="memdesc:a03724890b6b3af53493fcf54884f02b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a calibrated measurement covariance matrix, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:a6bc7781170388e6a5efc5dbfba2e369b" id="r_a6bc7781170388e6a5efc5dbfba2e369b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a6bc7781170388e6a5efc5dbfba2e369b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc7781170388e6a5efc5dbfba2e369b">ConstCalibrated</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, true&gt;<a class="el" href="#a84a42178bff9f1910351298b15ccf4db">::Calibrated</a></td></tr>
<tr class="memdesc:a6bc7781170388e6a5efc5dbfba2e369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>Calibrated</code>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a105d545b90be92b01c15163e89b8c763" id="r_a105d545b90be92b01c15163e89b8c763"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a105d545b90be92b01c15163e89b8c763 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a105d545b90be92b01c15163e89b8c763">ConstCalibratedCovariance</a></td></tr>
<tr class="memdesc:a105d545b90be92b01c15163e89b8c763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a03724890b6b3af53493fcf54884f02b7">CalibratedCovariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a04aa68f896e3a74cfc505a953867aa70" id="r_a04aa68f896e3a74cfc505a953867aa70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">::Covariance</a></td></tr>
<tr class="memdesc:a04aa68f896e3a74cfc505a953867aa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a7fbdcef77447c959db9a629ce2a1a50a" id="r_a7fbdcef77447c959db9a629ce2a1a50a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fbdcef77447c959db9a629ce2a1a50a">ConstEffectiveCalibrated</a></td></tr>
<tr class="memdesc:a7fbdcef77447c959db9a629ce2a1a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>EffectiveCalibrated</code>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a1ef98ae9574bf01c97c83eb7ab023257" id="r_a1ef98ae9574bf01c97c83eb7ab023257"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef98ae9574bf01c97c83eb7ab023257">ConstEffectiveCalibratedCovariance</a></td></tr>
<tr class="memdesc:a1ef98ae9574bf01c97c83eb7ab023257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#af37dee5477fc8f723ed159dd0bd4cf0b">EffectiveCalibratedCovariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:aeccd8d3a35af248c909696973307e1e8" id="r_aeccd8d3a35af248c909696973307e1e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">::Parameters</a></td></tr>
<tr class="memdesc:aeccd8d3a35af248c909696973307e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:ae2d3dcceec1ddf3457f1bc3b18462a3c" id="r_ae2d3dcceec1ddf3457f1bc3b18462a3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d3dcceec1ddf3457f1bc3b18462a3c">ConstProxyType</a> = <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt;trajectory_t, M, true&gt;</td></tr>
<tr class="memdesc:ae2d3dcceec1ddf3457f1bc3b18462a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an associated const track state proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:ae6bbe39dbafb35e54bf3de684beb16ea" id="r_ae6bbe39dbafb35e54bf3de684beb16ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, <a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>&gt;::Covariance</td></tr>
<tr class="memdesc:ae6bbe39dbafb35e54bf3de684beb16ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a bound covariance.  <br /></td></tr>
<tr class="memitem:ab0ed08ca7282b3640c3e5d16f6a62e42" id="r_ab0ed08ca7282b3640c3e5d16f6a62e42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0ed08ca7282b3640c3e5d16f6a62e42">EffectiveCalibrated</a></td></tr>
<tr class="memdesc:ab0ed08ca7282b3640c3e5d16f6a62e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a measurement vector, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:af37dee5477fc8f723ed159dd0bd4cf0b" id="r_af37dee5477fc8f723ed159dd0bd4cf0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af37dee5477fc8f723ed159dd0bd4cf0b">EffectiveCalibratedCovariance</a></td></tr>
<tr class="memdesc:af37dee5477fc8f723ed159dd0bd4cf0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a measurement covariance matrix, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:a88faa591bbaae408e41c6db7fb39e0e5" id="r_a88faa591bbaae408e41c6db7fb39e0e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> = <a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a></td></tr>
<tr class="memdesc:a88faa591bbaae408e41c6db7fb39e0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type of the track state container.  <br /></td></tr>
<tr class="memitem:ab2488c63138a9366f18d8cadd64aeee6" id="r_ab2488c63138a9366f18d8cadd64aeee6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, <a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>&gt;::Parameters</td></tr>
<tr class="memdesc:ab2488c63138a9366f18d8cadd64aeee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a bound parameter vector.  <br /></td></tr>
<tr class="memitem:ab5e5ad251ac9d342e90dfe255b698896" id="r_ab5e5ad251ac9d342e90dfe255b698896"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> = trajectory_t</td></tr>
<tr class="memdesc:ab5e5ad251ac9d342e90dfe255b698896"><td class="mdescLeft">&#160;</td><td class="mdescRight">The track state container backend given as a template parameter.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9eeeb3cd9207c308fa6bf497318d1f0d" id="r_a9eeeb3cd9207c308fa6bf497318d1f0d"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eeeb3cd9207c308fa6bf497318d1f0d">container</a> ()</td></tr>
<tr class="memdesc:a9eeeb3cd9207c308fa6bf497318d1f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the track state container backend.  <br /></td></tr>
<tr class="memitem:a28f8e6a2a933d5979843a6327d700349" id="r_a28f8e6a2a933d5979843a6327d700349"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f8e6a2a933d5979843a6327d700349">container</a> () const</td></tr>
<tr class="memdesc:a28f8e6a2a933d5979843a6327d700349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the track state container backend.  <br /></td></tr>
<tr class="memitem:aa275b2ab0856e73063d3bd9a8b7dee18" id="r_aa275b2ab0856e73063d3bd9a8b7dee18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa275b2ab0856e73063d3bd9a8b7dee18">hasColumn</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:aa275b2ab0856e73063d3bd9a8b7dee18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the track state has a specific dynamic column.  <br /></td></tr>
<tr class="memitem:a5fbed9bb3b46afcbd08f6d8559b55684" id="r_a5fbed9bb3b46afcbd08f6d8559b55684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fbed9bb3b46afcbd08f6d8559b55684">trajectory</a> ()</td></tr>
<tr class="memdesc:a5fbed9bb3b46afcbd08f6d8559b55684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the underlying backend container.  <br /></td></tr>
<tr class="memitem:a400c5a87fdeb279c3c705463f95195ff" id="r_a400c5a87fdeb279c3c705463f95195ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400c5a87fdeb279c3c705463f95195ff">trajectory</a> () const</td></tr>
<tr class="memdesc:a400c5a87fdeb279c3c705463f95195ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the underlying backend container.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors and assignment operator</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_construct"></a> Public constructors and assignment operators for <code>TrackStateProxy</code> only allow construction from another <code>TrackStateProxy</code>. You should generally not have to construct <code>TrackStateProxy</code> manually. </p>
</div></td></tr>
<tr class="memitem:a7c64da1d3029b735fd7651a2cc12cd9e" id="r_a7c64da1d3029b735fd7651a2cc12cd9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> (const TrackStateProxy &amp;other)=default</td></tr>
<tr class="memdesc:a7c64da1d3029b735fd7651a2cc12cd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: const to const or mutable to mutable.  <br /></td></tr>
<tr class="memitem:a4b952743d6b1f741c480358fc8674e49" id="r_a4b952743d6b1f741c480358fc8674e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b952743d6b1f741c480358fc8674e49">operator=</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp;other)=default</td></tr>
<tr class="memdesc:a4b952743d6b1f741c480358fc8674e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: const to const or mutable to mutable.  <br /></td></tr>
<tr class="memitem:ada128f1703a9355dd6e2d1e84d30176c" id="r_ada128f1703a9355dd6e2d1e84d30176c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada128f1703a9355dd6e2d1e84d30176c">TrackStateProxy</a> (const TrackStateProxy&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;other)</td></tr>
<tr class="memdesc:ada128f1703a9355dd6e2d1e84d30176c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from mutable TrackStateProxy.  <br /></td></tr>
<tr class="memitem:a2a7d2d25ba9d29f2d08793e7d82a323d" id="r_a2a7d2d25ba9d29f2d08793e7d82a323d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a7d2d25ba9d29f2d08793e7d82a323d">operator=</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;other)</td></tr>
<tr class="memdesc:a2a7d2d25ba9d29f2d08793e7d82a323d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to from mutable <code>TrackStateProxy</code>.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state properties</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_props"></a> Properties of the track state represented by <code>TrackStateProxy</code>.</p>
<p>Many of these methods come in a <code>const</code> and a non-<code>const</code> version. The non-<code>const</code> version is only available if you have an instance of <code>TrackStateProxy</code> that does not have the <code>read_only</code> template parameter set to <code>true</code>, even if you hold it as an lvalue.</p>
<p>The track states each have an index in the track state container. The sequence of track states is implemented as a one or two-way linked list, which uses indices into the same container.</p>
<p>Each track state has a <code>previous</code> index, which points at the track state immediately preceding. A track state with a <code>previous</code> index of <code>kInvalid</code> is the first (innermost) track state in a track or track candidate. This is also referred to as a <em>stem</em> at the track level.</p>
<p>During track finding and fitting, track states are usually appended to the sequence, populating the <code>previous</code> index of the new track state. Combinatorial track finding can produce track states which fork in this way, by having more than one track state with the same <code>previous</code> index.</p>
<p>The track states have static, optional and dynamic properties. Static properties are always present, and can always be retrieved. Optional components use an extra indirection mechanism that coordinates with the backend to allow both not having the component set, or sharing it with other track states. An example is a branching trajectory from track finding which shares the same predicted parameter vector and associated covariance.</p>
<p>Optional components are</p><ul>
<li>predicted parameters and covariance</li>
<li>filtered parameters and covariance</li>
<li>smoothed parameters and covariance</li>
<li>jacobian</li>
<li>calibrated measurement info including projector</li>
</ul>
<p>They can be unset via <a class="el" href="#a58ecea4d41d25884af489e1391a1fdb5">unset</a>, <a class="el" href="#ad287abac373d7c888eb39f26c1fff117">getMask</a> can be used to check which components are present. The first four are shareable between track states via <a class="el" href="#a95304204468f54911b50a674f7ada1d6">shareFrom</a>. </p>
</div></td></tr>
<tr class="memitem:a0c262c2b5ad8f0c90c99a157de006a60" id="r_a0c262c2b5ad8f0c90c99a157de006a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c262c2b5ad8f0c90c99a157de006a60">index</a> () const</td></tr>
<tr class="memdesc:a0c262c2b5ad8f0c90c99a157de006a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index within the trajectory.  <br /></td></tr>
<tr class="memitem:ae7d2d40aef71d1739184fd08eda93ac1" id="r_ae7d2d40aef71d1739184fd08eda93ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7d2d40aef71d1739184fd08eda93ac1">previous</a> () const</td></tr>
<tr class="memdesc:ae7d2d40aef71d1739184fd08eda93ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the track state <span class="tt">previous</span> in the track sequence.  <br /></td></tr>
<tr class="memitem:adab3254d35183a268e201ee8f0736d6f" id="r_adab3254d35183a268e201ee8f0736d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adab3254d35183a268e201ee8f0736d6f">previous</a> ()</td></tr>
<tr class="memdesc:adab3254d35183a268e201ee8f0736d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the index of the track state 'previous' in the track sequence.  <br /></td></tr>
<tr class="memitem:acd53c076b390ca5f20107a7390d3be00" id="r_acd53c076b390ca5f20107a7390d3be00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd53c076b390ca5f20107a7390d3be00">hasPrevious</a> () const</td></tr>
<tr class="memdesc:acd53c076b390ca5f20107a7390d3be00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether this track state has a previous (parent) track state.  <br /></td></tr>
<tr class="memitem:ad287abac373d7c888eb39f26c1fff117" id="r_ad287abac373d7c888eb39f26c1fff117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad287abac373d7c888eb39f26c1fff117">getMask</a> () const</td></tr>
<tr class="memdesc:ad287abac373d7c888eb39f26c1fff117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a mask that represents all the allocated components of this track state proxy.  <br /></td></tr>
<tr class="memitem:a58ecea4d41d25884af489e1391a1fdb5" id="r_a58ecea4d41d25884af489e1391a1fdb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ecea4d41d25884af489e1391a1fdb5">unset</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> target)</td></tr>
<tr class="memdesc:a58ecea4d41d25884af489e1391a1fdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset an optional track state component.  <br /></td></tr>
<tr class="memitem:a71b5772cf7d277d0f2b8051adb619188" id="r_a71b5772cf7d277d0f2b8051adb619188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b5772cf7d277d0f2b8051adb619188">addComponents</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> mask)</td></tr>
<tr class="memdesc:a71b5772cf7d277d0f2b8051adb619188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add additional components to the track state.  <br /></td></tr>
<tr class="memitem:a412f66e00d2d9194b0d1c1adee50a279" id="r_a412f66e00d2d9194b0d1c1adee50a279"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a412f66e00d2d9194b0d1c1adee50a279">referenceSurface</a> () const</td></tr>
<tr class="memdesc:a412f66e00d2d9194b0d1c1adee50a279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference surface.  <br /></td></tr>
<tr class="memitem:a9a727e6069185f42a12198df597e7c6e" id="r_a9a727e6069185f42a12198df597e7c6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a727e6069185f42a12198df597e7c6e">hasReferenceSurface</a> () const</td></tr>
<tr class="memdesc:a9a727e6069185f42a12198df597e7c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the track state has a non nullptr surface associated.  <br /></td></tr>
<tr class="memitem:a57835d73120cd60cf7dd0c37fa92d3c3" id="r_a57835d73120cd60cf7dd0c37fa92d3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57835d73120cd60cf7dd0c37fa92d3c3">setReferenceSurface</a> (std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt; srf)</td></tr>
<tr class="memdesc:a57835d73120cd60cf7dd0c37fa92d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference surface to a given value.  <br /></td></tr>
<tr class="memitem:a85f2647845454a5b97deb8f4f87ccd67" id="r_a85f2647845454a5b97deb8f4f87ccd67"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85f2647845454a5b97deb8f4f87ccd67">chi2</a> ()</td></tr>
<tr class="memdesc:a85f2647845454a5b97deb8f4f87ccd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter/setter for chi2 value associated with the track state This overload returns a mutable reference, which allows setting a new value directly into the backing store.  <br /></td></tr>
<tr class="memitem:a90fc7a4cd16b48d1eb30e01e40114ead" id="r_a90fc7a4cd16b48d1eb30e01e40114ead"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90fc7a4cd16b48d1eb30e01e40114ead">chi2</a> () const</td></tr>
<tr class="memdesc:a90fc7a4cd16b48d1eb30e01e40114ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the chi2 value associated with the track state.  <br /></td></tr>
<tr class="memitem:adfe74e3cdfb647c0eb7d3736bdb5b240" id="r_adfe74e3cdfb647c0eb7d3736bdb5b240"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfe74e3cdfb647c0eb7d3736bdb5b240">pathLength</a> ()</td></tr>
<tr class="memdesc:adfe74e3cdfb647c0eb7d3736bdb5b240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the path length associated with the track state.  <br /></td></tr>
<tr class="memitem:a073670d75bc434c1372c5c9bb906fdab" id="r_a073670d75bc434c1372c5c9bb906fdab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073670d75bc434c1372c5c9bb906fdab">pathLength</a> () const</td></tr>
<tr class="memdesc:a073670d75bc434c1372c5c9bb906fdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the path length.  <br /></td></tr>
<tr class="memitem:a346c4791f935c4aa667b50852ed96349" id="r_a346c4791f935c4aa667b50852ed96349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_type.html">TrackStateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a346c4791f935c4aa667b50852ed96349">typeFlags</a> ()</td></tr>
<tr class="memdesc:a346c4791f935c4aa667b50852ed96349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the type flags associated with the track state.  <br /></td></tr>
<tr class="memitem:a3f8d5bc54cb20d0cc76c1776d82cbd0f" id="r_a3f8d5bc54cb20d0cc76c1776d82cbd0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_const_track_state_type.html">ConstTrackStateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f8d5bc54cb20d0cc76c1776d82cbd0f">typeFlags</a> () const</td></tr>
<tr class="memdesc:a3f8d5bc54cb20d0cc76c1776d82cbd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the type flags.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state parameters</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_params"></a></p>
</div></td></tr>
<tr class="memitem:a0ca1157f1c278b89658764e4939d3521" id="r_a0ca1157f1c278b89658764e4939d3521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ca1157f1c278b89658764e4939d3521">parameters</a> () const</td></tr>
<tr class="memdesc:a0ca1157f1c278b89658764e4939d3521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track parameters vector.  <br /></td></tr>
<tr class="memitem:a65d0c723360f1c46b76d72c8e657c20e" id="r_a65d0c723360f1c46b76d72c8e657c20e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65d0c723360f1c46b76d72c8e657c20e">covariance</a> () const</td></tr>
<tr class="memdesc:a65d0c723360f1c46b76d72c8e657c20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track parameters covariance matrix.  <br /></td></tr>
<tr class="memitem:ada133337d6cd728e6439e568f2171a8f" id="r_ada133337d6cd728e6439e568f2171a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada133337d6cd728e6439e568f2171a8f">predicted</a> () const</td></tr>
<tr class="memdesc:ada133337d6cd728e6439e568f2171a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted track parameters vector.  <br /></td></tr>
<tr class="memitem:a45ce34be1d32b194bd6e745cc482b4b6" id="r_a45ce34be1d32b194bd6e745cc482b4b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45ce34be1d32b194bd6e745cc482b4b6">predicted</a> ()</td></tr>
<tr class="memdesc:a45ce34be1d32b194bd6e745cc482b4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted track parameters vector (non-const version).  <br /></td></tr>
<tr class="memitem:ad7b768ceb432a5bf536354e25057220b" id="r_ad7b768ceb432a5bf536354e25057220b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7b768ceb432a5bf536354e25057220b">predictedCovariance</a> () const</td></tr>
<tr class="memdesc:ad7b768ceb432a5bf536354e25057220b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted track parameters covariance matrix.  <br /></td></tr>
<tr class="memitem:a2c7f64e6e75d1cbd41dfd9dd5b63cce7" id="r_a2c7f64e6e75d1cbd41dfd9dd5b63cce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c7f64e6e75d1cbd41dfd9dd5b63cce7">predictedCovariance</a> ()</td></tr>
<tr class="memdesc:a2c7f64e6e75d1cbd41dfd9dd5b63cce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicted track parameters covariance matrix (non-const version).  <br /></td></tr>
<tr class="memitem:aaf6cafec36023994f719063de8426b1d" id="r_aaf6cafec36023994f719063de8426b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf6cafec36023994f719063de8426b1d">hasPredicted</a> () const</td></tr>
<tr class="memdesc:aaf6cafec36023994f719063de8426b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the predicted parameters+covariance is set.  <br /></td></tr>
<tr class="memitem:abb2e4ad815d47c72825530f63b639c18" id="r_abb2e4ad815d47c72825530f63b639c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb2e4ad815d47c72825530f63b639c18">filtered</a> () const</td></tr>
<tr class="memdesc:abb2e4ad815d47c72825530f63b639c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtered track parameters vector.  <br /></td></tr>
<tr class="memitem:a7f3a51475b679a985958b031a8334aa3" id="r_a7f3a51475b679a985958b031a8334aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f3a51475b679a985958b031a8334aa3">filtered</a> ()</td></tr>
<tr class="memdesc:a7f3a51475b679a985958b031a8334aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtered track parameters vector.  <br /></td></tr>
<tr class="memitem:ac6eaecab80e562c1634b64aff25aab8f" id="r_ac6eaecab80e562c1634b64aff25aab8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6eaecab80e562c1634b64aff25aab8f">filteredCovariance</a> () const</td></tr>
<tr class="memdesc:ac6eaecab80e562c1634b64aff25aab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtered track parameters covariance matrix.  <br /></td></tr>
<tr class="memitem:a41cbf81de0b526690dabc86978f22f94" id="r_a41cbf81de0b526690dabc86978f22f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41cbf81de0b526690dabc86978f22f94">filteredCovariance</a> ()</td></tr>
<tr class="memdesc:a41cbf81de0b526690dabc86978f22f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtered track parameters covariance matrix.  <br /></td></tr>
<tr class="memitem:a0ec76319889f85df89ce3737b0e906ae" id="r_a0ec76319889f85df89ce3737b0e906ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ec76319889f85df89ce3737b0e906ae">hasFiltered</a> () const</td></tr>
<tr class="memdesc:a0ec76319889f85df89ce3737b0e906ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether filtered parameters+covariance is set.  <br /></td></tr>
<tr class="memitem:ab6de4dd6ddb5a3cba4e1145e9880b12b" id="r_ab6de4dd6ddb5a3cba4e1145e9880b12b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6de4dd6ddb5a3cba4e1145e9880b12b">smoothed</a> () const</td></tr>
<tr class="memdesc:ab6de4dd6ddb5a3cba4e1145e9880b12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed track parameters vector.  <br /></td></tr>
<tr class="memitem:a3a1592698a419f1bd19dc95119c4cda7" id="r_a3a1592698a419f1bd19dc95119c4cda7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a1592698a419f1bd19dc95119c4cda7">smoothed</a> ()</td></tr>
<tr class="memdesc:a3a1592698a419f1bd19dc95119c4cda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed track parameters vector.  <br /></td></tr>
<tr class="memitem:a7f881d68f2cdd0a1fbc7a4019dc13826" id="r_a7f881d68f2cdd0a1fbc7a4019dc13826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f881d68f2cdd0a1fbc7a4019dc13826">smoothedCovariance</a> () const</td></tr>
<tr class="memdesc:a7f881d68f2cdd0a1fbc7a4019dc13826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed track parameters covariance matrix.  <br /></td></tr>
<tr class="memitem:a2af36064b9675a42205b741182810248" id="r_a2af36064b9675a42205b741182810248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2af36064b9675a42205b741182810248">smoothedCovariance</a> ()</td></tr>
<tr class="memdesc:a2af36064b9675a42205b741182810248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothed track parameters covariance matrix.  <br /></td></tr>
<tr class="memitem:a0b5e6983a57f0fc7a126a75b9dbf377b" id="r_a0b5e6983a57f0fc7a126a75b9dbf377b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b5e6983a57f0fc7a126a75b9dbf377b">hasSmoothed</a> () const</td></tr>
<tr class="memdesc:a0b5e6983a57f0fc7a126a75b9dbf377b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether smoothed parameters+covariance is set.  <br /></td></tr>
<tr class="memitem:a963bb4bd89f7e9f6db39b0215ef7ae28" id="r_a963bb4bd89f7e9f6db39b0215ef7ae28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a963bb4bd89f7e9f6db39b0215ef7ae28">jacobian</a> () const</td></tr>
<tr class="memdesc:a963bb4bd89f7e9f6db39b0215ef7ae28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the jacobian from the previous trackstate to this one.  <br /></td></tr>
<tr class="memitem:a646005da1a4e0fd60e864735dbbb4254" id="r_a646005da1a4e0fd60e864735dbbb4254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646005da1a4e0fd60e864735dbbb4254">jacobian</a> ()</td></tr>
<tr class="memdesc:a646005da1a4e0fd60e864735dbbb4254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the jacobian from the previous trackstate to this one.  <br /></td></tr>
<tr class="memitem:a7bfb1018523bdc51926cfd496e307884" id="r_a7bfb1018523bdc51926cfd496e307884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bfb1018523bdc51926cfd496e307884">hasJacobian</a> () const</td></tr>
<tr class="memdesc:a7bfb1018523bdc51926cfd496e307884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a jacobian is set for this trackstate.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state measurement properties</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_meas"></a> Properties of the measurement associated with the track state represented. This consists of a vector and an associated square matrix of a measurement dimension which is between one and the size of the track parametrization. The measurement coordinate frame is required to be a strict subset of the bound track parametrization on the local geometry coordinate frame, i.e. using a pure projector matrix to convert from the bound parametrization to the measurement frame is possible.</p>
<p>The track state stores the parameter vector and covariance, and the backend is given the possibility to do so in a jagged way, i.e. only storing the number of values needed. This requires calling <a class="el" href="#a8a6f76ec69c3de04836a2d2982be565a">allocateCalibrated</a> before storing the measurements (even if it might be a no-op).</p>
<p>The projector matrix is packed as a bitset, which is converted to a matrix on-demand (and therefore returned by value).</p>
<p>The track state also includes a <a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> which acts as a proxy to the original uncalibrated measurement that the calibrated measurement was derived from. It is set and returned by value, to allow unpacking / repacking by the backend, if needed. </p>
</div></td></tr>
<tr class="memitem:ae6d44df80cc0f018e5758cd0e20a2b81" id="r_ae6d44df80cc0f018e5758cd0e20a2b81"><td class="memTemplParams" colspan="2">template&lt;std::ranges::sized_range index_range_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a> &amp;&amp; std::convertible_to&lt;std::ranges::range_value_t&lt;index_range_t&gt;, std::uint8_t&gt;)</td></tr>
<tr class="memitem:ae6d44df80cc0f018e5758cd0e20a2b81 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6d44df80cc0f018e5758cd0e20a2b81">setProjectorSubspaceIndices</a> (const index_range_t &amp;subspaceIndices)</td></tr>
<tr class="memdesc:ae6d44df80cc0f018e5758cd0e20a2b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the projector subspace indices.  <br /></td></tr>
<tr class="memitem:a7ed085b267c5ea71fb7849b13e0d673b" id="r_a7ed085b267c5ea71fb7849b13e0d673b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ed085b267c5ea71fb7849b13e0d673b">hasProjector</a> () const</td></tr>
<tr class="memdesc:a7ed085b267c5ea71fb7849b13e0d673b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a projector is set.  <br /></td></tr>
<tr class="memitem:ab743ff83d4fe00e15bb27997e9dde3d0" id="r_ab743ff83d4fe00e15bb27997e9dde3d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab743ff83d4fe00e15bb27997e9dde3d0">projectorSubspaceIndices</a> () const</td></tr>
<tr class="memdesc:ab743ff83d4fe00e15bb27997e9dde3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the projector subspace indices.  <br /></td></tr>
<tr class="memitem:a388c57d9949076de1007c211c6924ea6" id="r_a388c57d9949076de1007c211c6924ea6"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; </td></tr>
<tr class="memitem:a388c57d9949076de1007c211c6924ea6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; measdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a388c57d9949076de1007c211c6924ea6">projectorSubspaceIndices</a> () const</td></tr>
<tr class="memdesc:a388c57d9949076de1007c211c6924ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the projector subspace indices.  <br /></td></tr>
<tr class="memitem:ae69bdc29fac30b3f4c9cf84b1f965c82" id="r_ae69bdc29fac30b3f4c9cf84b1f965c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#aaaa9c77f4dd9efc1ac464d9a941f2ef2">VariableBoundSubspaceHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae69bdc29fac30b3f4c9cf84b1f965c82">projectorSubspaceHelper</a> () const</td></tr>
<tr class="memdesc:ae69bdc29fac30b3f4c9cf84b1f965c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable size subspace helper.  <br /></td></tr>
<tr class="memitem:a597bd8143b2e3614fbbc37e7313c99d4" id="r_a597bd8143b2e3614fbbc37e7313c99d4"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; </td></tr>
<tr class="memitem:a597bd8143b2e3614fbbc37e7313c99d4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a9bc2353f4da72bb7afd4d868e278150c">FixedBoundSubspaceHelper</a>&lt; measdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a597bd8143b2e3614fbbc37e7313c99d4">projectorSubspaceHelper</a> () const</td></tr>
<tr class="memdesc:a597bd8143b2e3614fbbc37e7313c99d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fixed size subspace helper.  <br /></td></tr>
<tr class="memitem:ae735c7f377c9d136cd0dae9b404e1363" id="r_ae735c7f377c9d136cd0dae9b404e1363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae735c7f377c9d136cd0dae9b404e1363">getUncalibratedSourceLink</a> () const</td></tr>
<tr class="memdesc:ae735c7f377c9d136cd0dae9b404e1363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncalibrated measurement in the form of a source link.  <br /></td></tr>
<tr class="memitem:ad9e34422bd144eca89d0a0a3a3b085ab" id="r_ad9e34422bd144eca89d0a0a3a3b085ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e34422bd144eca89d0a0a3a3b085ab">setUncalibratedSourceLink</a> (<a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> &amp;&amp;sourceLink)</td></tr>
<tr class="memdesc:ad9e34422bd144eca89d0a0a3a3b085ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an uncalibrated source link.  <br /></td></tr>
<tr class="memitem:a9861fa7fb806028eb6ab74c98152e9c1" id="r_a9861fa7fb806028eb6ab74c98152e9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9861fa7fb806028eb6ab74c98152e9c1">hasUncalibratedSourceLink</a> () const</td></tr>
<tr class="memdesc:a9861fa7fb806028eb6ab74c98152e9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the point has an associated uncalibrated measurement.  <br /></td></tr>
<tr class="memitem:aa80699dc9461dc0d1b1b6b17e203c8ec" id="r_aa80699dc9461dc0d1b1b6b17e203c8ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa80699dc9461dc0d1b1b6b17e203c8ec">hasCalibrated</a> () const</td></tr>
<tr class="memdesc:aa80699dc9461dc0d1b1b6b17e203c8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the point has an associated calibrated measurement.  <br /></td></tr>
<tr class="memitem:afe7a343367038a1d6fe1fee9e6a9f6cb" id="r_afe7a343367038a1d6fe1fee9e6a9f6cb"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; </td></tr>
<tr class="memitem:afe7a343367038a1d6fe1fee9e6a9f6cb template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6bc7781170388e6a5efc5dbfba2e369b">ConstCalibrated</a>&lt; measdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe7a343367038a1d6fe1fee9e6a9f6cb">calibrated</a> () const</td></tr>
<tr class="memdesc:afe7a343367038a1d6fe1fee9e6a9f6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full calibrated measurement vector.  <br /></td></tr>
<tr class="memitem:ac3d2e674d8e36b45761fcaf1caa0ffab" id="r_ac3d2e674d8e36b45761fcaf1caa0ffab"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:ac3d2e674d8e36b45761fcaf1caa0ffab template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a84a42178bff9f1910351298b15ccf4db">Calibrated</a>&lt; measdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3d2e674d8e36b45761fcaf1caa0ffab">calibrated</a> ()</td></tr>
<tr class="memdesc:ac3d2e674d8e36b45761fcaf1caa0ffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full calibrated measurement vector.  <br /></td></tr>
<tr class="memitem:ac29e126eabff173682c068abef7b7a09" id="r_ac29e126eabff173682c068abef7b7a09"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; </td></tr>
<tr class="memitem:ac29e126eabff173682c068abef7b7a09 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a105d545b90be92b01c15163e89b8c763">ConstCalibratedCovariance</a>&lt; measdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29e126eabff173682c068abef7b7a09">calibratedCovariance</a> () const</td></tr>
<tr class="memdesc:ac29e126eabff173682c068abef7b7a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const full calibrated measurement covariance matrix.  <br /></td></tr>
<tr class="memitem:a9b043aaf908b373b227442f28dcffef0" id="r_a9b043aaf908b373b227442f28dcffef0"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a9b043aaf908b373b227442f28dcffef0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a03724890b6b3af53493fcf54884f02b7">CalibratedCovariance</a>&lt; measdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b043aaf908b373b227442f28dcffef0">calibratedCovariance</a> ()</td></tr>
<tr class="memdesc:a9b043aaf908b373b227442f28dcffef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable full calibrated measurement covariance matrix.  <br /></td></tr>
<tr class="memitem:ae5254b01a1b33f36fd4f6769f91a7b75" id="r_ae5254b01a1b33f36fd4f6769f91a7b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab0ed08ca7282b3640c3e5d16f6a62e42">EffectiveCalibrated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5254b01a1b33f36fd4f6769f91a7b75">effectiveCalibrated</a> ()</td></tr>
<tr class="memdesc:ae5254b01a1b33f36fd4f6769f91a7b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable dynamic measurement vector with only the valid dimensions.  <br /></td></tr>
<tr class="memitem:a61f7c3790deb443faad73b06d7c24a25" id="r_a61f7c3790deb443faad73b06d7c24a25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7fbdcef77447c959db9a629ce2a1a50a">ConstEffectiveCalibrated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61f7c3790deb443faad73b06d7c24a25">effectiveCalibrated</a> () const</td></tr>
<tr class="memdesc:a61f7c3790deb443faad73b06d7c24a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const dynamic measurement vector with only the valid dimensions.  <br /></td></tr>
<tr class="memitem:aaa274eb254b676d8d0119bffbdcb9908" id="r_aaa274eb254b676d8d0119bffbdcb9908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af37dee5477fc8f723ed159dd0bd4cf0b">EffectiveCalibratedCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa274eb254b676d8d0119bffbdcb9908">effectiveCalibratedCovariance</a> ()</td></tr>
<tr class="memdesc:aaa274eb254b676d8d0119bffbdcb9908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable dynamic measurement covariance matrix with only the valid dimensions.  <br /></td></tr>
<tr class="memitem:a8036047e6c138e2888529a31ac33298b" id="r_a8036047e6c138e2888529a31ac33298b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1ef98ae9574bf01c97c83eb7ab023257">ConstEffectiveCalibratedCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8036047e6c138e2888529a31ac33298b">effectiveCalibratedCovariance</a> () const</td></tr>
<tr class="memdesc:a8036047e6c138e2888529a31ac33298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const dynamic measurement covariance matrix with only the valid dimensions.  <br /></td></tr>
<tr class="memitem:a9288cb73d98dd95221ae6dd086d802fd" id="r_a9288cb73d98dd95221ae6dd086d802fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9288cb73d98dd95221ae6dd086d802fd">calibratedSize</a> () const</td></tr>
<tr class="memdesc:a9288cb73d98dd95221ae6dd086d802fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the (dynamic) number of dimensions stored for this measurement.  <br /></td></tr>
<tr class="memitem:a8a6f76ec69c3de04836a2d2982be565a" id="r_a8a6f76ec69c3de04836a2d2982be565a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a6f76ec69c3de04836a2d2982be565a">allocateCalibrated</a> (std::size_t measdim)</td></tr>
<tr class="memdesc:a8a6f76ec69c3de04836a2d2982be565a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage to be able to store a measurement of size <code class="param">measdim</code>.  <br /></td></tr>
<tr class="memitem:a75189bd3307977a4a78fcf7b380f1dcc" id="r_a75189bd3307977a4a78fcf7b380f1dcc"><td class="memTemplParams" colspan="2">template&lt;typename val_t, typename cov_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a> &amp;&amp; Concepts::eigen_base_is_fixed_size&lt;val_t&gt; &amp;&amp; Concepts::eigen_bases_have_same_num_rows&lt;val_t, cov_t&gt; &amp;&amp; Concepts::eigen_base_is_square&lt;cov_t&gt; &amp;&amp; Eigen::PlainObjectBase&lt;val_t&gt;::RowsAtCompileTime &lt;= static_cast&lt;std::underlying_type_t&lt;<a class="el" href="namespace_acts.html#ad2b38e86cfd40fa19fe61c74e8ca9fc7">BoundIndices</a>&gt;&gt;(<a class="el" href="namespace_acts.html#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>))</td></tr>
<tr class="memitem:a75189bd3307977a4a78fcf7b380f1dcc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75189bd3307977a4a78fcf7b380f1dcc">allocateCalibrated</a> (const Eigen::DenseBase&lt; val_t &gt; &amp;val, const Eigen::DenseBase&lt; cov_t &gt; &amp;cov)</td></tr>
<tr class="memdesc:a75189bd3307977a4a78fcf7b380f1dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage and assign the given vector and covariance to it.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Sharing and copying</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_share_copy"></a> Methods to share and copy track state components. Sharing means setting up more than one track state to point to the same component.</p>
<p>Shareable components are</p><ul>
<li>predicted parameters and covariance</li>
<li>filtered parameters and covariance</li>
<li>smoothed parameters and covariance</li>
<li>jacobian</li>
</ul>
<p>See <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a>. </p>
</div></td></tr>
<tr class="memitem:a95304204468f54911b50a674f7ada1d6" id="r_a95304204468f54911b50a674f7ada1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95304204468f54911b50a674f7ada1d6">shareFrom</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareSource, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareTarget)</td></tr>
<tr class="memdesc:a95304204468f54911b50a674f7ada1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share a shareable component <b>within</b> this track state.  <br /></td></tr>
<tr class="memitem:a8086412d1967b46203d8a00c0811e8de" id="r_a8086412d1967b46203d8a00c0811e8de"><td class="memTemplParams" colspan="2">template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a8086412d1967b46203d8a00c0811e8de template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8086412d1967b46203d8a00c0811e8de">shareFrom</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;other, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> <a class="el" href="#a1accd7846f32112e931dc3cbe683ae4a">component</a>)</td></tr>
<tr class="memdesc:a8086412d1967b46203d8a00c0811e8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share a shareable component from another track state.  <br /></td></tr>
<tr class="memitem:a4bb9736a7c382a83ce79d543f563e6f9" id="r_a4bb9736a7c382a83ce79d543f563e6f9"><td class="memTemplParams" colspan="2">template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a4bb9736a7c382a83ce79d543f563e6f9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bb9736a7c382a83ce79d543f563e6f9">shareFrom</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;other, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareSource, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareTarget)</td></tr>
<tr class="memdesc:a4bb9736a7c382a83ce79d543f563e6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share a shareable component from another track state.  <br /></td></tr>
<tr class="memitem:affcbffae2f5137aad8fbc5dffe187f2e" id="r_affcbffae2f5137aad8fbc5dffe187f2e"><td class="memTemplParams" colspan="2">template&lt;TrackStateProxyConcept track_state_proxy_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:affcbffae2f5137aad8fbc5dffe187f2e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcbffae2f5137aad8fbc5dffe187f2e">copyFrom</a> (const track_state_proxy_t &amp;other, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> mask=<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">TrackStatePropMask::All</a>, bool onlyAllocated=true)</td></tr>
<tr class="memdesc:affcbffae2f5137aad8fbc5dffe187f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of another track state proxy into this one.  <br /></td></tr>
<tr id="pub-methods-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state proxy Generic component access</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_generic_component"></a></p>
</div></td></tr>
<tr class="memitem:af1035fd64a07b94bf5df59e5c84978f8" id="r_af1035fd64a07b94bf5df59e5c84978f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </td></tr>
<tr class="memitem:af1035fd64a07b94bf5df59e5c84978f8 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1035fd64a07b94bf5df59e5c84978f8">has</a> () const</td></tr>
<tr class="memdesc:af1035fd64a07b94bf5df59e5c84978f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a component is set.  <br /></td></tr>
<tr class="memitem:a2f032c5a6b354bcf96c600429dd47dbd" id="r_a2f032c5a6b354bcf96c600429dd47dbd"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f032c5a6b354bcf96c600429dd47dbd">has</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:a2f032c5a6b354bcf96c600429dd47dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a component is set.  <br /></td></tr>
<tr class="memitem:a05ba115f5833ed450aa28e94cd21e2f2" id="r_a05ba115f5833ed450aa28e94cd21e2f2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ba115f5833ed450aa28e94cd21e2f2">has</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a05ba115f5833ed450aa28e94cd21e2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a component is set.  <br /></td></tr>
<tr class="memitem:a1accd7846f32112e931dc3cbe683ae4a" id="r_a1accd7846f32112e931dc3cbe683ae4a"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a1accd7846f32112e931dc3cbe683ae4a template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1accd7846f32112e931dc3cbe683ae4a">component</a> ()</td></tr>
<tr class="memdesc:a1accd7846f32112e931dc3cbe683ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:a7fa8a0971eb199e1f77c669ea485e93b" id="r_a7fa8a0971eb199e1f77c669ea485e93b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a7fa8a0971eb199e1f77c669ea485e93b template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa8a0971eb199e1f77c669ea485e93b">component</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key)</td></tr>
<tr class="memdesc:a7fa8a0971eb199e1f77c669ea485e93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:aaba9ae1881ae6d359047c983abead7e5" id="r_aaba9ae1881ae6d359047c983abead7e5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:aaba9ae1881ae6d359047c983abead7e5 template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaba9ae1881ae6d359047c983abead7e5">component</a> (std::string_view key)</td></tr>
<tr class="memdesc:aaba9ae1881ae6d359047c983abead7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:a02384247b8232dfcfe24ad0e8a54773e" id="r_a02384247b8232dfcfe24ad0e8a54773e"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </td></tr>
<tr class="memitem:a02384247b8232dfcfe24ad0e8a54773e template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02384247b8232dfcfe24ad0e8a54773e">component</a> () const</td></tr>
<tr class="memdesc:a02384247b8232dfcfe24ad0e8a54773e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="memitem:a3e2161c9e5d0ab6781732ba63f81f379" id="r_a3e2161c9e5d0ab6781732ba63f81f379"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3e2161c9e5d0ab6781732ba63f81f379 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2161c9e5d0ab6781732ba63f81f379">component</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:a3e2161c9e5d0ab6781732ba63f81f379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="memitem:aa5176de3179f8fa3a6f69bf4697842e4" id="r_aa5176de3179f8fa3a6f69bf4697842e4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa5176de3179f8fa3a6f69bf4697842e4 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5176de3179f8fa3a6f69bf4697842e4">component</a> (std::string_view key) const</td></tr>
<tr class="memdesc:aa5176de3179f8fa3a6f69bf4697842e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac971a8625ee702ef7cb743fa52e4f186" id="r_ac971a8625ee702ef7cb743fa52e4f186"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac971a8625ee702ef7cb743fa52e4f186">kInvalid</a> = <a class="el" href="namespace_acts.html#a589e3f01b082df3de46c2a6f5e6ce749">kTrackIndexInvalid</a></td></tr>
<tr class="memdesc:ac971a8625ee702ef7cb743fa52e4f186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value that indicates an invalid index.  <br /></td></tr>
<tr class="memitem:a99b5acfc879ef16dc1c017452b5bbe87" id="r_a99b5acfc879ef16dc1c017452b5bbe87"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a> = read_only</td></tr>
<tr class="memdesc:a99b5acfc879ef16dc1c017452b5bbe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this track state proxy is read-only or if it can be modified.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt;<br />
class Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt;</div><p>Proxy object to access a single point on the trajectory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SourceLink</td><td>Type to link back to an original measurement </td></tr>
    <tr><td class="paramname">M</td><td>Maximum number of measurement dimensions </td></tr>
    <tr><td class="paramname">read_only</td><td>true for read-only access to underlying storage </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a84a42178bff9f1910351298b15ccf4db" name="a84a42178bff9f1910351298b15ccf4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a42178bff9f1910351298b15ccf4db">&#9670;&#160;</a></span>Calibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Calibrated = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, <a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>&gt;::Calibrated</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-type for a calibrated measurement vector, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="a03724890b6b3af53493fcf54884f02b7" name="a03724890b6b3af53493fcf54884f02b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03724890b6b3af53493fcf54884f02b7">&#9670;&#160;</a></span>CalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::CalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#aa64c572629f672b29c31ae27a88789db">TrackStateTraits&lt;N, ReadOnly&gt;::CalibratedCovariance</a></div>
<div class="ttc" id="astruct_acts_1_1_track_state_traits_html_aa64c572629f672b29c31ae27a88789db"><div class="ttname"><a href="struct_acts_1_1_track_state_traits.html#aa64c572629f672b29c31ae27a88789db">Acts::TrackStateTraits::CalibratedCovariance</a></div><div class="ttdeci">typename detail_lt::FixedSizeTypes&lt; M, ReadOnly &gt;::CovarianceMap CalibratedCovariance</div><div class="ttdef"><b>Definition</b> TrackStateProxy.hpp:144</div></div>
</div><!-- fragment -->
<p>Map-type for a calibrated measurement covariance matrix, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="a6bc7781170388e6a5efc5dbfba2e369b" name="a6bc7781170388e6a5efc5dbfba2e369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc7781170388e6a5efc5dbfba2e369b">&#9670;&#160;</a></span>ConstCalibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstCalibrated = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, true&gt;<a class="el" href="#a84a42178bff9f1910351298b15ccf4db">::Calibrated</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>Calibrated</code>, but with const semantics. </p>

</div>
</div>
<a id="a105d545b90be92b01c15163e89b8c763" name="a105d545b90be92b01c15163e89b8c763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d545b90be92b01c15163e89b8c763">&#9670;&#160;</a></span>ConstCalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstCalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#aa64c572629f672b29c31ae27a88789db">TrackStateTraits&lt;N, true&gt;::CalibratedCovariance</a></div>
</div><!-- fragment -->
<p>Same as <a class="el" href="#a03724890b6b3af53493fcf54884f02b7">CalibratedCovariance</a>, but with const semantics. </p>

</div>
</div>
<a id="a04aa68f896e3a74cfc505a953867aa70" name="a04aa68f896e3a74cfc505a953867aa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa68f896e3a74cfc505a953867aa70">&#9670;&#160;</a></span>ConstCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstCovariance = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">::Covariance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a>, but with const semantics. </p>

</div>
</div>
<a id="a7fbdcef77447c959db9a629ce2a1a50a" name="a7fbdcef77447c959db9a629ce2a1a50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbdcef77447c959db9a629ce2a1a50a">&#9670;&#160;</a></span>ConstEffectiveCalibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstEffectiveCalibrated</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#a65ea4ce85c3b6d2516ffce7c81731bbd">TrackStateTraits&lt;M, true&gt;::EffectiveCalibrated</a></div>
<div class="ttc" id="astruct_acts_1_1_track_state_traits_html_a65ea4ce85c3b6d2516ffce7c81731bbd"><div class="ttname"><a href="struct_acts_1_1_track_state_traits.html#a65ea4ce85c3b6d2516ffce7c81731bbd">Acts::TrackStateTraits::EffectiveCalibrated</a></div><div class="ttdeci">typename detail_lt::DynamicSizeTypes&lt; ReadOnly &gt;::CoefficientsMap EffectiveCalibrated</div><div class="ttdef"><b>Definition</b> TrackStateProxy.hpp:146</div></div>
</div><!-- fragment -->
<p>Same as <code>EffectiveCalibrated</code>, but with const semantics. </p>

</div>
</div>
<a id="a1ef98ae9574bf01c97c83eb7ab023257" name="a1ef98ae9574bf01c97c83eb7ab023257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef98ae9574bf01c97c83eb7ab023257">&#9670;&#160;</a></span>ConstEffectiveCalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstEffectiveCalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#a707f18a1d55e71af9ee4699896034ed7">TrackStateTraits&lt;M, true&gt;::EffectiveCalibratedCovariance</a></div>
<div class="ttc" id="astruct_acts_1_1_track_state_traits_html_a707f18a1d55e71af9ee4699896034ed7"><div class="ttname"><a href="struct_acts_1_1_track_state_traits.html#a707f18a1d55e71af9ee4699896034ed7">Acts::TrackStateTraits::EffectiveCalibratedCovariance</a></div><div class="ttdeci">typename detail_lt::DynamicSizeTypes&lt; ReadOnly &gt;::CovarianceMap EffectiveCalibratedCovariance</div><div class="ttdef"><b>Definition</b> TrackStateProxy.hpp:148</div></div>
</div><!-- fragment -->
<p>Same as <a class="el" href="#af37dee5477fc8f723ed159dd0bd4cf0b">EffectiveCalibratedCovariance</a>, but with const semantics. </p>

</div>
</div>
<a id="aeccd8d3a35af248c909696973307e1e8" name="aeccd8d3a35af248c909696973307e1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccd8d3a35af248c909696973307e1e8">&#9670;&#160;</a></span>ConstParameters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstParameters = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">::Parameters</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a>, but with const semantics. </p>

</div>
</div>
<a id="ae2d3dcceec1ddf3457f1bc3b18462a3c" name="ae2d3dcceec1ddf3457f1bc3b18462a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d3dcceec1ddf3457f1bc3b18462a3c">&#9670;&#160;</a></span>ConstProxyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstProxyType = <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt;trajectory_t, M, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an associated const track state proxy, with the same backends. </p>

</div>
</div>
<a id="ae6bbe39dbafb35e54bf3de684beb16ea" name="ae6bbe39dbafb35e54bf3de684beb16ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bbe39dbafb35e54bf3de684beb16ea">&#9670;&#160;</a></span>Covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Covariance = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, <a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>&gt;::Covariance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-type for a bound covariance. </p>
<p>This has reference semantics, i.e. points at a matrix by an internal pointer. </p>

</div>
</div>
<a id="ab0ed08ca7282b3640c3e5d16f6a62e42" name="ab0ed08ca7282b3640c3e5d16f6a62e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ed08ca7282b3640c3e5d16f6a62e42">&#9670;&#160;</a></span>EffectiveCalibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::EffectiveCalibrated</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#a65ea4ce85c3b6d2516ffce7c81731bbd">TrackStateTraits&lt;M, ReadOnly&gt;::EffectiveCalibrated</a></div>
</div><!-- fragment -->
<p>Map-type for a measurement vector, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="af37dee5477fc8f723ed159dd0bd4cf0b" name="af37dee5477fc8f723ed159dd0bd4cf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37dee5477fc8f723ed159dd0bd4cf0b">&#9670;&#160;</a></span>EffectiveCalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::EffectiveCalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#a707f18a1d55e71af9ee4699896034ed7">TrackStateTraits&lt;M, ReadOnly&gt;::EffectiveCalibratedCovariance</a></div>
</div><!-- fragment -->
<p>Map-type for a measurement covariance matrix, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="a88faa591bbaae408e41c6db7fb39e0e5" name="a88faa591bbaae408e41c6db7fb39e0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88faa591bbaae408e41c6db7fb39e0e5">&#9670;&#160;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::IndexType = <a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index type of the track state container. </p>

</div>
</div>
<a id="ab2488c63138a9366f18d8cadd64aeee6" name="ab2488c63138a9366f18d8cadd64aeee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2488c63138a9366f18d8cadd64aeee6">&#9670;&#160;</a></span>Parameters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Parameters = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, <a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>&gt;::Parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-type for a bound parameter vector. </p>
<p>This has reference semantics, i.e. points at a matrix by an internal pointer. </p>

</div>
</div>
<a id="ab5e5ad251ac9d342e90dfe255b698896" name="ab5e5ad251ac9d342e90dfe255b698896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e5ad251ac9d342e90dfe255b698896">&#9670;&#160;</a></span>Trajectory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Trajectory = trajectory_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The track state container backend given as a template parameter. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c64da1d3029b735fd7651a2cc12cd9e" name="a7c64da1d3029b735fd7651a2cc12cd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c64da1d3029b735fd7651a2cc12cd9e">&#9670;&#160;</a></span>TrackStateProxy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::TrackStateProxy </td>
          <td>(</td>
          <td class="paramtype">const TrackStateProxy&lt; trajectory_t, M, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: const to const or mutable to mutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to construct from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada128f1703a9355dd6e2d1e84d30176c" name="ada128f1703a9355dd6e2d1e84d30176c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada128f1703a9355dd6e2d1e84d30176c">&#9670;&#160;</a></span>TrackStateProxy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::TrackStateProxy </td>
          <td>(</td>
          <td class="paramtype">const TrackStateProxy&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from mutable TrackStateProxy. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to construct from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a71b5772cf7d277d0f2b8051adb619188" name="a71b5772cf7d277d0f2b8051adb619188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b5772cf7d277d0f2b8051adb619188">&#9670;&#160;</a></span>addComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::addComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add additional components to the track state. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is not read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The bitmask that instructs which components to allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75189bd3307977a4a78fcf7b380f1dcc" name="a75189bd3307977a4a78fcf7b380f1dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75189bd3307977a4a78fcf7b380f1dcc">&#9670;&#160;</a></span>allocateCalibrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename val_t, typename cov_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a> &amp;&amp; Concepts::eigen_base_is_fixed_size&lt;val_t&gt; &amp;&amp; Concepts::eigen_bases_have_same_num_rows&lt;val_t, cov_t&gt; &amp;&amp; Concepts::eigen_base_is_square&lt;cov_t&gt; &amp;&amp; Eigen::PlainObjectBase&lt;val_t&gt;::RowsAtCompileTime &lt;= static_cast&lt;std::underlying_type_t&lt;<a class="el" href="namespace_acts.html#ad2b38e86cfd40fa19fe61c74e8ca9fc7">BoundIndices</a>&gt;&gt;(<a class="el" href="namespace_acts.html#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>))</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::allocateCalibrated </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; val_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; cov_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cov</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage and assign the given vector and covariance to it. </p>
<p>The dimension is inferred from the given vector and matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">val_t</td><td>Type of the vector </td></tr>
    <tr><td class="paramname">cov_t</td><td>Type of the covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The measurement vector </td></tr>
    <tr><td class="paramname">cov</td><td>The covariance matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does not allocate if an allocation of the same size already exists </dd>
<dd>
This throws an exception if an existing allocation has different size </dd></dl>

</div>
</div>
<a id="a8a6f76ec69c3de04836a2d2982be565a" name="a8a6f76ec69c3de04836a2d2982be565a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6f76ec69c3de04836a2d2982be565a">&#9670;&#160;</a></span>allocateCalibrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::allocateCalibrated </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>measdim</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage to be able to store a measurement of size <code class="param">measdim</code>. </p>
<p>This must be called <b>before</b> setting the measurement content. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measdim</td><td>Number of measurement dimensions to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does not allocate if an allocation of the same size already exists </dd>
<dd>
This will zero-initialize the allocated storage </dd>
<dd>
This is an error if an existing allocation has different size </dd></dl>

</div>
</div>
<a id="ac3d2e674d8e36b45761fcaf1caa0ffab" name="ac3d2e674d8e36b45761fcaf1caa0ffab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d2e674d8e36b45761fcaf1caa0ffab">&#9670;&#160;</a></span>calibrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t measdim&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a84a42178bff9f1910351298b15ccf4db">Calibrated</a>&lt; measdim &gt; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full calibrated measurement vector. </p>
<p>Might contain additional zeroed dimensions. </p><dl class="section return"><dt>Returns</dt><dd>The measurement vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="afe7a343367038a1d6fe1fee9e6a9f6cb" name="afe7a343367038a1d6fe1fee9e6a9f6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7a343367038a1d6fe1fee9e6a9f6cb">&#9670;&#160;</a></span>calibrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t measdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6bc7781170388e6a5efc5dbfba2e369b">ConstCalibrated</a>&lt; measdim &gt; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full calibrated measurement vector. </p>
<p>Might contain additional zeroed dimensions. </p><dl class="section return"><dt>Returns</dt><dd>The measurement vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="a9b043aaf908b373b227442f28dcffef0" name="a9b043aaf908b373b227442f28dcffef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b043aaf908b373b227442f28dcffef0">&#9670;&#160;</a></span>calibratedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t measdim&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a03724890b6b3af53493fcf54884f02b7">CalibratedCovariance</a>&lt; measdim &gt; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable full calibrated measurement covariance matrix. </p>
<p>The effective covariance is located in the top left corner, everything else is zeroed. </p><dl class="section return"><dt>Returns</dt><dd>The measurement covariance matrix </dd></dl>

</div>
</div>
<a id="ac29e126eabff173682c068abef7b7a09" name="ac29e126eabff173682c068abef7b7a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29e126eabff173682c068abef7b7a09">&#9670;&#160;</a></span>calibratedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t measdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a105d545b90be92b01c15163e89b8c763">ConstCalibratedCovariance</a>&lt; measdim &gt; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const full calibrated measurement covariance matrix. </p>
<p>The effective covariance is located in the top left corner, everything else is zeroed. </p><dl class="section return"><dt>Returns</dt><dd>The measurement covariance matrix </dd></dl>

</div>
</div>
<a id="a9288cb73d98dd95221ae6dd086d802fd" name="a9288cb73d98dd95221ae6dd086d802fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9288cb73d98dd95221ae6dd086d802fd">&#9670;&#160;</a></span>calibratedSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the (dynamic) number of dimensions stored for this measurement. </p>
<dl class="section note"><dt>Note</dt><dd>Depending on the backend, this size is used to determine the memory range of the measurement vector and covariance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dimensions </dd></dl>

</div>
</div>
<a id="a85f2647845454a5b97deb8f4f87ccd67" name="a85f2647845454a5b97deb8f4f87ccd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f2647845454a5b97deb8f4f87ccd67">&#9670;&#160;</a></span>chi2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::chi2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter/setter for chi2 value associated with the track state This overload returns a mutable reference, which allows setting a new value directly into the backing store. </p>
<dl class="section note"><dt>Note</dt><dd>this overload is only enabled in case the proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the chi2 value </dd></dl>

</div>
</div>
<a id="a90fc7a4cd16b48d1eb30e01e40114ead" name="a90fc7a4cd16b48d1eb30e01e40114ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fc7a4cd16b48d1eb30e01e40114ead">&#9670;&#160;</a></span>chi2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::chi2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the chi2 value associated with the track state. </p>
<p>This overload returns a copy of the chi2 value, and thus does not allow modification of the value in the backing storage. </p><dl class="section return"><dt>Returns</dt><dd>the chi2 value of the track state </dd></dl>

</div>
</div>
<a id="a1accd7846f32112e931dc3cbe683ae4a" name="a1accd7846f32112e931dc3cbe683ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1accd7846f32112e931dc3cbe683ae4a">&#9670;&#160;</a></span>component() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a02384247b8232dfcfe24ad0e8a54773e" name="a02384247b8232dfcfe24ad0e8a54773e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02384247b8232dfcfe24ad0e8a54773e">&#9670;&#160;</a></span>component() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a7fa8a0971eb199e1f77c669ea485e93b" name="a7fa8a0971eb199e1f77c669ea485e93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa8a0971eb199e1f77c669ea485e93b">&#9670;&#160;</a></span>component() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a3e2161c9e5d0ab6781732ba63f81f379" name="a3e2161c9e5d0ab6781732ba63f81f379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2161c9e5d0ab6781732ba63f81f379">&#9670;&#160;</a></span>component() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="aaba9ae1881ae6d359047c983abead7e5" name="aaba9ae1881ae6d359047c983abead7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba9ae1881ae6d359047c983abead7e5">&#9670;&#160;</a></span>component() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="aa5176de3179f8fa3a6f69bf4697842e4" name="aa5176de3179f8fa3a6f69bf4697842e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5176de3179f8fa3a6f69bf4697842e4">&#9670;&#160;</a></span>component() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a9eeeb3cd9207c308fa6bf497318d1f0d" name="a9eeeb3cd9207c308fa6bf497318d1f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeeb3cd9207c308fa6bf497318d1f0d">&#9670;&#160;</a></span>container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::container </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable reference to the track state container backend. </p>
<dl class="section return"><dt>Returns</dt><dd>a mutable reference to the backend </dd></dl>

</div>
</div>
<a id="a28f8e6a2a933d5979843a6327d700349" name="a28f8e6a2a933d5979843a6327d700349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f8e6a2a933d5979843a6327d700349">&#9670;&#160;</a></span>container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::container </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to the track state container backend. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the backend </dd></dl>

</div>
</div>
<a id="affcbffae2f5137aad8fbc5dffe187f2e" name="affcbffae2f5137aad8fbc5dffe187f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcbffae2f5137aad8fbc5dffe187f2e">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;TrackStateProxyConcept track_state_proxy_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const track_state_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">TrackStatePropMask::All</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>onlyAllocated</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of another track state proxy into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other track state to copy from </td></tr>
    <tr><td class="paramname">mask</td><td>An optional mask to determine what to copy from </td></tr>
    <tr><td class="paramname">onlyAllocated</td><td>Whether to only copy allocated components </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the this track state proxy does not have compatible allocations with the source track state proxy, and <code class="param">onlyAllocated</code> is false, an exception is thrown. </dd>
<dd>
The mask parameter will not cause a copy of components that are not allocated in the source track state proxy. </dd></dl>

</div>
</div>
<a id="a65d0c723360f1c46b76d72c8e657c20e" name="a65d0c723360f1c46b76d72c8e657c20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d0c723360f1c46b76d72c8e657c20e">&#9670;&#160;</a></span>covariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::covariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track parameters covariance matrix. </p>
<p>This tries to be somewhat smart and return the first parameters that are set in this order: predicted -&gt; filtered -&gt; smoothed </p><dl class="section return"><dt>Returns</dt><dd>one of predicted, filtered or smoothed covariances </dd></dl>

</div>
</div>
<a id="ae5254b01a1b33f36fd4f6769f91a7b75" name="ae5254b01a1b33f36fd4f6769f91a7b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5254b01a1b33f36fd4f6769f91a7b75">&#9670;&#160;</a></span>effectiveCalibrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab0ed08ca7282b3640c3e5d16f6a62e42">EffectiveCalibrated</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::effectiveCalibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable dynamic measurement vector with only the valid dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>The dynamic vector has a runtime overhead! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The effective calibrated measurement vector </dd></dl>

</div>
</div>
<a id="a61f7c3790deb443faad73b06d7c24a25" name="a61f7c3790deb443faad73b06d7c24a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f7c3790deb443faad73b06d7c24a25">&#9670;&#160;</a></span>effectiveCalibrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7fbdcef77447c959db9a629ce2a1a50a">ConstEffectiveCalibrated</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::effectiveCalibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const dynamic measurement vector with only the valid dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>The dynamic matrix has a runtime overhead! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The effective calibrated measurement vector </dd></dl>

</div>
</div>
<a id="aaa274eb254b676d8d0119bffbdcb9908" name="aaa274eb254b676d8d0119bffbdcb9908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa274eb254b676d8d0119bffbdcb9908">&#9670;&#160;</a></span>effectiveCalibratedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af37dee5477fc8f723ed159dd0bd4cf0b">EffectiveCalibratedCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::effectiveCalibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable dynamic measurement covariance matrix with only the valid dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>The dynamic matrix has a runtime overhead! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The effective calibrated covariance matrix </dd></dl>

</div>
</div>
<a id="a8036047e6c138e2888529a31ac33298b" name="a8036047e6c138e2888529a31ac33298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8036047e6c138e2888529a31ac33298b">&#9670;&#160;</a></span>effectiveCalibratedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1ef98ae9574bf01c97c83eb7ab023257">ConstEffectiveCalibratedCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::effectiveCalibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const dynamic measurement covariance matrix with only the valid dimensions. </p>
<dl class="section warning"><dt>Warning</dt><dd>The dynamic matrix has a runtime overhead! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The effective calibrated covariance matrix </dd></dl>

</div>
</div>
<a id="a7f3a51475b679a985958b031a8334aa3" name="a7f3a51475b679a985958b031a8334aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3a51475b679a985958b031a8334aa3">&#9670;&#160;</a></span>filtered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::filtered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtered track parameters vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The filtered parameters </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="abb2e4ad815d47c72825530f63b639c18" name="abb2e4ad815d47c72825530f63b639c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2e4ad815d47c72825530f63b639c18">&#9670;&#160;</a></span>filtered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::filtered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtered track parameters vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The filtered parameters </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="a41cbf81de0b526690dabc86978f22f94" name="a41cbf81de0b526690dabc86978f22f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cbf81de0b526690dabc86978f22f94">&#9670;&#160;</a></span>filteredCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::filteredCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtered track parameters covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The filtered parameters covariance </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="ac6eaecab80e562c1634b64aff25aab8f" name="ac6eaecab80e562c1634b64aff25aab8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6eaecab80e562c1634b64aff25aab8f">&#9670;&#160;</a></span>filteredCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::filteredCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtered track parameters covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The filtered parameters covariance </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="ad287abac373d7c888eb39f26c1fff117" name="ad287abac373d7c888eb39f26c1fff117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad287abac373d7c888eb39f26c1fff117">&#9670;&#160;</a></span>getMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::getMask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a mask that represents all the allocated components of this track state proxy. </p>
<dl class="section return"><dt>Returns</dt><dd>The generated mask </dd></dl>

</div>
</div>
<a id="ae735c7f377c9d136cd0dae9b404e1363" name="ae735c7f377c9d136cd0dae9b404e1363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae735c7f377c9d136cd0dae9b404e1363">&#9670;&#160;</a></span>getUncalibratedSourceLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::getUncalibratedSourceLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncalibrated measurement in the form of a source link. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The uncalibrated measurement source link </dd></dl>

</div>
</div>
<a id="af1035fd64a07b94bf5df59e5c84978f8" name="af1035fd64a07b94bf5df59e5c84978f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1035fd64a07b94bf5df59e5c84978f8">&#9670;&#160;</a></span>has() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::has </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a component is set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>Hashed string key to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the component exists, false if not </dd></dl>

</div>
</div>
<a id="a2f032c5a6b354bcf96c600429dd47dbd" name="a2f032c5a6b354bcf96c600429dd47dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f032c5a6b354bcf96c600429dd47dbd">&#9670;&#160;</a></span>has() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::has </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a component is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Hashed string key to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the component exists, false if not </dd></dl>

</div>
</div>
<a id="a05ba115f5833ed450aa28e94cd21e2f2" name="a05ba115f5833ed450aa28e94cd21e2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ba115f5833ed450aa28e94cd21e2f2">&#9670;&#160;</a></span>has() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::has </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a component is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the component exists, false if not </dd></dl>

</div>
</div>
<a id="aa80699dc9461dc0d1b1b6b17e203c8ec" name="aa80699dc9461dc0d1b1b6b17e203c8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80699dc9461dc0d1b1b6b17e203c8ec">&#9670;&#160;</a></span>hasCalibrated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasCalibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the point has an associated calibrated measurement. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="aa275b2ab0856e73063d3bd9a8b7dee18" name="aa275b2ab0856e73063d3bd9a8b7dee18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa275b2ab0856e73063d3bd9a8b7dee18">&#9670;&#160;</a></span>hasColumn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the track state has a specific dynamic column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The hashed column key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the column exists </dd></dl>

</div>
</div>
<a id="a0ec76319889f85df89ce3737b0e906ae" name="a0ec76319889f85df89ce3737b0e906ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec76319889f85df89ce3737b0e906ae">&#9670;&#160;</a></span>hasFiltered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasFiltered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether filtered parameters+covariance is set. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="a7bfb1018523bdc51926cfd496e307884" name="a7bfb1018523bdc51926cfd496e307884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bfb1018523bdc51926cfd496e307884">&#9670;&#160;</a></span>hasJacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasJacobian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a jacobian is set for this trackstate. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="aaf6cafec36023994f719063de8426b1d" name="aaf6cafec36023994f719063de8426b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6cafec36023994f719063de8426b1d">&#9670;&#160;</a></span>hasPredicted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasPredicted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the predicted parameters+covariance is set. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set or not </dd></dl>

</div>
</div>
<a id="acd53c076b390ca5f20107a7390d3be00" name="acd53c076b390ca5f20107a7390d3be00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd53c076b390ca5f20107a7390d3be00">&#9670;&#160;</a></span>hasPrevious()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasPrevious </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether this track state has a previous (parent) track state. </p>
<dl class="section return"><dt>Returns</dt><dd>Boolean indicating whether a previous track state exists </dd></dl>

</div>
</div>
<a id="a7ed085b267c5ea71fb7849b13e0d673b" name="a7ed085b267c5ea71fb7849b13e0d673b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed085b267c5ea71fb7849b13e0d673b">&#9670;&#160;</a></span>hasProjector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasProjector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a projector is set. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="a9a727e6069185f42a12198df597e7c6e" name="a9a727e6069185f42a12198df597e7c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a727e6069185f42a12198df597e7c6e">&#9670;&#160;</a></span>hasReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasReferenceSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the track state has a non nullptr surface associated. </p>
<dl class="section return"><dt>Returns</dt><dd>whether a surface exists or not </dd></dl>

</div>
</div>
<a id="a0b5e6983a57f0fc7a126a75b9dbf377b" name="a0b5e6983a57f0fc7a126a75b9dbf377b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5e6983a57f0fc7a126a75b9dbf377b">&#9670;&#160;</a></span>hasSmoothed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasSmoothed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether smoothed parameters+covariance is set. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="a9861fa7fb806028eb6ab74c98152e9c1" name="a9861fa7fb806028eb6ab74c98152e9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9861fa7fb806028eb6ab74c98152e9c1">&#9670;&#160;</a></span>hasUncalibratedSourceLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasUncalibratedSourceLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the point has an associated uncalibrated measurement. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="a0c262c2b5ad8f0c90c99a157de006a60" name="a0c262c2b5ad8f0c90c99a157de006a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c262c2b5ad8f0c90c99a157de006a60">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index within the trajectory. </p>
<dl class="section return"><dt>Returns</dt><dd>the index </dd></dl>

</div>
</div>
<a id="a646005da1a4e0fd60e864735dbbb4254" name="a646005da1a4e0fd60e864735dbbb4254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646005da1a4e0fd60e864735dbbb4254">&#9670;&#160;</a></span>jacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::jacobian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the jacobian from the previous trackstate to this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The jacobian matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="a963bb4bd89f7e9f6db39b0215ef7ae28" name="a963bb4bd89f7e9f6db39b0215ef7ae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963bb4bd89f7e9f6db39b0215ef7ae28">&#9670;&#160;</a></span>jacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::jacobian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the jacobian from the previous trackstate to this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The jacobian matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="a4b952743d6b1f741c480358fc8674e49" name="a4b952743d6b1f741c480358fc8674e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b952743d6b1f741c480358fc8674e49">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator: const to const or mutable to mutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this TrackStateProxy </dd></dl>

</div>
</div>
<a id="a2a7d2d25ba9d29f2d08793e7d82a323d" name="a2a7d2d25ba9d29f2d08793e7d82a323d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7d2d25ba9d29f2d08793e7d82a323d">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator to from mutable <code>TrackStateProxy</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this TrackStateProxy </dd></dl>

</div>
</div>
<a id="a0ca1157f1c278b89658764e4939d3521" name="a0ca1157f1c278b89658764e4939d3521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca1157f1c278b89658764e4939d3521">&#9670;&#160;</a></span>parameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::parameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track parameters vector. </p>
<p>This tries to be somewhat smart and return the first parameters that are set in this order: predicted -&gt; filtered -&gt; smoothed </p><dl class="section return"><dt>Returns</dt><dd>one of predicted, filtered or smoothed parameters </dd></dl>

</div>
</div>
<a id="adfe74e3cdfb647c0eb7d3736bdb5b240" name="adfe74e3cdfb647c0eb7d3736bdb5b240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe74e3cdfb647c0eb7d3736bdb5b240">&#9670;&#160;</a></span>pathLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::pathLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the path length associated with the track state. </p>
<p>This overloaded is only enabled if not read-only, and returns a mutable reference. </p><dl class="section return"><dt>Returns</dt><dd>Mutable reference to the pathlength. </dd></dl>

</div>
</div>
<a id="a073670d75bc434c1372c5c9bb906fdab" name="a073670d75bc434c1372c5c9bb906fdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073670d75bc434c1372c5c9bb906fdab">&#9670;&#160;</a></span>pathLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::pathLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the path length. </p>
<p>Returns a copy of the path length value. </p><dl class="section return"><dt>Returns</dt><dd>The path length of this track state </dd></dl>

</div>
</div>
<a id="a45ce34be1d32b194bd6e745cc482b4b6" name="a45ce34be1d32b194bd6e745cc482b4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ce34be1d32b194bd6e745cc482b4b6">&#9670;&#160;</a></span>predicted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::predicted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicted track parameters vector (non-const version). </p>
<dl class="section return"><dt>Returns</dt><dd>The predicted parameters with mutable access </dd></dl>

</div>
</div>
<a id="ada133337d6cd728e6439e568f2171a8f" name="ada133337d6cd728e6439e568f2171a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada133337d6cd728e6439e568f2171a8f">&#9670;&#160;</a></span>predicted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::predicted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicted track parameters vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The predicted parameters </dd></dl>

</div>
</div>
<a id="a2c7f64e6e75d1cbd41dfd9dd5b63cce7" name="a2c7f64e6e75d1cbd41dfd9dd5b63cce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7f64e6e75d1cbd41dfd9dd5b63cce7">&#9670;&#160;</a></span>predictedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::predictedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicted track parameters covariance matrix (non-const version). </p>
<dl class="section return"><dt>Returns</dt><dd>The predicted track parameter covariance with mutable access </dd></dl>

</div>
</div>
<a id="ad7b768ceb432a5bf536354e25057220b" name="ad7b768ceb432a5bf536354e25057220b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b768ceb432a5bf536354e25057220b">&#9670;&#160;</a></span>predictedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::predictedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Predicted track parameters covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The predicted track parameter covariance </dd></dl>

</div>
</div>
<a id="adab3254d35183a268e201ee8f0736d6f" name="adab3254d35183a268e201ee8f0736d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab3254d35183a268e201ee8f0736d6f">&#9670;&#160;</a></span>previous() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::previous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the index of the track state 'previous' in the track sequence. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the previous track state. </dd></dl>

</div>
</div>
<a id="ae7d2d40aef71d1739184fd08eda93ac1" name="ae7d2d40aef71d1739184fd08eda93ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d2d40aef71d1739184fd08eda93ac1">&#9670;&#160;</a></span>previous() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::previous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the track state <span class="tt">previous</span> in the track sequence. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the previous track state. </dd></dl>

</div>
</div>
<a id="a597bd8143b2e3614fbbc37e7313c99d4" name="a597bd8143b2e3614fbbc37e7313c99d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597bd8143b2e3614fbbc37e7313c99d4">&#9670;&#160;</a></span>projectorSubspaceHelper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t measdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a9bc2353f4da72bb7afd4d868e278150c">FixedBoundSubspaceHelper</a>&lt; measdim &gt; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::projectorSubspaceHelper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a fixed size subspace helper. </p>
<dl class="section return"><dt>Returns</dt><dd>The subspace helper </dd></dl>

</div>
</div>
<a id="ae69bdc29fac30b3f4c9cf84b1f965c82" name="ae69bdc29fac30b3f4c9cf84b1f965c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69bdc29fac30b3f4c9cf84b1f965c82">&#9670;&#160;</a></span>projectorSubspaceHelper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#aaaa9c77f4dd9efc1ac464d9a941f2ef2">VariableBoundSubspaceHelper</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::projectorSubspaceHelper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a variable size subspace helper. </p>
<dl class="section return"><dt>Returns</dt><dd>The subspace helper </dd></dl>

</div>
</div>
<a id="a388c57d9949076de1007c211c6924ea6" name="a388c57d9949076de1007c211c6924ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388c57d9949076de1007c211c6924ea6">&#9670;&#160;</a></span>projectorSubspaceIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t measdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; measdim &gt; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::projectorSubspaceIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the projector subspace indices. </p>
<dl class="section return"><dt>Returns</dt><dd>The projector subspace indices </dd></dl>

</div>
</div>
<a id="ab743ff83d4fe00e15bb27997e9dde3d0" name="ab743ff83d4fe00e15bb27997e9dde3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab743ff83d4fe00e15bb27997e9dde3d0">&#9670;&#160;</a></span>projectorSubspaceIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::projectorSubspaceIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the projector subspace indices. </p>
<dl class="section return"><dt>Returns</dt><dd>The projector subspace indices </dd></dl>

</div>
</div>
<a id="a412f66e00d2d9194b0d1c1adee50a279" name="a412f66e00d2d9194b0d1c1adee50a279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412f66e00d2d9194b0d1c1adee50a279">&#9670;&#160;</a></span>referenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::referenceSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>the reference surface </dd></dl>

</div>
</div>
<a id="ae6d44df80cc0f018e5758cd0e20a2b81" name="ae6d44df80cc0f018e5758cd0e20a2b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d44df80cc0f018e5758cd0e20a2b81">&#9670;&#160;</a></span>setProjectorSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::ranges::sized_range index_range_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a> &amp;&amp; std::convertible_to&lt;std::ranges::range_value_t&lt;index_range_t&gt;, std::uint8_t&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::setProjectorSubspaceIndices </td>
          <td>(</td>
          <td class="paramtype">const index_range_t &amp;</td>          <td class="paramname"><span class="paramname"><em>subspaceIndices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the projector subspace indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subspaceIndices</td><td>The projector subspace indices to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57835d73120cd60cf7dd0c37fa92d3c3" name="a57835d73120cd60cf7dd0c37fa92d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57835d73120cd60cf7dd0c37fa92d3c3">&#9670;&#160;</a></span>setReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::setReferenceSurface </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>srf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference surface to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srf</td><td>Shared pointer to the surface to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is only present in case <code>ReadOnly</code> is false. </dd></dl>

</div>
</div>
<a id="ad9e34422bd144eca89d0a0a3a3b085ab" name="ad9e34422bd144eca89d0a0a3a3b085ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e34422bd144eca89d0a0a3a3b085ab">&#9670;&#160;</a></span>setUncalibratedSourceLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::setUncalibratedSourceLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sourceLink</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an uncalibrated source link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceLink</td><td>The uncalibrated source link to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8086412d1967b46203d8a00c0811e8de" name="a8086412d1967b46203d8a00c0811e8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8086412d1967b46203d8a00c0811e8de">&#9670;&#160;</a></span>shareFrom() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::shareFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>component</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share a shareable component from another track state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Track state proxy to share component from </td></tr>
    <tr><td class="paramname">component</td><td>Which component to share. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The track states both need to be stored in the same <code>MultiTrajectory</code> instance </dd></dl>

</div>
</div>
<a id="a4bb9736a7c382a83ce79d543f563e6f9" name="a4bb9736a7c382a83ce79d543f563e6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb9736a7c382a83ce79d543f563e6f9">&#9670;&#160;</a></span>shareFrom() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::shareFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareTarget</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share a shareable component from another track state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Track state proxy to share component(s) from </td></tr>
    <tr><td class="paramname">shareSource</td><td>Which component to share from </td></tr>
    <tr><td class="paramname">shareTarget</td><td>Which component to share as. This can be be different from as <code class="param">shareSource</code>, e.g. predicted can be shared as filtered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Shareable components are predicted, filtered, smoothed, calibrated, jacobian, or projector. See <code>TrackStatePropMask</code>. </dd></dl>

</div>
</div>
<a id="a95304204468f54911b50a674f7ada1d6" name="a95304204468f54911b50a674f7ada1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95304204468f54911b50a674f7ada1d6">&#9670;&#160;</a></span>shareFrom() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::shareFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareTarget</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share a shareable component <b>within</b> this track state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shareSource</td><td>Which component to share from </td></tr>
    <tr><td class="paramname">shareTarget</td><td>Which component to share as. This should be different from as <code class="param">shareSource</code>, e.g. predicted can be shared as filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a1592698a419f1bd19dc95119c4cda7" name="a3a1592698a419f1bd19dc95119c4cda7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1592698a419f1bd19dc95119c4cda7">&#9670;&#160;</a></span>smoothed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab2488c63138a9366f18d8cadd64aeee6">Parameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::smoothed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed track parameters vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The smoothed parameters </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="ab6de4dd6ddb5a3cba4e1145e9880b12b" name="ab6de4dd6ddb5a3cba4e1145e9880b12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6de4dd6ddb5a3cba4e1145e9880b12b">&#9670;&#160;</a></span>smoothed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::smoothed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed track parameters vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The smoothed parameters </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="a2af36064b9675a42205b741182810248" name="a2af36064b9675a42205b741182810248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af36064b9675a42205b741182810248">&#9670;&#160;</a></span>smoothedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae6bbe39dbafb35e54bf3de684beb16ea">Covariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::smoothedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed track parameters covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>the parameter covariance matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="a7f881d68f2cdd0a1fbc7a4019dc13826" name="a7f881d68f2cdd0a1fbc7a4019dc13826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f881d68f2cdd0a1fbc7a4019dc13826">&#9670;&#160;</a></span>smoothedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::smoothedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoothed track parameters covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>the parameter covariance matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="a5fbed9bb3b46afcbd08f6d8559b55684" name="a5fbed9bb3b46afcbd08f6d8559b55684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbed9bb3b46afcbd08f6d8559b55684">&#9670;&#160;</a></span>trajectory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::trajectory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the underlying backend container. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the backend container </dd></dl>

</div>
</div>
<a id="a400c5a87fdeb279c3c705463f95195ff" name="a400c5a87fdeb279c3c705463f95195ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400c5a87fdeb279c3c705463f95195ff">&#9670;&#160;</a></span>trajectory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::trajectory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the underlying backend container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the backend container </dd></dl>

</div>
</div>
<a id="a346c4791f935c4aa667b50852ed96349" name="a346c4791f935c4aa667b50852ed96349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346c4791f935c4aa667b50852ed96349">&#9670;&#160;</a></span>typeFlags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_type.html">TrackStateType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::typeFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the type flags associated with the track state. </p>
<p>This overloaded is only enabled if not read-only, and returns a mutable reference. </p><dl class="section return"><dt>Returns</dt><dd>reference to the type flags. </dd></dl>

</div>
</div>
<a id="a3f8d5bc54cb20d0cc76c1776d82cbd0f" name="a3f8d5bc54cb20d0cc76c1776d82cbd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8d5bc54cb20d0cc76c1776d82cbd0f">&#9670;&#160;</a></span>typeFlags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_const_track_state_type.html">ConstTrackStateType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::typeFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the type flags. </p>
<p>Returns a copy of the type flags value. </p><dl class="section return"><dt>Returns</dt><dd>The type flags of this track state </dd></dl>

</div>
</div>
<a id="a58ecea4d41d25884af489e1391a1fdb5" name="a58ecea4d41d25884af489e1391a1fdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ecea4d41d25884af489e1391a1fdb5">&#9670;&#160;</a></span>unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset an optional track state component. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is not read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The component to unset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="ac971a8625ee702ef7cb743fa52e4f186" name="ac971a8625ee702ef7cb743fa52e4f186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac971a8625ee702ef7cb743fa52e4f186">&#9670;&#160;</a></span>kInvalid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::kInvalid = <a class="el" href="namespace_acts.html#a589e3f01b082df3de46c2a6f5e6ce749">kTrackIndexInvalid</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sentinel value that indicates an invalid index. </p>

</div>
</div>
<a id="a99b5acfc879ef16dc1c017452b5bbe87" name="a99b5acfc879ef16dc1c017452b5bbe87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b5acfc879ef16dc1c017452b5bbe87">&#9670;&#160;</a></span>ReadOnly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ReadOnly = read_only</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this track state proxy is read-only or if it can be modified. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="class_acts_1_1_track_state_proxy.html">TrackStateProxy</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
