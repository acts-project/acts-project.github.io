<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::MultiStepperLoop&lt; single_stepper_t, component_reducer_t &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_multi_stepper_loop.html','','class_acts_1_1_multi_stepper_loop-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::MultiStepperLoop&lt; single_stepper_t, component_reducer_t &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Stepper based on a single-component stepper, but can handle Multi-Component Tracks (e.g., for the GSF).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_multi_stepper_loop_8hpp_source.html">Acts/Propagator/MultiStepperLoop.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::MultiStepperLoop&lt; single_stepper_t, component_reducer_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_multi_stepper_loop__inherit__graph.svg" width="314" height="286"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Acts::MultiStepperLoop&lt; single_stepper_t, component_reducer_t &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_multi_stepper_loop__coll__graph.svg" width="236" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Config" id="r_Config"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_config.html">Config</a></td></tr>
<tr class="memitem:Options" id="r_Options"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_options.html">Options</a></td></tr>
<tr class="memitem:State" id="r_State"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a25bae4907217345239b06d2fa164dccb" id="r_a25bae4907217345239b06d2fa164dccb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25bae4907217345239b06d2fa164dccb">BoundState</a></td></tr>
<tr class="memdesc:a25bae4907217345239b06d2fa164dccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an own bound state.  <br /></td></tr>
<tr class="memitem:a4c04e0a4abab2458b926bbd31a22786a" id="r_a4c04e0a4abab2458b926bbd31a22786a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c04e0a4abab2458b926bbd31a22786a">ComponentProxy</a></td></tr>
<tr class="memdesc:a4c04e0a4abab2458b926bbd31a22786a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy struct which allows access to a single component of the multi-component state.  <br /></td></tr>
<tr class="memitem:ae7f0c6ca518ae97111f67a4da70423ed" id="r_ae7f0c6ca518ae97111f67a4da70423ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7f0c6ca518ae97111f67a4da70423ed">ConstComponentProxy</a></td></tr>
<tr class="memdesc:ae7f0c6ca518ae97111f67a4da70423ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy struct which allows access to a single component of the multi-component state.  <br /></td></tr>
<tr class="memitem:a49f9ef065470ab990eec8f3e01eb698a" id="r_a49f9ef065470ab990eec8f3e01eb698a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f9ef065470ab990eec8f3e01eb698a">Reducer</a> = component_reducer_t</td></tr>
<tr class="memdesc:a49f9ef065470ab990eec8f3e01eb698a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reducer type.  <br /></td></tr>
<tr class="memitem:ac48fd14cb18d559b290831a2736f312d" id="r_ac48fd14cb18d559b290831a2736f312d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac48fd14cb18d559b290831a2736f312d">SingleConfig</a> = typename SingleStepper::Config</td></tr>
<tr class="memdesc:ac48fd14cb18d559b290831a2736f312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to the Config of the single component Stepper.  <br /></td></tr>
<tr class="memitem:aa0f294a69febb3a5fad1e0adae46e0a7" id="r_aa0f294a69febb3a5fad1e0adae46e0a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f294a69febb3a5fad1e0adae46e0a7">SingleOptions</a> = typename SingleStepper::Options</td></tr>
<tr class="memdesc:aa0f294a69febb3a5fad1e0adae46e0a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to the Single-Component Stepper Options.  <br /></td></tr>
<tr class="memitem:afb16bd3a77436790ee0e1c4148fb5cf7" id="r_afb16bd3a77436790ee0e1c4148fb5cf7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb16bd3a77436790ee0e1c4148fb5cf7">SingleState</a> = typename SingleStepper::State</td></tr>
<tr class="memdesc:afb16bd3a77436790ee0e1c4148fb5cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to the State of the single component Stepper.  <br /></td></tr>
<tr class="memitem:a7767f8dd7e4a4a2aec00b0ed9a7411f1" id="r_a7767f8dd7e4a4a2aec00b0ed9a7411f1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7767f8dd7e4a4a2aec00b0ed9a7411f1">SingleStepper</a> = single_stepper_t</td></tr>
<tr class="memdesc:a7767f8dd7e4a4a2aec00b0ed9a7411f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to the Single-Component Eigen Stepper.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1c5570e468bf963682ca070c9ca5246" id="r_af1c5570e468bf963682ca070c9ca5246"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c5570e468bf963682ca070c9ca5246">MultiStepperLoop</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_config.html">Config</a> &amp;config, std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &gt; logger=<a class="el" href="namespace_acts.html#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;MultiStepperLoop&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>))</td></tr>
<tr class="memdesc:af1c5570e468bf963682ca070c9ca5246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a configuration and optionally provided Logger.  <br /></td></tr>
<tr class="memitem:a570b81ba406b8c3eb2451cef7d4a4c15" id="r_a570b81ba406b8c3eb2451cef7d4a4c15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a570b81ba406b8c3eb2451cef7d4a4c15">MultiStepperLoop</a> (std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_magnetic_field_provider.html">MagneticFieldProvider</a> &gt; bField, std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &gt; logger=<a class="el" href="namespace_acts.html#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;GSF&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>))</td></tr>
<tr class="memdesc:a570b81ba406b8c3eb2451cef7d4a4c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a magnetic field and a optionally provided Logger TODO this requires that every stepper can be constructed like this...  <br /></td></tr>
<tr class="memitem:af0cffcbdb894dbb7ae97f435f573b4f3" id="r_af0cffcbdb894dbb7ae97f435f573b4f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0cffcbdb894dbb7ae97f435f573b4f3">absoluteMomentum</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:af0cffcbdb894dbb7ae97f435f573b4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute momentum accessor.  <br /></td></tr>
<tr class="memitem:aadb5485323be4c9842111031bc0b5b6b" id="r_aadb5485323be4c9842111031bc0b5b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#a4c04e0a4abab2458b926bbd31a22786a">ComponentProxy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadb5485323be4c9842111031bc0b5b6b">addComponent</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const <a class="el" href="namespace_acts.html#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a> &amp;pars, double weight) const</td></tr>
<tr class="memdesc:aadb5485323be4c9842111031bc0b5b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a component to the Multistepper.  <br /></td></tr>
<tr class="memitem:a88eb382ca93bd78bcbe82e430748ec20" id="r_a88eb382ca93bd78bcbe82e430748ec20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#a25bae4907217345239b06d2fa164dccb">BoundState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88eb382ca93bd78bcbe82e430748ec20">boundState</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, bool transportCov=true, const FreeToBoundCorrection &amp;freeToBoundCorrection=FreeToBoundCorrection(false)) const</td></tr>
<tr class="memdesc:a88eb382ca93bd78bcbe82e430748ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return the bound state at the current position.  <br /></td></tr>
<tr class="memitem:a5810edeb15d1733ba6447b4e1cbe7613" id="r_a5810edeb15d1733ba6447b4e1cbe7613"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5810edeb15d1733ba6447b4e1cbe7613">charge</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a5810edeb15d1733ba6447b4e1cbe7613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charge access.  <br /></td></tr>
<tr class="memitem:aad4ed104697bb10e91de477d0099958e" id="r_aad4ed104697bb10e91de477d0099958e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad4ed104697bb10e91de477d0099958e">clearComponents</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:aad4ed104697bb10e91de477d0099958e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the number of components.  <br /></td></tr>
<tr class="memitem:ae7493f780932d2a91057e1cde8b57d41" id="r_ae7493f780932d2a91057e1cde8b57d41"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7493f780932d2a91057e1cde8b57d41">componentIterable</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:ae7493f780932d2a91057e1cde8b57d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterable which can be plugged into a range-based for-loop to iterate over components.  <br /></td></tr>
<tr class="memitem:a8e36c69a3252b98c7e3a207dc2dc3360" id="r_a8e36c69a3252b98c7e3a207dc2dc3360"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e36c69a3252b98c7e3a207dc2dc3360">constComponentIterable</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a8e36c69a3252b98c7e3a207dc2dc3360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an constant iterable which can be plugged into a range-based for-loop to iterate over components.  <br /></td></tr>
<tr class="memitem:aa4655ee78def889ce17191cc2185a773" id="r_aa4655ee78def889ce17191cc2185a773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a25bae4907217345239b06d2fa164dccb">BoundState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4655ee78def889ce17191cc2185a773">curvilinearState</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, bool transportCov=true) const</td></tr>
<tr class="memdesc:aa4655ee78def889ce17191cc2185a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a curvilinear state at the current position.  <br /></td></tr>
<tr class="memitem:adfbd62497eb2d734077831f052b39917" id="r_adfbd62497eb2d734077831f052b39917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfbd62497eb2d734077831f052b39917">direction</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:adfbd62497eb2d734077831f052b39917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum direction accessor.  <br /></td></tr>
<tr class="memitem:ad02581b5a3f99db0fd84cb274e15272f" id="r_ad02581b5a3f99db0fd84cb274e15272f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad02581b5a3f99db0fd84cb274e15272f">getField</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;pos) const</td></tr>
<tr class="memdesc:ad02581b5a3f99db0fd84cb274e15272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the field for the stepping, it checks first if the access is still within the Cell, and updates the cell if necessary.  <br /></td></tr>
<tr class="memitem:a17c46fd3911200c3b49c41b1c71f70b2" id="r_a17c46fd3911200c3b49c41b1c71f70b2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17c46fd3911200c3b49c41b1c71f70b2">getStepSize</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, <a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a> stype) const</td></tr>
<tr class="memdesc:a17c46fd3911200c3b49c41b1c71f70b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the step size.  <br /></td></tr>
<tr class="memitem:a422d81f88543bdc4b38e50f464c9cde9" id="r_a422d81f88543bdc4b38e50f464c9cde9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422d81f88543bdc4b38e50f464c9cde9">initialize</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const <a class="el" href="class_acts_1_1_multi_component_bound_track_parameters.html">MultiComponentBoundTrackParameters</a> &amp;par) const</td></tr>
<tr class="memdesc:a422d81f88543bdc4b38e50f464c9cde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the stepper state from multi-component bound track parameters.  <br /></td></tr>
<tr class="memitem:ac294b68a4777e63aecb2b587f7e56643" id="r_ac294b68a4777e63aecb2b587f7e56643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac294b68a4777e63aecb2b587f7e56643">makeState</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_options.html">Options</a> &amp;options) const</td></tr>
<tr class="memdesc:ac294b68a4777e63aecb2b587f7e56643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a state object for multi-stepping.  <br /></td></tr>
<tr class="memitem:a0d05d15a0ba03da5a4e99820166ca3a4" id="r_a0d05d15a0ba03da5a4e99820166ca3a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d05d15a0ba03da5a4e99820166ca3a4">momentum</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a0d05d15a0ba03da5a4e99820166ca3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Momentum accessor.  <br /></td></tr>
<tr class="memitem:af7f7340a7bcdce9386b74280345687bf" id="r_af7f7340a7bcdce9386b74280345687bf"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7f7340a7bcdce9386b74280345687bf">numberComponents</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:af7f7340a7bcdce9386b74280345687bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of components.  <br /></td></tr>
<tr class="memitem:a350103911e41093a317343014652774d" id="r_a350103911e41093a317343014652774d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a350103911e41093a317343014652774d">outputStepSize</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a350103911e41093a317343014652774d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the Step Size of all components into one std::string.  <br /></td></tr>
<tr class="memitem:a2bd33807eab7aa336729b6e4071ddfa3" id="r_a2bd33807eab7aa336729b6e4071ddfa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bd33807eab7aa336729b6e4071ddfa3">particleHypothesis</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a2bd33807eab7aa336729b6e4071ddfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle hypothesis.  <br /></td></tr>
<tr class="memitem:a77b755cb0045ae54b5970effe08a041a" id="r_a77b755cb0045ae54b5970effe08a041a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77b755cb0045ae54b5970effe08a041a">position</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a77b755cb0045ae54b5970effe08a041a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global particle position accessor.  <br /></td></tr>
<tr class="memitem:a95bae37aba1f2ffb3da2bb6f283cbdc7" id="r_a95bae37aba1f2ffb3da2bb6f283cbdc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95bae37aba1f2ffb3da2bb6f283cbdc7">prepareCurvilinearState</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a95bae37aba1f2ffb3da2bb6f283cbdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If necessary fill additional members needed for curvilinearState.  <br /></td></tr>
<tr class="memitem:a996d6c0099ebc11d52f79e5a0cdd2f98" id="r_a996d6c0099ebc11d52f79e5a0cdd2f98"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a996d6c0099ebc11d52f79e5a0cdd2f98">qOverP</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a996d6c0099ebc11d52f79e5a0cdd2f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">QoP access.  <br /></td></tr>
<tr class="memitem:a8214196154e421fbc981aac7dd252de7" id="r_a8214196154e421fbc981aac7dd252de7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8214196154e421fbc981aac7dd252de7">releaseStepSize</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, <a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a> stype) const</td></tr>
<tr class="memdesc:a8214196154e421fbc981aac7dd252de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the step-size for all components.  <br /></td></tr>
<tr class="memitem:a2fde02c90ca222d08e69c44eac6ab577" id="r_a2fde02c90ca222d08e69c44eac6ab577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fde02c90ca222d08e69c44eac6ab577">removeMissedComponents</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a2fde02c90ca222d08e69c44eac6ab577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove missed components from the component state.  <br /></td></tr>
<tr class="memitem:a18148893c93190a148dec77b00b48d75" id="r_a18148893c93190a148dec77b00b48d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18148893c93190a148dec77b00b48d75">reweightComponents</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a18148893c93190a148dec77b00b48d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reweight the components.  <br /></td></tr>
<tr class="memitem:a5fd61a6fae614fee412c0cfc33d4f8ba" id="r_a5fd61a6fae614fee412c0cfc33d4f8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fd61a6fae614fee412c0cfc33d4f8ba">step</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, <a class="el" href="class_acts_1_1_direction.html">Direction</a> propDir, const <a class="el" href="class_acts_1_1_i_volume_material.html">IVolumeMaterial</a> *material) const</td></tr>
<tr class="memdesc:a5fd61a6fae614fee412c0cfc33d4f8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a Runge-Kutta track parameter propagation step.  <br /></td></tr>
<tr class="memitem:a302cbeff32f5f8d724ee18e1efeeb46d" id="r_a302cbeff32f5f8d724ee18e1efeeb46d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302cbeff32f5f8d724ee18e1efeeb46d">time</a> (const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a302cbeff32f5f8d724ee18e1efeeb46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time access.  <br /></td></tr>
<tr class="memitem:adaeaae8bc11f7964b91434cad7b2abb0" id="r_adaeaae8bc11f7964b91434cad7b2abb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaeaae8bc11f7964b91434cad7b2abb0">transportCovarianceToBound</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, const FreeToBoundCorrection &amp;freeToBoundCorrection=FreeToBoundCorrection(false)) const</td></tr>
<tr class="memdesc:adaeaae8bc11f7964b91434cad7b2abb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for on-demand transport of the covariance to a new curvilinear frame at current position, or direction of the state.  <br /></td></tr>
<tr class="memitem:a990dbc216f38984e57f1875b855e5aa8" id="r_a990dbc216f38984e57f1875b855e5aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a990dbc216f38984e57f1875b855e5aa8">transportCovarianceToCurvilinear</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state) const</td></tr>
<tr class="memdesc:a990dbc216f38984e57f1875b855e5aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method for on-demand transport of the covariance to a new curvilinear frame at current position, or direction of the state.  <br /></td></tr>
<tr class="memitem:adb7a1bdff195f1bc9ed9f2d2bc88e0e2" id="r_adb7a1bdff195f1bc9ed9f2d2bc88e0e2"><td class="memTemplParams" colspan="2">template&lt;typename object_intersection_t&gt; </td></tr>
<tr class="memitem:adb7a1bdff195f1bc9ed9f2d2bc88e0e2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb7a1bdff195f1bc9ed9f2d2bc88e0e2">updateStepSize</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const object_intersection_t &amp;oIntersection, <a class="el" href="class_acts_1_1_direction.html">Direction</a> <a class="el" href="#adfbd62497eb2d734077831f052b39917">direction</a>, <a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a> stype) const</td></tr>
<tr class="memdesc:adb7a1bdff195f1bc9ed9f2d2bc88e0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update step size.  <br /></td></tr>
<tr class="memitem:a8d8165ca37acd22cd0e423c7a8cd1625" id="r_a8d8165ca37acd22cd0e423c7a8cd1625"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8165ca37acd22cd0e423c7a8cd1625">updateStepSize</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, double stepSize, <a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a> stype) const</td></tr>
<tr class="memdesc:a8d8165ca37acd22cd0e423c7a8cd1625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update step size - explicitly with a double.  <br /></td></tr>
<tr class="memitem:a0dc60c5117467bf4f3aed5c0dc7dfdf3" id="r_a0dc60c5117467bf4f3aed5c0dc7dfdf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a52191edec34daa17746d1937fb06c1fb">IntersectionStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dc60c5117467bf4f3aed5c0dc7dfdf3">updateSurfaceStatus</a> (<a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;state, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, std::uint8_t index, <a class="el" href="class_acts_1_1_direction.html">Direction</a> navDir, const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;boundaryTolerance, double surfaceTolerance, <a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a> stype, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">getDummyLogger</a>()) const</td></tr>
<tr class="memdesc:a0dc60c5117467bf4f3aed5c0dc7dfdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update surface status.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af87a75205a8a0417f5072228a67143ca" id="r_af87a75205a8a0417f5072228a67143ca"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af87a75205a8a0417f5072228a67143ca">maxComponents</a> = std::numeric_limits&lt;int&gt;::max()</td></tr>
<tr class="memdesc:af87a75205a8a0417f5072228a67143ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many components can this stepper manage?  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt;<br />
class Acts::MultiStepperLoop&lt; single_stepper_t, component_reducer_t &gt;</div><p>Stepper based on a single-component stepper, but can handle Multi-Component Tracks (e.g., for the GSF). </p>
<p>Internally, this only manages a vector of states of the single stepper. This simplifies implementation, but has several drawbacks:</p><ul>
<li>There are certain redundancies between the global State and the component states</li>
<li>The components do not share a single magnetic-field-cache <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sstepper_t</td><td>The single-component stepper type to use </td></tr>
    <tr><td class="paramname">component_reducer_t</td><td>How to map the multi-component state to a single component </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a25bae4907217345239b06d2fa164dccb" name="a25bae4907217345239b06d2fa164dccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bae4907217345239b06d2fa164dccb">&#9670;&#160;</a></span>BoundState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::BoundState</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      std::tuple&lt;MultiComponentBoundTrackParameters, Jacobian, double&gt;</div>
</div><!-- fragment -->
<p>Define an own bound state. </p>

</div>
</div>
<a id="a4c04e0a4abab2458b926bbd31a22786a" name="a4c04e0a4abab2458b926bbd31a22786a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c04e0a4abab2458b926bbd31a22786a">&#9670;&#160;</a></span>ComponentProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::ComponentProxy</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      detail::LoopComponentProxy&lt;typename State::Component, MultiStepperLoop&gt;</div>
</div><!-- fragment -->
<p>A proxy struct which allows access to a single component of the multi-component state. </p>
<p>It has the semantics of a mutable reference, i.e. it requires a mutable reference of the single-component state it represents </p>

</div>
</div>
<a id="ae7f0c6ca518ae97111f67a4da70423ed" name="ae7f0c6ca518ae97111f67a4da70423ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f0c6ca518ae97111f67a4da70423ed">&#9670;&#160;</a></span>ConstComponentProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::ConstComponentProxy</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      detail::LoopComponentProxyBase&lt;<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code hl_struct" href="struct_acts_1_1_multi_stepper_loop_1_1_state_1_1_component.html">State::Component</a>,</div>
<div class="line">                                     <a class="code hl_function" href="#a570b81ba406b8c3eb2451cef7d4a4c15">MultiStepperLoop</a>&gt;</div>
<div class="ttc" id="aclass_acts_1_1_multi_stepper_loop_html_a570b81ba406b8c3eb2451cef7d4a4c15"><div class="ttname"><a href="#a570b81ba406b8c3eb2451cef7d4a4c15">Acts::MultiStepperLoop::MultiStepperLoop</a></div><div class="ttdeci">MultiStepperLoop(std::shared_ptr&lt; const MagneticFieldProvider &gt; bField, std::unique_ptr&lt; const Logger &gt; logger=getDefaultLogger(&quot;GSF&quot;, Logging::INFO))</div><div class="ttdoc">Constructor from a magnetic field and a optionally provided Logger TODO this requires that every step...</div><div class="ttdef"><b>Definition</b> MultiStepperLoop.hpp:241</div></div>
<div class="ttc" id="astruct_acts_1_1_multi_stepper_loop_1_1_state_1_1_component_html"><div class="ttname"><a href="struct_acts_1_1_multi_stepper_loop_1_1_state_1_1_component.html">Acts::MultiStepperLoop::State::Component</a></div><div class="ttdoc">The struct that stores the individual components.</div><div class="ttdef"><b>Definition</b> MultiStepperLoop.hpp:194</div></div>
</div><!-- fragment -->
<p>A proxy struct which allows access to a single component of the multi-component state. </p>
<p>It has the semantics of a const reference, i.e. it requires a const reference of the single-component state it represents </p>

</div>
</div>
<a id="a49f9ef065470ab990eec8f3e01eb698a" name="a49f9ef065470ab990eec8f3e01eb698a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f9ef065470ab990eec8f3e01eb698a">&#9670;&#160;</a></span>Reducer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::Reducer = component_reducer_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reducer type. </p>

</div>
</div>
<a id="ac48fd14cb18d559b290831a2736f312d" name="ac48fd14cb18d559b290831a2736f312d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48fd14cb18d559b290831a2736f312d">&#9670;&#160;</a></span>SingleConfig</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::SingleConfig = typename SingleStepper::Config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to the Config of the single component Stepper. </p>

</div>
</div>
<a id="aa0f294a69febb3a5fad1e0adae46e0a7" name="aa0f294a69febb3a5fad1e0adae46e0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f294a69febb3a5fad1e0adae46e0a7">&#9670;&#160;</a></span>SingleOptions</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::SingleOptions = typename SingleStepper::Options</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to the Single-Component Stepper Options. </p>

</div>
</div>
<a id="afb16bd3a77436790ee0e1c4148fb5cf7" name="afb16bd3a77436790ee0e1c4148fb5cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb16bd3a77436790ee0e1c4148fb5cf7">&#9670;&#160;</a></span>SingleState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::SingleState = typename SingleStepper::State</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to the State of the single component Stepper. </p>

</div>
</div>
<a id="a7767f8dd7e4a4a2aec00b0ed9a7411f1" name="a7767f8dd7e4a4a2aec00b0ed9a7411f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7767f8dd7e4a4a2aec00b0ed9a7411f1">&#9670;&#160;</a></span>SingleStepper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::SingleStepper = single_stepper_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to the Single-Component Eigen Stepper. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a570b81ba406b8c3eb2451cef7d4a4c15" name="a570b81ba406b8c3eb2451cef7d4a4c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570b81ba406b8c3eb2451cef7d4a4c15">&#9670;&#160;</a></span>MultiStepperLoop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::MultiStepperLoop </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_magnetic_field_provider.html">MagneticFieldProvider</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>bField</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;GSF&quot;,&#160;<a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a magnetic field and a optionally provided Logger TODO this requires that every stepper can be constructed like this... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bField</td><td>Magnetic field provider to use for propagation </td></tr>
    <tr><td class="paramname">logger</td><td>Logger instance for debugging output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1c5570e468bf963682ca070c9ca5246" name="af1c5570e468bf963682ca070c9ca5246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c5570e468bf963682ca070c9ca5246">&#9670;&#160;</a></span>MultiStepperLoop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::MultiStepperLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_config.html">Config</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;MultiStepperLoop&lt;&#160;single_stepper_t,&#160;component_reducer_t&#160;&gt;&quot;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Logging::INFO)</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from a configuration and optionally provided Logger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Configuration object containing stepper settings </td></tr>
    <tr><td class="paramname">logger</td><td>Logger instance for debugging output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="af0cffcbdb894dbb7ae97f435f573b4f3" name="af0cffcbdb894dbb7ae97f435f573b4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cffcbdb894dbb7ae97f435f573b4f3">&#9670;&#160;</a></span>absoluteMomentum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::absoluteMomentum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Absolute momentum accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute momentum magnitude from the reduced component state </dd></dl>

</div>
</div>
<a id="aadb5485323be4c9842111031bc0b5b6b" name="aadb5485323be4c9842111031bc0b5b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb5485323be4c9842111031bc0b5b6b">&#9670;&#160;</a></span>addComponent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#a4c04e0a4abab2458b926bbd31a22786a">ComponentProxy</a> &gt; <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::addComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>weight</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a component to the Multistepper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The stepping state (thread-local cache) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pars</td><td>Parameters of the component to add </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>Weight of the component to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: It is not ensured that the weights are normalized afterwards </dd>
<dd>
This function makes no garantuees about how new components are initialized, it is up to the caller to ensure that all components are valid in the end. </dd>
<dd>
The returned component-proxy is only garantueed to be valid until the component number is again modified </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>ComponentProxy for the newly added component or error </dd></dl>

</div>
</div>
<a id="a88eb382ca93bd78bcbe82e430748ec20" name="a88eb382ca93bd78bcbe82e430748ec20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88eb382ca93bd78bcbe82e430748ec20">&#9670;&#160;</a></span>boundState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#a25bae4907217345239b06d2fa164dccb">BoundState</a> &gt; <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::boundState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>transportCov</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeToBoundCorrection &amp;</td>          <td class="paramname"><span class="paramname"><em>freeToBoundCorrection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FreeToBoundCorrection(false)</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return the bound state at the current position. </p>
<p>This transports (if necessary) the covariance to the surface and creates a bound state. It does not check if the transported state is at the surface, this needs to be guaranteed by the propagator. </p><dl class="section note"><dt>Note</dt><dd>This is done by combining the gaussian mixture on the specified surface. If the conversion to bound states of some components fails, these components are ignored unless all components fail. In this case an error code is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>State that will be presented as <code>BoundState</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The surface to which we bind the state </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transportCov</td><td>Flag steering covariance transport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeToBoundCorrection</td><td>Flag steering non-linear correction during global to local correction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bound state:<ul>
<li>the parameters at the surface</li>
<li>the stepwise jacobian towards it (from last bound)</li>
<li>and the path length (from start - for ordering) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a5810edeb15d1733ba6447b4e1cbe7613" name="a5810edeb15d1733ba6447b4e1cbe7613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5810edeb15d1733ba6447b4e1cbe7613">&#9670;&#160;</a></span>charge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::charge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Charge access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Electric charge value from the reduced component state </dd></dl>

</div>
</div>
<a id="aad4ed104697bb10e91de477d0099958e" name="aad4ed104697bb10e91de477d0099958e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4ed104697bb10e91de477d0099958e">&#9670;&#160;</a></span>clearComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::clearComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the number of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7493f780932d2a91057e1cde8b57d41" name="ae7493f780932d2a91057e1cde8b57d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7493f780932d2a91057e1cde8b57d41">&#9670;&#160;</a></span>componentIterable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::componentIterable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an iterable which can be plugged into a range-based for-loop to iterate over components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Multi-component stepper state to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use a for-loop with by-value semantics, since the Iterable returns a proxy internally holding a reference </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Iterable range object that can be used in range-based for-loops </dd></dl>

</div>
</div>
<a id="a8e36c69a3252b98c7e3a207dc2dc3360" name="a8e36c69a3252b98c7e3a207dc2dc3360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e36c69a3252b98c7e3a207dc2dc3360">&#9670;&#160;</a></span>constComponentIterable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::constComponentIterable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an constant iterable which can be plugged into a range-based for-loop to iterate over components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Multi-component stepper state to iterate over (const) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Use a for-loop with by-value semantics, since the Iterable returns a proxy internally holding a reference </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Const iterable range object for read-only iteration over components </dd></dl>

</div>
</div>
<a id="aa4655ee78def889ce17191cc2185a773" name="aa4655ee78def889ce17191cc2185a773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4655ee78def889ce17191cc2185a773">&#9670;&#160;</a></span>curvilinearState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a25bae4907217345239b06d2fa164dccb">BoundState</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::curvilinearState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>transportCov</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and return a curvilinear state at the current position. </p>
<p>This transports (if necessary) the covariance to the current position and creates a curvilinear state. </p><dl class="section note"><dt>Note</dt><dd>This is done as a simple average over the free representation and covariance of the components.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>State that will be presented as <code>CurvilinearState</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transportCov</td><td>Flag steering covariance transport</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A curvilinear state:<ul>
<li>the curvilinear parameters at given position</li>
<li>the stepweise jacobian towards it (from last bound)</li>
<li>and the path length (from start - for ordering) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="adfbd62497eb2d734077831f052b39917" name="adfbd62497eb2d734077831f052b39917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbd62497eb2d734077831f052b39917">&#9670;&#160;</a></span>direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::direction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Momentum direction accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized momentum direction vector from the reduced component state </dd></dl>

</div>
</div>
<a id="ad02581b5a3f99db0fd84cb274e15272f" name="ad02581b5a3f99db0fd84cb274e15272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02581b5a3f99db0fd84cb274e15272f">&#9670;&#160;</a></span>getField()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &gt; <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::getField </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the field for the stepping, it checks first if the access is still within the Cell, and updates the cell if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>is the propagation state associated with the track the magnetic field cell is used (and potentially updated) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>is the field position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This uses the cache of the first component stored in the state </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Magnetic field vector at the given position or error </dd></dl>

</div>
</div>
<a id="a17c46fd3911200c3b49c41b1c71f70b2" name="a17c46fd3911200c3b49c41b1c71f70b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c46fd3911200c3b49c41b1c71f70b2">&#9670;&#160;</a></span>getStepSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::getStepSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a></td>          <td class="paramname"><span class="paramname"><em>stype</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the step size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
    <tr><td class="paramname">stype</td><td>[in] The step size type to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This returns the smallest step size of all components. It uses std::abs for comparison to handle backward propagation and negative step sizes correctly. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Smallest step size among all components for the requested type </dd></dl>

</div>
</div>
<a id="a422d81f88543bdc4b38e50f464c9cde9" name="a422d81f88543bdc4b38e50f464c9cde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422d81f88543bdc4b38e50f464c9cde9">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_multi_component_bound_track_parameters.html">MultiComponentBoundTrackParameters</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>par</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the stepper state from multi-component bound track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The stepper state to initialize </td></tr>
    <tr><td class="paramname">par</td><td>The multi-component bound track parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac294b68a4777e63aecb2b587f7e56643" name="ac294b68a4777e63aecb2b587f7e56643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac294b68a4777e63aecb2b587f7e56643">&#9670;&#160;</a></span>makeState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::makeState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_options.html">Options</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a state object for multi-stepping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The propagation options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Initialized state object for multi-stepper </dd></dl>

</div>
</div>
<a id="a0d05d15a0ba03da5a4e99820166ca3a4" name="a0d05d15a0ba03da5a4e99820166ca3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d05d15a0ba03da5a4e99820166ca3a4">&#9670;&#160;</a></span>momentum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::momentum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Momentum accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Momentum vector from the reduced component state </dd></dl>

</div>
</div>
<a id="af7f7340a7bcdce9386b74280345687bf" name="af7f7340a7bcdce9386b74280345687bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f7340a7bcdce9386b74280345687bf">&#9670;&#160;</a></span>numberComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::numberComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in,out] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of components in the multi-component state </dd></dl>

</div>
</div>
<a id="a350103911e41093a317343014652774d" name="a350103911e41093a317343014652774d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a350103911e41093a317343014652774d">&#9670;&#160;</a></span>outputStepSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::outputStepSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the Step Size of all components into one std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in,out] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of all component step sizes concatenated </dd></dl>

</div>
</div>
<a id="a2bd33807eab7aa336729b6e4071ddfa3" name="a2bd33807eab7aa336729b6e4071ddfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd33807eab7aa336729b6e4071ddfa3">&#9670;&#160;</a></span>particleHypothesis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::particleHypothesis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Particle hypothesis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Particle hypothesis used for this multi-component state </dd></dl>

</div>
</div>
<a id="a77b755cb0045ae54b5970effe08a041a" name="a77b755cb0045ae54b5970effe08a041a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b755cb0045ae54b5970effe08a041a">&#9670;&#160;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global particle position accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Global position vector from the reduced component state </dd></dl>

</div>
</div>
<a id="a95bae37aba1f2ffb3da2bb6f283cbdc7" name="a95bae37aba1f2ffb3da2bb6f283cbdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bae37aba1f2ffb3da2bb6f283cbdc7">&#9670;&#160;</a></span>prepareCurvilinearState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::prepareCurvilinearState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If necessary fill additional members needed for curvilinearState. </p>
<p>Compute path length derivatives in case they have not been computed yet, which is the case if no step has been executed yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if nothing is missing after this call, false otherwise. </dd></dl>

</div>
</div>
<a id="a996d6c0099ebc11d52f79e5a0cdd2f98" name="a996d6c0099ebc11d52f79e5a0cdd2f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996d6c0099ebc11d52f79e5a0cdd2f98">&#9670;&#160;</a></span>qOverP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::qOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QoP access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Charge over momentum (q/p) value from the reduced component state </dd></dl>

</div>
</div>
<a id="a8214196154e421fbc981aac7dd252de7" name="a8214196154e421fbc981aac7dd252de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214196154e421fbc981aac7dd252de7">&#9670;&#160;</a></span>releaseStepSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::releaseStepSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a></td>          <td class="paramname"><span class="paramname"><em>stype</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the step-size for all components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">state</td><td>[in,out] The stepping state (thread-local cache) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stype</td><td>The step size type to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fde02c90ca222d08e69c44eac6ab577" name="a2fde02c90ca222d08e69c44eac6ab577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fde02c90ca222d08e69c44eac6ab577">&#9670;&#160;</a></span>removeMissedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::removeMissedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove missed components from the component state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in,out] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18148893c93190a148dec77b00b48d75" name="a18148893c93190a148dec77b00b48d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18148893c93190a148dec77b00b48d75">&#9670;&#160;</a></span>reweightComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::reweightComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reweight the components. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fd61a6fae614fee412c0cfc33d4f8ba" name="a5fd61a6fae614fee412c0cfc33d4f8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fd61a6fae614fee412c0cfc33d4f8ba">&#9670;&#160;</a></span>step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; double &gt; <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>propDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_i_volume_material.html">IVolumeMaterial</a> *</td>          <td class="paramname"><span class="paramname"><em>material</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a Runge-Kutta track parameter propagation step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The state of the stepper </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">propDir</td><td>is the direction of propagation </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">material</td><td>is the material properties </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result of the step</dd></dl>
<p>The state contains the desired step size. It can be negative during backwards track propagation, and since we're using an adaptive algorithm, it can be modified by the stepper class during propagation. </p>

</div>
</div>
<a id="a302cbeff32f5f8d724ee18e1efeeb46d" name="a302cbeff32f5f8d724ee18e1efeeb46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302cbeff32f5f8d724ee18e1efeeb46d">&#9670;&#160;</a></span>time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in] The stepping state (thread-local cache) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time coordinate from the reduced component state </dd></dl>

</div>
</div>
<a id="adaeaae8bc11f7964b91434cad7b2abb0" name="adaeaae8bc11f7964b91434cad7b2abb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeaae8bc11f7964b91434cad7b2abb0">&#9670;&#160;</a></span>transportCovarianceToBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::transportCovarianceToBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FreeToBoundCorrection &amp;</td>          <td class="paramname"><span class="paramname"><em>freeToBoundCorrection</em></span><span class="paramdefsep"> = </span><span class="paramdefval">FreeToBoundCorrection(false)</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method for on-demand transport of the covariance to a new curvilinear frame at current position, or direction of the state. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">surface_t</td><td>the Surface type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>State of the stepper </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>is the surface to which the covariance is forwarded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freeToBoundCorrection</td><td>Flag steering non-linear correction during global to local correction to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>no check is done if the position is actually on the surface </dd></dl>

</div>
</div>
<a id="a990dbc216f38984e57f1875b855e5aa8" name="a990dbc216f38984e57f1875b855e5aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990dbc216f38984e57f1875b855e5aa8">&#9670;&#160;</a></span>transportCovarianceToCurvilinear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::transportCovarianceToCurvilinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method for on-demand transport of the covariance to a new curvilinear frame at current position, or direction of the state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>State of the stepper </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb7a1bdff195f1bc9ed9f2d2bc88e0e2" name="adb7a1bdff195f1bc9ed9f2d2bc88e0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7a1bdff195f1bc9ed9f2d2bc88e0e2">&#9670;&#160;</a></span>updateStepSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
<div class="memtemplate">
template&lt;typename object_intersection_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::updateStepSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const object_intersection_t &amp;</td>          <td class="paramname"><span class="paramname"><em>oIntersection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a></td>          <td class="paramname"><span class="paramname"><em>stype</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update step size. </p>
<p>This method intersects the provided surface and update the navigation step estimation accordingly (hence it changes the state). It also returns the status of the intersection to trigger onSurface in case the surface is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in,out] The stepping state (thread-local cache) </td></tr>
    <tr><td class="paramname">oIntersection</td><td>[in] The ObjectIntersection to layer, boundary, etc </td></tr>
    <tr><td class="paramname">direction</td><td>[in] The propagation direction </td></tr>
    <tr><td class="paramname">stype</td><td>[in] The step size type to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d8165ca37acd22cd0e423c7a8cd1625" name="a8d8165ca37acd22cd0e423c7a8cd1625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8165ca37acd22cd0e423c7a8cd1625">&#9670;&#160;</a></span>updateStepSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::updateStepSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>stepSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a></td>          <td class="paramname"><span class="paramname"><em>stype</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update step size - explicitly with a double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>[in,out] The stepping state (thread-local cache) </td></tr>
    <tr><td class="paramname">stepSize</td><td>[in] The step size value </td></tr>
    <tr><td class="paramname">stype</td><td>[in] The step size type to be set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dc60c5117467bf4f3aed5c0dc7dfdf3" name="a0dc60c5117467bf4f3aed5c0dc7dfdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc60c5117467bf4f3aed5c0dc7dfdf3">&#9670;&#160;</a></span>updateSurfaceStatus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a52191edec34daa17746d1937fb06c1fb">IntersectionStatus</a> <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::updateSurfaceStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_multi_stepper_loop_1_1_state.html">State</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>state</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint8_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>navDir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundaryTolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>surfaceTolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_constrained_step.html#a0eecb2e9c95a2c252b3fea20e69b0ba5">ConstrainedStep::Type</a></td>          <td class="paramname"><span class="paramname"><em>stype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">getDummyLogger</a>()</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update surface status. </p>
<p>It checks the status to the reference surface &amp; updates the step size accordingly</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">state</td><td>The stepping state (thread-local cache) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surface</td><td>The surface provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The surface intersection index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">navDir</td><td>The navigation direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundaryTolerance</td><td>The boundary check for this status update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">surfaceTolerance</td><td>Surface tolerance used for intersection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stype</td><td>The step size type to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logger</td><td>A <code>Logger</code> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>IntersectionStatus indicating the overall status of all components relative to the surface </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="af87a75205a8a0417f5072228a67143ca" name="af87a75205a8a0417f5072228a67143ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87a75205a8a0417f5072228a67143ca">&#9670;&#160;</a></span>maxComponents</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Concepts::SingleStepper single_stepper_t, typename component_reducer_t = MaxWeightReducerLoop&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a>&lt; single_stepper_t, component_reducer_t &gt;::maxComponents = std::numeric_limits&lt;int&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many components can this stepper manage? </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="class_acts_1_1_multi_stepper_loop.html">MultiStepperLoop</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
