<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespace_acts.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The main namespace encompassing all ACTS code.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:AngleHelpers" id="r_AngleHelpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_angle_helpers.html">AngleHelpers</a></td></tr>
<tr class="memitem:AxisJsonConverter" id="r_AxisJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_axis_json_converter.html">AxisJsonConverter</a></td></tr>
<tr class="memitem:Ccl" id="r_Ccl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_ccl.html">Ccl</a></td></tr>
<tr class="memitem:CkfTypes" id="r_CkfTypes"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_ckf_types.html">CkfTypes</a></td></tr>
<tr class="memitem:Concepts" id="r_Concepts"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_concepts.html">Concepts</a></td></tr>
<tr class="memitem:DetrayJsonHelper" id="r_DetrayJsonHelper"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_detray_json_helper.html">DetrayJsonHelper</a></td></tr>
<tr class="memitem:Experimental" id="r_Experimental"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_experimental.html">Experimental</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_experimental"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains code that is not considered stable yet and might change. <br /></td></tr>
<tr class="memitem:GeometryIdentifierJsonConverter" id="r_GeometryIdentifierJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_geometry_identifier_json_converter.html">GeometryIdentifierJsonConverter</a></td></tr>
<tr class="memitem:GraphViz" id="r_GraphViz"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_graph_viz.html">GraphViz</a></td></tr>
<tr class="memitem:GridAccess" id="r_GridAccess"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_grid_access.html">GridAccess</a></td></tr>
<tr class="memitem:GridAccessHelpers" id="r_GridAccessHelpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_grid_access_helpers.html">GridAccessHelpers</a></td></tr>
<tr class="memitem:GridAccessJsonConverter" id="r_GridAccessJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_grid_access_json_converter.html">GridAccessJsonConverter</a></td></tr>
<tr class="memitem:GridAxisGenerators" id="r_GridAxisGenerators"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_grid_axis_generators.html">GridAxisGenerators</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_grid_axis_generators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis generators are used to allow defining different grid types for indexed geometry objects. <br /></td></tr>
<tr class="memitem:GridJsonConverter" id="r_GridJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_grid_json_converter.html">GridJsonConverter</a></td></tr>
<tr class="memitem:GridSurfaceMaterialFactory" id="r_GridSurfaceMaterialFactory"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_grid_surface_material_factory.html">GridSurfaceMaterialFactory</a></td></tr>
<tr class="memitem:GsfConstants" id="r_GsfConstants"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_gsf_constants.html">GsfConstants</a></td></tr>
<tr class="memitem:HashedStringLiteral" id="r_HashedStringLiteral"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_hashed_string_literal.html">HashedStringLiteral</a></td></tr>
<tr class="memitem:HoughTransformUtils" id="r_HoughTransformUtils"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_hough_transform_utils.html">HoughTransformUtils</a></td></tr>
<tr class="memitem:IndexedGridJsonHelper" id="r_IndexedGridJsonHelper"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_indexed_grid_json_helper.html">IndexedGridJsonHelper</a></td></tr>
<tr class="memitem:IndexGridNavigationJsonConverter" id="r_IndexGridNavigationJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_index_grid_navigation_json_converter.html">IndexGridNavigationJsonConverter</a></td></tr>
<tr class="memitem:Interpolation3D" id="r_Interpolation3D"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_interpolation3_d.html">Interpolation3D</a></td></tr>
<tr class="memitem:JsonSurfacesReader" id="r_JsonSurfacesReader"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_json_surfaces_reader.html">JsonSurfacesReader</a></td></tr>
<tr class="memitem:KalmanVertexUpdater" id="r_KalmanVertexUpdater"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_kalman_vertex_updater.html">KalmanVertexUpdater</a></td></tr>
<tr class="memitem:Logging" id="r_Logging"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_logging.html">Logging</a></td></tr>
<tr class="memitem:MaterialInteractionAssignment" id="r_MaterialInteractionAssignment"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_material_interaction_assignment.html">MaterialInteractionAssignment</a></td></tr>
<tr class="memitem:MultiTrajectoryHelpers" id="r_MultiTrajectoryHelpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_multi_trajectory_helpers.html">MultiTrajectoryHelpers</a></td></tr>
<tr class="memitem:MultiTrajectoryTraits" id="r_MultiTrajectoryTraits"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_multi_trajectory_traits.html">MultiTrajectoryTraits</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_multi_trajectory_traits"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains typedefs and constant values that are used by other parts of the <code>MultiTrajectory</code> implementation. <br /></td></tr>
<tr class="memitem:ParticleIdHelper" id="r_ParticleIdHelper"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_particle_id_helper.html">ParticleIdHelper</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_particle_id_helper"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle identification based on PDG number. <br /></td></tr>
<tr class="memitem:PhysicalConstants" id="r_PhysicalConstants"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_physical_constants.html">PhysicalConstants</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_physical_constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical constants in native units. <br /></td></tr>
<tr class="memitem:PixelSpacePointBuilder" id="r_PixelSpacePointBuilder"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_pixel_space_point_builder.html">PixelSpacePointBuilder</a></td></tr>
<tr class="memitem:PortalJsonConverter" id="r_PortalJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_portal_json_converter.html">PortalJsonConverter</a></td></tr>
<tr class="memitem:ProtoAxisHelpers" id="r_ProtoAxisHelpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_proto_axis_helpers.html">ProtoAxisHelpers</a></td></tr>
<tr class="memitem:ProtoAxisJsonConverter" id="r_ProtoAxisJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_proto_axis_json_converter.html">ProtoAxisJsonConverter</a></td></tr>
<tr class="memitem:StripSpacePointBuilder" id="r_StripSpacePointBuilder"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_strip_space_point_builder.html">StripSpacePointBuilder</a></td></tr>
<tr class="memitem:SurfaceBoundsJsonConverter" id="r_SurfaceBoundsJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_surface_bounds_json_converter.html">SurfaceBoundsJsonConverter</a></td></tr>
<tr class="memitem:SurfaceJsonConverter" id="r_SurfaceJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_surface_json_converter.html">SurfaceJsonConverter</a></td></tr>
<tr class="memitem:Transform3JsonConverter" id="r_Transform3JsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_transform3_json_converter.html">Transform3JsonConverter</a></td></tr>
<tr class="memitem:Types" id="r_Types"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_types.html">Types</a></td></tr>
<tr class="memitem:UnitConstants" id="r_UnitConstants"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_unit_constants.html">UnitConstants</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_unit_constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants and helper literals for physical units. <br /></td></tr>
<tr class="memitem:UnitLiterals" id="r_UnitLiterals"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_unit_literals.html">UnitLiterals</a></td></tr>
<tr class="memdesc:namespace_acts_1_1_unit_literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for user-defined literals for physical units. <br /></td></tr>
<tr class="memitem:VectorHelpers" id="r_VectorHelpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_vector_helpers.html">VectorHelpers</a></td></tr>
<tr class="memitem:VolumeBoundsJsonConverter" id="r_VolumeBoundsJsonConverter"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_1_1_volume_bounds_json_converter.html">VolumeBoundsJsonConverter</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AccumulatedMaterialSlab" id="r_AccumulatedMaterialSlab"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_accumulated_material_slab.html">AccumulatedMaterialSlab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate material properties from multiple hits/track and multiple tracks.  <a href="class_acts_1_1_accumulated_material_slab.html#details">More...</a><br /></td></tr>
<tr class="memitem:AccumulatedSurfaceMaterial" id="r_AccumulatedSurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_accumulated_surface_material.html">AccumulatedSurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by the SurfaceMaterialMapper in order to accumulate/collect material information during the mapping process.  <a href="class_acts_1_1_accumulated_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:AccumulatedVolumeMaterial" id="r_AccumulatedVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_accumulated_volume_material.html">AccumulatedVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate and average volume-based material properties.  <a href="class_acts_1_1_accumulated_volume_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActorHasResultStruct" id="r_ActorHasResultStruct"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_actor_has_result_struct.html">ActorHasResultStruct</a></td></tr>
<tr class="memitem:ActorList" id="r_ActorList"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_actor_list.html">ActorList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ActorList implementation to be used with the propagator.  <a href="struct_acts_1_1_actor_list.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActorResultTypeExtractor" id="r_ActorResultTypeExtractor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_actor_result_type_extractor.html">ActorResultTypeExtractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the result type of an actor.  <a href="struct_acts_1_1_actor_result_type_extractor.html#details">More...</a><br /></td></tr>
<tr class="memitem:AdaptiveGridDensityVertexFinder" id="r_AdaptiveGridDensityVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_adaptive_grid_density_vertex_finder.html">AdaptiveGridDensityVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex finder that makes use of a track density grid.  <a href="class_acts_1_1_adaptive_grid_density_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:AdaptiveGridTrackDensity" id="r_AdaptiveGridTrackDensity"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_adaptive_grid_track_density.html">AdaptiveGridTrackDensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a 1D (no time seeding) / 2D (time seeding) grid that is filled with track densities.  <a href="class_acts_1_1_adaptive_grid_track_density.html#details">More...</a><br /></td></tr>
<tr class="memitem:AdaptiveMultiVertexFinder" id="r_AdaptiveMultiVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_adaptive_multi_vertex_finder.html">AdaptiveMultiVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an iterative vertex finder.  <a href="class_acts_1_1_adaptive_multi_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:AdaptiveMultiVertexFitter" id="r_AdaptiveMultiVertexFitter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_adaptive_multi_vertex_fitter.html">AdaptiveMultiVertexFitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an adaptive multi-vertex fitter as described in detail in Section 5.3.5 in: Ref.  <a href="class_acts_1_1_adaptive_multi_vertex_fitter.html#details">More...</a><br /></td></tr>
<tr class="memitem:AmbiguityResolutionML" id="r_AmbiguityResolutionML"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_ambiguity_resolution_m_l.html">AmbiguityResolutionML</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of the machine learning ambiguity resolution Contains method for data preparations.  <a href="class_acts_1_1_ambiguity_resolution_m_l.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnnealingUtility" id="r_AnnealingUtility"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_annealing_utility.html">AnnealingUtility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a deterministic thermodynamic annealing scheme Ref.  <a href="class_acts_1_1_annealing_utility.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnnulusBounds" id="r_AnnulusBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_annulus_bounds.html">AnnulusBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that implements a (potentially asymmetric) bounds with difference between surface bound center and surface coordinate center.  <a href="class_acts_1_1_annulus_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyBase" id="r_AnyBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_base.html">AnyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small opaque cache type with configurable small buffer optimization.  <a href="class_acts_1_1_any_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyBaseAll" id="r_AnyBaseAll"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_base_all.html">AnyBaseAll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all instances of <a class="el" href="class_acts_1_1_any_base.html">AnyBase</a> regarfless of SBO size.  <a href="class_acts_1_1_any_base_all.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyCharge" id="r_AnyCharge"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_charge.html">AnyCharge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charge and momentum interpretation for arbitrarily charged particles.  <a href="class_acts_1_1_any_charge.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyGridConstView" id="r_AnyGridConstView"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_grid_const_view.html">AnyGridConstView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe view into a grid with const access.  <a href="class_acts_1_1_any_grid_const_view.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyGridView" id="r_AnyGridView"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_grid_view.html">AnyGridView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-safe view into a grid with mutable access.  <a href="class_acts_1_1_any_grid_view.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnySurfaceReached" id="r_AnySurfaceReached"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_any_surface_reached.html">AnySurfaceReached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborter that checks if the propagation has reached any surface.  <a href="struct_acts_1_1_any_surface_reached.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyTrack" id="r_AnyTrack"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_track.html">AnyTrack</a></td></tr>
<tr class="memitem:AnyTrackProxy" id="r_AnyTrackProxy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_track_proxy.html">AnyTrackProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased track object This class provides a type-erased interface to track proxies without requiring heap allocation per instance.  <a href="class_acts_1_1_any_track_proxy.html#details">More...</a><br /></td></tr>
<tr class="memitem:AnyTrackStateProxy" id="r_AnyTrackStateProxy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_any_track_state_proxy.html">AnyTrackStateProxy</a></td></tr>
<tr class="memitem:AppendOnlyNavigationStream" id="r_AppendOnlyNavigationStream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_append_only_navigation_stream.html">AppendOnlyNavigationStream</a></td></tr>
<tr class="memitem:ApproachDescriptor" id="r_ApproachDescriptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_approach_descriptor.html">ApproachDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class to decide and return which approaching surface to be taken, the surfaces are std::shared_ptr, as they can be the boundary surfaces of the representingVolume of the Layer.  <a href="class_acts_1_1_approach_descriptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:AssertionFailureException" id="r_AssertionFailureException"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_assertion_failure_exception.html">AssertionFailureException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type for assertion failures This class captures the information available to the throw_assert macro.  <a href="class_acts_1_1_assertion_failure_exception.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtlasBetheHeitlerApprox" id="r_AtlasBetheHeitlerApprox"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class approximates the Bethe-Heitler distribution as a gaussian mixture.  <a href="class_acts_1_1_atlas_bethe_heitler_approx.html#details">More...</a><br /></td></tr>
<tr class="memitem:AtlasStepper" id="r_AtlasStepper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_atlas_stepper.html">AtlasStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the AtlasStepper implementation for the  <a href="class_acts_1_1_atlas_stepper.html#details">More...</a><br /></td></tr>
<tr class="memitem:AveragingScopedTimer" id="r_AveragingScopedTimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_averaging_scoped_timer.html">AveragingScopedTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer class that measures and averages execution times of multiple samples.  <a href="class_acts_1_1_averaging_scoped_timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:Axis" id="r_Axis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_axis.html">Axis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate bin indices from a given binning structure  <a href="class_acts_1_1_axis.html#details">More...</a><br /></td></tr>
<tr class="memitem:Axis_3C_20AxisType_3A_3AEquidistant_2C_20bdt_20_3E" id="r_Axis_3C_20AxisType_3A_3AEquidistant_2C_20bdt_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_axis_3_01_axis_type_1_1_equidistant_00_01bdt_01_4.html">Axis&lt; AxisType::Equidistant, bdt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate bin indices for an equidistant binning  <a href="class_acts_1_1_axis_3_01_axis_type_1_1_equidistant_00_01bdt_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:Axis_3C_20AxisType_3A_3AVariable_2C_20bdt_20_3E" id="r_Axis_3C_20AxisType_3A_3AVariable_2C_20bdt_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_axis_3_01_axis_type_1_1_variable_00_01bdt_01_4.html">Axis&lt; AxisType::Variable, bdt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate bin indices for a variable binning  <a href="class_acts_1_1_axis_3_01_axis_type_1_1_variable_00_01bdt_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:AxisAlignedBoundingBox" id="r_AxisAlignedBoundingBox"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of an Axis Aligned Bounding Box.  <a href="class_acts_1_1_axis_aligned_bounding_box.html#details">More...</a><br /></td></tr>
<tr class="memitem:AxisBoundaryTypeTag" id="r_AxisBoundaryTypeTag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag helper type for Axis constructors with class template deduction.  <a href="struct_acts_1_1_axis_boundary_type_tag.html#details">More...</a><br /></td></tr>
<tr class="memitem:AxisDirectionReferenceGenerator" id="r_AxisDirectionReferenceGenerator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_axis_direction_reference_generator.html">AxisDirectionReferenceGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to access reference positions based on bin values.  <a href="struct_acts_1_1_axis_direction_reference_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:BasePropagator" id="r_BasePropagator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_base_propagator.html">BasePropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common simplified base interface for propagators.  <a href="class_acts_1_1_base_propagator.html#details">More...</a><br /></td></tr>
<tr class="memitem:BetheHeitlerApprox" id="r_BetheHeitlerApprox"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_bethe_heitler_approx.html">BetheHeitlerApprox</a></td></tr>
<tr class="memitem:BetheHeitlerApproxSingleCmp" id="r_BetheHeitlerApproxSingleCmp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_bethe_heitler_approx_single_cmp.html">BetheHeitlerApproxSingleCmp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class approximates the Bethe-Heitler with only one component.  <a href="class_acts_1_1_bethe_heitler_approx_single_cmp.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinnedArray" id="r_BinnedArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual base class for Binned Array to avoid map searches.  <a href="class_acts_1_1_binned_array.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinnedArrayXD" id="r_BinnedArrayXD"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_array_x_d.html">BinnedArrayXD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Avoiding a map search, the templated BinnedArray class can help ordereing geometrical objects by providing a dedicated BinUtility.  <a href="class_acts_1_1_binned_array_x_d.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinnedGroup" id="r_BinnedGroup"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_group.html">BinnedGroup</a></td></tr>
<tr class="memitem:BinnedGroupIterator" id="r_BinnedGroupIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_group_iterator.html">BinnedGroupIterator</a></td></tr>
<tr class="memitem:BinnedSurfaceMaterial" id="r_BinnedSurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_surface_material.html">BinnedSurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It extends the <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> base class and is an array pf MaterialSlab.  <a href="class_acts_1_1_binned_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinnedSurfaceMaterialAccumulater" id="r_BinnedSurfaceMaterialAccumulater"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_surface_material_accumulater.html">BinnedSurfaceMaterialAccumulater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The binned surface material accumulater.  <a href="class_acts_1_1_binned_surface_material_accumulater.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinningData" id="r_BinningData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binning_data.html">BinningData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds all the data necessary for the bin calculation.  <a href="class_acts_1_1_binning_data.html#details">More...</a><br /></td></tr>
<tr class="memitem:BinUtility" id="r_BinUtility"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The BinUtility class that translated global and local position into a bins of a BinnedArray, most performant is equidistant binning without a transform, however, optionally a transform can be provided, e.g.  <a href="class_acts_1_1_bin_utility.html#details">More...</a><br /></td></tr>
<tr class="memitem:BoundarySurfaceT" id="r_BoundarySurfaceT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_boundary_surface_t.html">BoundarySurfaceT</a></td></tr>
<tr class="memitem:BoundaryTolerance" id="r_BoundaryTolerance"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant-like type to capture different types of boundary tolerances.  <a href="class_acts_1_1_boundary_tolerance.html#details">More...</a><br /></td></tr>
<tr class="memitem:BoundFactory" id="r_BoundFactory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_bound_factory.html">BoundFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory helper class to construct volume or surface bounds where the constructed bounds are cached inside the factory and if the same bound parameters are requested at a later stage the factory automatically returns the cached bounds.  <a href="class_acts_1_1_bound_factory.html#details">More...</a><br /></td></tr>
<tr class="memitem:BroadTripletSeedFilter" id="r_BroadTripletSeedFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_broad_triplet_seed_filter.html">BroadTripletSeedFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triplet seed filter used in the triplet seeding algorithm.  <a href="class_acts_1_1_broad_triplet_seed_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:CalibrationContext" id="r_CalibrationContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_calibration_context.html">CalibrationContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the central definition of the Acts payload object regarding detector calibration.  <a href="class_acts_1_1_calibration_context.html#details">More...</a><br /></td></tr>
<tr class="memitem:CandidatesForMiddleSp" id="r_CandidatesForMiddleSp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_candidates_for_middle_sp.html">CandidatesForMiddleSp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CandidatesForMiddleSp collects the triplet candidates given a fixed middle spacepoint.  <a href="class_acts_1_1_candidates_for_middle_sp.html#details">More...</a><br /></td></tr>
<tr class="memitem:CenterReferenceGenerator" id="r_CenterReferenceGenerator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_center_reference_generator.html">CenterReferenceGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to access the center position as a sole reference.  <a href="struct_acts_1_1_center_reference_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Color" id="r_Color"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct describing a color.  <a href="struct_acts_1_1_color.html#details">More...</a><br /></td></tr>
<tr class="memitem:CombinatorialKalmanFilter" id="r_CombinatorialKalmanFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_combinatorial_kalman_filter.html">CombinatorialKalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combinatorial Kalman filter to find tracks.  <a href="class_acts_1_1_combinatorial_kalman_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:CombinatorialKalmanFilterExtensions" id="r_CombinatorialKalmanFilterExtensions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_combinatorial_kalman_filter_extensions.html">CombinatorialKalmanFilterExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension struct which holds the delegates to customize the CKF behavior.  <a href="struct_acts_1_1_combinatorial_kalman_filter_extensions.html#details">More...</a><br /></td></tr>
<tr class="memitem:CombinatorialKalmanFilterOptions" id="r_CombinatorialKalmanFilterOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_combinatorial_kalman_filter_options.html">CombinatorialKalmanFilterOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined options for the combinatorial Kalman filter.  <a href="struct_acts_1_1_combinatorial_kalman_filter_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:CombinatorialKalmanFilterResult" id="r_CombinatorialKalmanFilterResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_combinatorial_kalman_filter_result.html">CombinatorialKalmanFilterResult</a></td></tr>
<tr class="memitem:CompositePortalLink" id="r_CompositePortalLink"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_composite_portal_link.html">CompositePortalLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composite portal links can graft together other portal link instances, for example grids that could not be merged due to invalid binnings.  <a href="class_acts_1_1_composite_portal_link.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConeBounds" id="r_ConeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cone_bounds.html">ConeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds for a conical surface, the opening angle is stored in \( \tan(\alpha) \) and always positively defined.  <a href="class_acts_1_1_cone_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConeLayer" id="r_ConeLayer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cone_layer.html">ConeLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to describe a conical detector layer for tracking, it inherits from both, Layer base class and ConeSurface class.  <a href="class_acts_1_1_cone_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConeSurface" id="r_ConeSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cone_surface.html">ConeSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a conical surface in the Tracking geometry.  <a href="class_acts_1_1_cone_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConeVolumeBounds" id="r_ConeVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cone_volume_bounds.html">ConeVolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume bound class for describing conical volumes either with cylindrical inlay or outer boundary, it also allows for a sectoral description.  <a href="class_acts_1_1_cone_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstantBField" id="r_ConstantBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_constant_b_field.html">ConstantBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest magnetic field implementation is a constant field, which returns the same field values at every queried location.  <a href="class_acts_1_1_constant_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstrainedStep" id="r_ConstrainedStep"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_constrained_step.html">ConstrainedStep</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constrained step class for the steppers.  <a href="class_acts_1_1_constrained_step.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstTrackStateType" id="r_ConstTrackStateType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_const_track_state_type.html">ConstTrackStateType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View type over a bitset stored in a 64 bit integer This view does not allow modifications.  <a href="class_acts_1_1_const_track_state_type.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstVectorMultiTrajectory" id="r_ConstVectorMultiTrajectory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_const_vector_multi_trajectory.html">ConstVectorMultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const version of <a class="el" href="class_acts_1_1_vector_multi_trajectory.html">VectorMultiTrajectory</a>.  <a href="class_acts_1_1_const_vector_multi_trajectory.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConstVectorTrackContainer" id="r_ConstVectorTrackContainer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_const_vector_track_container.html">ConstVectorTrackContainer</a></td></tr>
<tr class="memitem:ConvexPolygonBounds" id="r_ConvexPolygonBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_convex_polygon_bounds.html">ConvexPolygonBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the actual implementation of the bounds.  <a href="class_acts_1_1_convex_polygon_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvexPolygonBounds_3C_20PolygonDynamic_20_3E" id="r_ConvexPolygonBounds_3C_20PolygonDynamic_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_convex_polygon_bounds_3_01_polygon_dynamic_01_4.html">ConvexPolygonBounds&lt; PolygonDynamic &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the specialization handling a polygon with a dynamic number of points.  <a href="class_acts_1_1_convex_polygon_bounds_3_01_polygon_dynamic_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ConvexPolygonBoundsBase" id="r_ConvexPolygonBoundsBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_convex_polygon_bounds_base.html">ConvexPolygonBoundsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for convex polygon bounds  <a href="class_acts_1_1_convex_polygon_bounds_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:CuboidPortalShell" id="r_CuboidPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cuboid_portal_shell.html">CuboidPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for cuboid shaped portal shells, e.g.  <a href="class_acts_1_1_cuboid_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:CuboidStackPortalShell" id="r_CuboidStackPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cuboid_stack_portal_shell.html">CuboidStackPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a cuboid shell containing multiple volumes.  <a href="class_acts_1_1_cuboid_stack_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:CuboidVolumeBounds" id="r_CuboidVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cuboid_volume_bounds.html">CuboidVolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds for a cubical Volume, the orientedSurfaces(...) method creates a vector of 6 surfaces:  <a href="class_acts_1_1_cuboid_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:CuboidVolumeBuilder" id="r_CuboidVolumeBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cuboid_volume_builder.html">CuboidVolumeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds a box detector with a configurable amount of surfaces in it.  <a href="class_acts_1_1_cuboid_volume_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CuboidVolumeStack" id="r_CuboidVolumeStack"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cuboid_volume_stack.html">CuboidVolumeStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a x-.  <a href="class_acts_1_1_cuboid_volume_stack.html#details">More...</a><br /></td></tr>
<tr class="memitem:CurvilinearSurface" id="r_CurvilinearSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_curvilinear_surface.html">CurvilinearSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for curvilinear surfaces.  <a href="class_acts_1_1_curvilinear_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:CutoutCylinderVolumeBounds" id="r_CutoutCylinderVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cutout_cylinder_volume_bounds.html">CutoutCylinderVolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which implements a cutout cylinder.  <a href="class_acts_1_1_cutout_cylinder_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderBounds" id="r_CylinderBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_bounds.html">CylinderBounds</a></td></tr>
<tr class="memitem:CylinderLayer" id="r_CylinderLayer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_layer.html">CylinderLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to describe a cylindrical detector layer for tracking, it inherits from both, Layer base class and CylinderSurface class.  <a href="class_acts_1_1_cylinder_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderNavigationPolicy" id="r_CylinderNavigationPolicy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_navigation_policy.html">CylinderNavigationPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimized navigation policy for cylindrical volumes that intelligently selects which portals to add as candidates based on geometric analysis.  <a href="class_acts_1_1_cylinder_navigation_policy.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderPortalShell" id="r_CylinderPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_portal_shell.html">CylinderPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for cylinder shaped portal shells, e.g.  <a href="class_acts_1_1_cylinder_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderStackPortalShell" id="r_CylinderStackPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_stack_portal_shell.html">CylinderStackPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a cylinder shell containing multiple volumes.  <a href="class_acts_1_1_cylinder_stack_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderSurface" id="r_CylinderSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_surface.html">CylinderSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a CylinderSurface in the TrackingGeometry.  <a href="class_acts_1_1_cylinder_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderVolumeBounds" id="r_CylinderVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_volume_bounds.html">CylinderVolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">[0] and [1] at positive \( \phi \)  <a href="class_acts_1_1_cylinder_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderVolumeBuilder" id="r_CylinderVolumeBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_volume_builder.html">CylinderVolumeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A volume builder to be used for building concentric cylinder volumes.  <a href="class_acts_1_1_cylinder_volume_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderVolumeHelper" id="r_CylinderVolumeHelper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_volume_helper.html">CylinderVolumeHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concrete implementation for cylindrical TrackingVolume objects of the ITrackingVolumeCreator interface.  <a href="class_acts_1_1_cylinder_volume_helper.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylinderVolumeStack" id="r_CylinderVolumeStack"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylinder_volume_stack.html">CylinderVolumeStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a z-aligned or r-aligned stack of cylinder volumes with synchronized bounds.  <a href="class_acts_1_1_cylinder_volume_stack.html#details">More...</a><br /></td></tr>
<tr class="memitem:CylindricalSpacePointGrid2" id="r_CylindricalSpacePointGrid2"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_cylindrical_space_point_grid2.html">CylindricalSpacePointGrid2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cylindrical space point grid used for seeding in a cylindrical detector geometry.  <a href="class_acts_1_1_cylindrical_space_point_grid2.html#details">More...</a><br /></td></tr>
<tr class="memitem:DBScan" id="r_DBScan"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_d_b_scan.html">DBScan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general implementation of an N dimensional DBScan clustering algorithm.  <a href="class_acts_1_1_d_b_scan.html#details">More...</a><br /></td></tr>
<tr class="memitem:Delegate" id="r_Delegate"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_delegate.html">Delegate</a></td></tr>
<tr class="memitem:Delegate_3C_20R_28Args_2E_2E_2E_29_2C_20H_2C_20O_20_3E" id="r_Delegate_3C_20R_28Args_2E_2E_2E_29_2C_20H_2C_20O_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_delegate_3_01_r_07_args_8_8_8_08_00_01_h_00_01_o_01_4.html">Delegate&lt; R(Args...), H, O &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegate type that allows type erasure of a callable without allocation and with a single level of indirection.  <a href="class_acts_1_1_delegate_3_01_r_07_args_8_8_8_08_00_01_h_00_01_o_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:DelegateFuncTag" id="r_DelegateFuncTag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_delegate_func_tag.html">DelegateFuncTag</a></td></tr>
<tr class="memitem:DetectorElementBase" id="r_DetectorElementBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the base of all detector elements that are usable by ACTS.  <a href="class_acts_1_1_detector_element_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiamondBounds" id="r_DiamondBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_diamond_bounds.html">DiamondBounds</a></td></tr>
<tr class="memitem:DiamondPortalShell" id="r_DiamondPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_diamond_portal_shell.html">DiamondPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for diamond shaped portal shells, e.g single volumes with polygon shape or stacked (multiple) volumes (TODO).  <a href="class_acts_1_1_diamond_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiamondVolumeBounds" id="r_DiamondVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_diamond_volume_bounds.html">DiamondVolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds for a polygonal prism shaped Volume, the orientedSurface(...) method creates a vector of 8 surfaces: 2 Diamond Shape Surfaces (see.  <a href="class_acts_1_1_diamond_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:DirectedProtoAxis" id="r_DirectedProtoAxis"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_directed_proto_axis.html">DirectedProtoAxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Directed proto axis.  <a href="struct_acts_1_1_directed_proto_axis.html#details">More...</a><br /></td></tr>
<tr class="memitem:Direction" id="r_Direction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction is always with respect to a given momentum, surface normal or other general axes.  <a href="class_acts_1_1_direction.html#details">More...</a><br /></td></tr>
<tr class="memitem:DirectNavigator" id="r_DirectNavigator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_direct_navigator.html">DirectNavigator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully guided navigator.  <a href="class_acts_1_1_direct_navigator.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiscBounds" id="r_DiscBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_disc_bounds.html">DiscBounds</a></td></tr>
<tr class="memitem:DiscLayer" id="r_DiscLayer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_disc_layer.html">DiscLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to describe a disc-like detector layer for tracking, it inherits from both, Layer base class and DiscSurface class.  <a href="class_acts_1_1_disc_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiscSurface" id="r_DiscSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_disc_surface.html">DiscSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a disc surface (or a segment thereof).  <a href="class_acts_1_1_disc_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:DiscTrapezoidBounds" id="r_DiscTrapezoidBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_disc_trapezoid_bounds.html">DiscTrapezoidBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to describe the bounds for a planar DiscSurface.  <a href="class_acts_1_1_disc_trapezoid_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:DistanceSorterT" id="r_DistanceSorterT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_distance_sorter_t.html">DistanceSorterT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will check on absolute distance.  <a href="class_acts_1_1_distance_sorter_t.html#details">More...</a><br /></td></tr>
<tr class="memitem:DoubletSeedFinder" id="r_DoubletSeedFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_doublet_seed_finder.html">DoubletSeedFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface and a collection of standard implementations for a doublet seed finder.  <a href="class_acts_1_1_doublet_seed_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:DoubletsForMiddleSp" id="r_DoubletsForMiddleSp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_doublets_for_middle_sp.html">DoubletsForMiddleSp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for doublets found by the doublet seed finder.  <a href="class_acts_1_1_doublets_for_middle_sp.html#details">More...</a><br /></td></tr>
<tr class="memitem:DummyVertexFitter" id="r_DummyVertexFitter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_dummy_vertex_fitter.html">DummyVertexFitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy vertex fitter class, only to be used for ensuring interfaces where a vertex fitter type is required but no fitter is actually needed.  <a href="class_acts_1_1_dummy_vertex_fitter.html#details">More...</a><br /></td></tr>
<tr class="memitem:EigenStepper" id="r_EigenStepper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_eigen_stepper.html">EigenStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runge-Kutta-Nystroem stepper based on Eigen implementation for the following ODE:  <a href="class_acts_1_1_eigen_stepper.html#details">More...</a><br /></td></tr>
<tr class="memitem:EigenStepperDefaultExtension" id="r_EigenStepperDefaultExtension"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_eigen_stepper_default_extension.html">EigenStepperDefaultExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default evaluator of the k_i's and elements of the transport matrix D of the RKN4 stepping.  <a href="struct_acts_1_1_eigen_stepper_default_extension.html#details">More...</a><br /></td></tr>
<tr class="memitem:EigenStepperDenseExtension" id="r_EigenStepperDenseExtension"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_eigen_stepper_dense_extension.html">EigenStepperDenseExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluator of the k_i's and elements of the transport matrix D of the RKN4 stepping.  <a href="struct_acts_1_1_eigen_stepper_dense_extension.html#details">More...</a><br /></td></tr>
<tr class="memitem:ElementFraction" id="r_ElementFraction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_element_fraction.html">ElementFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-efficient storage of the relative fraction of an element.  <a href="class_acts_1_1_element_fraction.html#details">More...</a><br /></td></tr>
<tr class="memitem:EllipseBounds" id="r_EllipseBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_ellipse_bounds.html">EllipseBounds</a></td></tr>
<tr class="memitem:EndOfWorldReached" id="r_EndOfWorldReached"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_end_of_world_reached.html">EndOfWorldReached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the condition that the end of world has been reached it then triggers an propagation abort.  <a href="struct_acts_1_1_end_of_world_reached.html#details">More...</a><br /></td></tr>
<tr class="memitem:EstimateTrackParamCovarianceConfig" id="r_EstimateTrackParamCovarianceConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_estimate_track_param_covariance_config.html">EstimateTrackParamCovarianceConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration for the estimation of the covariance matrix of the track parameters with <span class="tt">estimateTrackParamCovariance</span>.  <a href="struct_acts_1_1_estimate_track_param_covariance_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:EventDataView3D" id="r_EventDataView3D"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_event_data_view3_d.html">EventDataView3D</a></td></tr>
<tr class="memitem:ExpSafeLimit" id="r_ExpSafeLimit"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_exp_safe_limit.html">ExpSafeLimit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of the exponent limit to be used for safe exponential, depending on the floating point type.  <a href="struct_acts_1_1_exp_safe_limit.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExpSafeLimit_3C_20double_20_3E" id="r_ExpSafeLimit_3C_20double_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_exp_safe_limit_3_01double_01_4.html">ExpSafeLimit&lt; double &gt;</a></td></tr>
<tr class="memitem:ExpSafeLimit_3C_20float_20_3E" id="r_ExpSafeLimit_3C_20float_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_exp_safe_limit_3_01float_01_4.html">ExpSafeLimit&lt; float &gt;</a></td></tr>
<tr class="memitem:Extent" id="r_Extent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_extent.html">Extent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing the geometric extent of an object in its possible dimensions, these can be all dimensions that are described as AxisDirections.  <a href="class_acts_1_1_extent.html#details">More...</a><br /></td></tr>
<tr class="memitem:ExtentEnvelope" id="r_ExtentEnvelope"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_extent_envelope.html">ExtentEnvelope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct models a multi-dimensional enveloper along the axis directions.  <a href="struct_acts_1_1_extent_envelope.html#details">More...</a><br /></td></tr>
<tr class="memitem:FiniteStateMachine" id="r_FiniteStateMachine"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_finite_state_machine.html">FiniteStateMachine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a finite state machine engine.  <a href="class_acts_1_1_finite_state_machine.html#details">More...</a><br /></td></tr>
<tr class="memitem:FixedSubspaceHelper" id="r_FixedSubspaceHelper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_fixed_subspace_helper.html">FixedSubspaceHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for fixed subspace operations.  <a href="class_acts_1_1_fixed_subspace_helper.html#details">More...</a><br /></td></tr>
<tr class="memitem:ForcedSurfaceReached" id="r_ForcedSurfaceReached"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_forced_surface_reached.html">ForcedSurfaceReached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to SurfaceReached, but with an infinite overstep limit.  <a href="struct_acts_1_1_forced_surface_reached.html#details">More...</a><br /></td></tr>
<tr class="memitem:Frustum" id="r_Frustum"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_frustum.html">Frustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing a frustum shape.  <a href="class_acts_1_1_frustum.html#details">More...</a><br /></td></tr>
<tr class="memitem:FsmwMode1dFinder" id="r_FsmwMode1dFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_fsmw_mode1d_finder.html">FsmwMode1dFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mode of a unidimenensional distribution using the Fraction of Sample Mode with Weights algorithm For reference, see: On a Fast, Robust Estimator of the Mode: Comparisons to Other Robust Estimators with Applications, David R.  <a href="class_acts_1_1_fsmw_mode1d_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:FullBilloirVertexFitter" id="r_FullBilloirVertexFitter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_full_billoir_vertex_fitter.html">FullBilloirVertexFitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex fitter class implementing the Billoir vertex fitter.  <a href="class_acts_1_1_full_billoir_vertex_fitter.html#details">More...</a><br /></td></tr>
<tr class="memitem:GainMatrixSmoother" id="r_GainMatrixSmoother"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_gain_matrix_smoother.html">GainMatrixSmoother</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman trajectory smoother based on gain matrix formalism.  <a href="class_acts_1_1_gain_matrix_smoother.html#details">More...</a><br /></td></tr>
<tr class="memitem:GainMatrixUpdater" id="r_GainMatrixUpdater"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_gain_matrix_updater.html">GainMatrixUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman update step using the gain matrix formalism.  <a href="class_acts_1_1_gain_matrix_updater.html#details">More...</a><br /></td></tr>
<tr class="memitem:GaussianGridTrackDensity" id="r_GaussianGridTrackDensity"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_gaussian_grid_track_density.html">GaussianGridTrackDensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a 1-dim density grid to be filled with track Gaussian distributions.  <a href="class_acts_1_1_gaussian_grid_track_density.html#details">More...</a><br /></td></tr>
<tr class="memitem:GaussianSumFitter" id="r_GaussianSumFitter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_gaussian_sum_fitter.html">GaussianSumFitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian Sum Fitter implementation.  <a href="struct_acts_1_1_gaussian_sum_fitter.html#details">More...</a><br /></td></tr>
<tr class="memitem:GaussianTrackDensity" id="r_GaussianTrackDensity"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_gaussian_track_density.html">GaussianTrackDensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to model tracks as 2D density functions based on their d0 and z0 perigee parameters (mean value) and covariance matrices (determining the width of the function).  <a href="class_acts_1_1_gaussian_track_density.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenericApproachDescriptor" id="r_GenericApproachDescriptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_generic_approach_descriptor.html">GenericApproachDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to decide and return which approaching surface to be taken, it's a generic descriptor for n surfaces.  <a href="class_acts_1_1_generic_approach_descriptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenericBoundTrackParameters" id="r_GenericBoundTrackParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_generic_bound_track_parameters.html">GenericBoundTrackParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track parameters bound to a reference surface for a single track.  <a href="class_acts_1_1_generic_bound_track_parameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenericCuboidVolumeBounds" id="r_GenericCuboidVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_generic_cuboid_volume_bounds.html">GenericCuboidVolumeBounds</a></td></tr>
<tr class="memitem:GenericFreeTrackParameters" id="r_GenericFreeTrackParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_generic_free_track_parameters.html">GenericFreeTrackParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track parameters not bound to a surface for a single track.  <a href="class_acts_1_1_generic_free_track_parameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:GenericParticleHypothesis" id="r_GenericParticleHypothesis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_generic_particle_hypothesis.html">GenericParticleHypothesis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Particle hypothesis used in reconstruction.  <a href="class_acts_1_1_generic_particle_hypothesis.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryContext" id="r_GeometryContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the central definition of the Acts payload object regarding detector geometry status (e.g.  <a href="class_acts_1_1_geometry_context.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryContextOstreamWrapper" id="r_GeometryContextOstreamWrapper"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_geometry_context_ostream_wrapper.html">GeometryContextOstreamWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct that stores an object and a context, and will print it to an outstream.  <a href="struct_acts_1_1_geometry_context_ostream_wrapper.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryHierarchyMap" id="r_GeometryHierarchyMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_hierarchy_map.html">GeometryHierarchyMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store values mapped into the geometry hierarchy.  <a href="class_acts_1_1_geometry_hierarchy_map.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryHierarchyMapJsonConverter" id="r_GeometryHierarchyMapJsonConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_hierarchy_map_json_converter.html">GeometryHierarchyMapJsonConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a geometry hierarchy map to/from Json.  <a href="class_acts_1_1_geometry_hierarchy_map_json_converter.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryIdentifier" id="r_GeometryIdentifier"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifier for geometry nodes within the geometry hierarchy.  <a href="class_acts_1_1_geometry_identifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryIdentifierHook" id="r_GeometryIdentifierHook"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_geometry_identifier_hook.html">GeometryIdentifierHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for hooks that can be used to modify the Geometry Identifier during construction.  <a href="struct_acts_1_1_geometry_identifier_hook.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryObject" id="r_GeometryObject"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html">GeometryObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to provide GeometryIdentifier interface:  <a href="class_acts_1_1_geometry_object.html#details">More...</a><br /></td></tr>
<tr class="memitem:GeometryObjectSorterT" id="r_GeometryObjectSorterT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object_sorter_t.html">GeometryObjectSorterT</a></td></tr>
<tr class="memitem:GeometryView3D" id="r_GeometryView3D"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_geometry_view3_d.html">GeometryView3D</a></td></tr>
<tr class="memitem:GloballyIndexedMaterialAccessor" id="r_GloballyIndexedMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_globally_indexed_material_accessor.html">GloballyIndexedMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor for cases where the material is filled in a global material vector that is accessed from the different material grids.  <a href="struct_acts_1_1_globally_indexed_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:GlueVolumesDescriptor" id="r_GlueVolumesDescriptor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_glue_volumes_descriptor.html">GlueVolumesDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptor class to hold GlueVolumes of a TrackingGeometry object.  <a href="class_acts_1_1_glue_volumes_descriptor.html#details">More...</a><br /></td></tr>
<tr class="memitem:GreedyAmbiguityResolution" id="r_GreedyAmbiguityResolution"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_greedy_ambiguity_resolution.html">GreedyAmbiguityResolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evicts tracks that seem to be duplicates or fakes.  <a href="class_acts_1_1_greedy_ambiguity_resolution.html#details">More...</a><br /></td></tr>
<tr class="memitem:Grid" id="r_Grid"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid.html">Grid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for describing a regular multi-dimensional grid  <a href="class_acts_1_1_grid.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridBinFinder" id="r_GridBinFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_bin_finder.html">GridBinFinder</a></td></tr>
<tr class="memitem:GridDensityVertexFinder" id="r_GridDensityVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_density_vertex_finder.html">GridDensityVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex finder that makes use of a track density grid.  <a href="class_acts_1_1_grid_density_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridGlobalIterator" id="r_GridGlobalIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_global_iterator.html">GridGlobalIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid iterator using the global position.  <a href="class_acts_1_1_grid_global_iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridLocalIterator" id="r_GridLocalIterator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_local_iterator.html">GridLocalIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grid iterator using the local position.  <a href="class_acts_1_1_grid_local_iterator.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridMaterialAccessor" id="r_GridMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_grid_material_accessor.html">GridMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor for cases where the material is directly stored in the grid, it simply forwards the grid entry in const and non-const way.  <a href="struct_acts_1_1_grid_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridPortalLink" id="r_GridPortalLink"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_portal_link.html">GridPortalLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GridPortalLink implements a subdivided surface where the target volume depends on the position on the surface.  <a href="class_acts_1_1_grid_portal_link.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridPortalLinkT" id="r_GridPortalLinkT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_portal_link_t.html">GridPortalLinkT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete class deriving from <code>GridPortalLink</code> that boxes a concrete grid for lookup.  <a href="class_acts_1_1_grid_portal_link_t.html#details">More...</a><br /></td></tr>
<tr class="memitem:GridSurfaceMaterialT" id="r_GridSurfaceMaterialT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_surface_material_t.html">GridSurfaceMaterialT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GridSurfaceMaterialT.  <a href="class_acts_1_1_grid_surface_material_t.html#details">More...</a><br /></td></tr>
<tr class="memitem:GsfComponent" id="r_GsfComponent"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_gsf_component.html">GsfComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a component of a Gaussian mixture as used by the GSF.  <a href="struct_acts_1_1_gsf_component.html#details">More...</a><br /></td></tr>
<tr class="memitem:GsfExtensions" id="r_GsfExtensions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_gsf_extensions.html">GsfExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The extensions needed for the GSF.  <a href="struct_acts_1_1_gsf_extensions.html#details">More...</a><br /></td></tr>
<tr class="memitem:GsfOptions" id="r_GsfOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_gsf_options.html">GsfOptions</a></td></tr>
<tr class="memitem:HelicalTrackLinearizer" id="r_HelicalTrackLinearizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_helical_track_linearizer.html">HelicalTrackLinearizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearizes the track parameters at the PCA to a user-provided point (linPoint).  <a href="class_acts_1_1_helical_track_linearizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:HomogeneousSurfaceMaterial" id="r_HomogeneousSurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_homogeneous_surface_material.html">HomogeneousSurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It extends the ISurfaceMaterial virtual base class to describe a simple homogeneous material on a surface.  <a href="class_acts_1_1_homogeneous_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:HomogeneousVolumeMaterial" id="r_HomogeneousVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_homogeneous_volume_material.html">HomogeneousVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It extends the IVolumeMaterial base class to describe a simple homogeneous material in a volume.  <a href="class_acts_1_1_homogeneous_volume_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:HoughVertexFinder" id="r_HoughVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_hough_vertex_finder.html">HoughVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the vertex finder based on the spacepoints using Hough transform For more information, see arXiv:2410.14494 0.  <a href="class_acts_1_1_hough_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:IAssignmentFinder" id="r_IAssignmentFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_assignment_finder.html">IAssignmentFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the material mapping that seeks the possible assignment candidates for the material interactiosn.  <a href="class_acts_1_1_i_assignment_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:IAxis" id="r_IAxis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_axis.html">IAxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for all Axis instance.  <a href="class_acts_1_1_i_axis.html#details">More...</a><br /></td></tr>
<tr class="memitem:IConfinedTrackingVolumeBuilder" id="r_IConfinedTrackingVolumeBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_confined_tracking_volume_builder.html">IConfinedTrackingVolumeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an interface class for constructing TrackingVolumes whose are confined in a mother-TrackingVolume.  <a href="class_acts_1_1_i_confined_tracking_volume_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:IExperimentCuts" id="r_IExperimentCuts"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_experiment_cuts.html">IExperimentCuts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>IExperimentCuts</code> can be used to increase or decrease seed weights based on the space points used in a seed.  <a href="class_acts_1_1_i_experiment_cuts.html#details">More...</a><br /></td></tr>
<tr class="memitem:IGrid" id="r_IGrid"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_grid.html">IGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all grid types.  <a href="class_acts_1_1_i_grid.html#details">More...</a><br /></td></tr>
<tr class="memitem:IGridMaterialAccessor" id="r_IGridMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_i_grid_material_accessor.html">IGridMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for material accessors, this is needed for the I/O of the different grid material types, in the actual implementation the material accessor is a template parameter.  <a href="struct_acts_1_1_i_grid_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:IGridSurfaceMaterial" id="r_IGridSurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_grid_surface_material.html">IGridSurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate interface to the grid surface material given access to the grid and the material accessor.  <a href="class_acts_1_1_i_grid_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:IGridSurfaceMaterialBase" id="r_IGridSurfaceMaterialBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_grid_surface_material_base.html">IGridSurfaceMaterialBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the concrete templated grid surface material types.  <a href="class_acts_1_1_i_grid_surface_material_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:ILayerArrayCreator" id="r_ILayerArrayCreator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_layer_array_creator.html">ILayerArrayCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class ILayerArrayCreators, it inherits from IAlgTool.  <a href="class_acts_1_1_i_layer_array_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ILayerBuilder" id="r_ILayerBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_layer_builder.html">ILayerBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for ILayerBuilders in a typical | EC- | Central | EC+ | detector setup.  <a href="class_acts_1_1_i_layer_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:IMaterialDecorator" id="r_IMaterialDecorator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_material_decorator.html">IMaterialDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for decorators that allow to load material onto a TrackingGeometry.  <a href="class_acts_1_1_i_material_decorator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ImpactParametersAndSigma" id="r_ImpactParametersAndSigma"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_impact_parameters_and_sigma.html">ImpactParametersAndSigma</a></td></tr>
<tr class="memitem:ImpactPointEstimator" id="r_ImpactPointEstimator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_impact_point_estimator.html">ImpactPointEstimator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimator for impact point calculations A description of the underlying mathematics can be found here: <a href="https://github.com/acts-project/acts/pull/2506">https://github.com/acts-project/acts/pull/2506</a> TODO: Upload reference at a better place.  <a href="class_acts_1_1_impact_point_estimator.html#details">More...</a><br /></td></tr>
<tr class="memitem:INavigationPolicy" id="r_INavigationPolicy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_navigation_policy.html">INavigationPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all navigation policies.  <a href="class_acts_1_1_i_navigation_policy.html#details">More...</a><br /></td></tr>
<tr class="memitem:IndexedMaterialAccessor" id="r_IndexedMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_indexed_material_accessor.html">IndexedMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor for cases where the material is filled in a vector and then indexed by the grid.  <a href="struct_acts_1_1_indexed_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:IndexGrid" id="r_IndexGrid"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_index_grid.html">IndexGrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an index grid based navigation state updator, it uses an extractor type and a filler type to handle the navigation state.  <a href="class_acts_1_1_index_grid.html#details">More...</a><br /></td></tr>
<tr class="memitem:IndexGridFiller" id="r_IndexGridFiller"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_index_grid_filler.html">IndexGridFiller</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that fills surfaces into predefined grids.  <a href="struct_acts_1_1_index_grid_filler.html#details">More...</a><br /></td></tr>
<tr class="memitem:IndexGridNavigationConfig" id="r_IndexGridNavigationConfig"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_index_grid_navigation_config.html">IndexGridNavigationConfig</a></td></tr>
<tr class="memitem:IndexGridNavigationPolicy" id="r_IndexGridNavigationPolicy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_index_grid_navigation_policy.html">IndexGridNavigationPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A navigation policy that uses grid based navigation for indexed surfaces Navigate through a multilayer structure by creating an artificial path on the grid.  <a href="class_acts_1_1_index_grid_navigation_policy.html#details">More...</a><br /></td></tr>
<tr class="memitem:InfiniteBounds" id="r_InfiniteBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_infinite_bounds.html">InfiniteBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">templated boundless extension to forward the interface Returns all inside checks to true and can templated for all bounds  <a href="class_acts_1_1_infinite_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:InputTrack" id="r_InputTrack"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_input_track.html">InputTrack</a></td></tr>
<tr class="memitem:InteractionVolume" id="r_InteractionVolume"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_interaction_volume.html">InteractionVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Material interaction volume struct.  <a href="struct_acts_1_1_interaction_volume.html#details">More...</a><br /></td></tr>
<tr class="memitem:InteractionVolumeCollector" id="r_InteractionVolumeCollector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_interaction_volume_collector.html">InteractionVolumeCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Interaction volume collector with unique counting.  <a href="struct_acts_1_1_interaction_volume_collector.html#details">More...</a><br /></td></tr>
<tr class="memitem:InterpolatedBFieldMap" id="r_InterpolatedBFieldMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates magnetic field value from field values on a given grid.  <a href="class_acts_1_1_interpolated_b_field_map.html#details">More...</a><br /></td></tr>
<tr class="memitem:InterpolatedMagneticField" id="r_InterpolatedMagneticField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_interpolated_magnetic_field.html">InterpolatedMagneticField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for interpolated magnetic field providers.  <a href="class_acts_1_1_interpolated_magnetic_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:InterpolatedMaterialMap" id="r_InterpolatedMaterialMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_interpolated_material_map.html">InterpolatedMaterialMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate material classification values from material values on a given grid.  <a href="class_acts_1_1_interpolated_material_map.html#details">More...</a><br /></td></tr>
<tr class="memitem:Intersection" id="r_Intersection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_intersection.html">Intersection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection struct containing the position, path length and status of an intersection.  <a href="class_acts_1_1_intersection.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntersectionMaterialAssigner" id="r_IntersectionMaterialAssigner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_intersection_material_assigner.html">IntersectionMaterialAssigner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A purely intersection based material assigner on a trial and error basis.  <a href="class_acts_1_1_intersection_material_assigner.html#details">More...</a><br /></td></tr>
<tr class="memitem:IReferenceGenerator" id="r_IReferenceGenerator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_i_reference_generator.html">IReferenceGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for reference point generators.  <a href="struct_acts_1_1_i_reference_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:IsReadOnlyMultiTrajectory" id="r_IsReadOnlyMultiTrajectory"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_multi_trajectory.html">IsReadOnlyMultiTrajectory</a></td></tr>
<tr class="memitem:IsReadOnlyMultiTrajectory_3C_20ActsPlugins_3A_3AConstPodioTrackStateContainer_20_3E" id="r_IsReadOnlyMultiTrajectory_3C_20ActsPlugins_3A_3AConstPodioTrackStateContainer_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_multi_trajectory_3_01_acts_plugins_1_1_const_podio_track_state_container_01_4.html">IsReadOnlyMultiTrajectory&lt; ActsPlugins::ConstPodioTrackStateContainer &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyMultiTrajectory_3C_20ActsPlugins_3A_3AMutablePodioTrackStateContainer_20_3E" id="r_IsReadOnlyMultiTrajectory_3C_20ActsPlugins_3A_3AMutablePodioTrackStateContainer_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_multi_trajectory_3_01_acts_plugins_1_1_mutable_podio_track_state_container_01_4.html">IsReadOnlyMultiTrajectory&lt; ActsPlugins::MutablePodioTrackStateContainer &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyMultiTrajectory_3C_20ConstVectorMultiTrajectory_20_3E" id="r_IsReadOnlyMultiTrajectory_3C_20ConstVectorMultiTrajectory_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_multi_trajectory_3_01_const_vector_multi_trajectory_01_4.html">IsReadOnlyMultiTrajectory&lt; ConstVectorMultiTrajectory &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyMultiTrajectory_3C_20VectorMultiTrajectory_20_3E" id="r_IsReadOnlyMultiTrajectory_3C_20VectorMultiTrajectory_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_multi_trajectory_3_01_vector_multi_trajectory_01_4.html">IsReadOnlyMultiTrajectory&lt; VectorMultiTrajectory &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyTrackContainer" id="r_IsReadOnlyTrackContainer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_track_container.html">IsReadOnlyTrackContainer</a></td></tr>
<tr class="memitem:IsReadOnlyTrackContainer_3C_20ActsPlugins_3A_3AConstPodioTrackContainer_20_3E" id="r_IsReadOnlyTrackContainer_3C_20ActsPlugins_3A_3AConstPodioTrackContainer_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_track_container_3_01_acts_plugins_1_1_const_podio_track_container_01_4.html">IsReadOnlyTrackContainer&lt; ActsPlugins::ConstPodioTrackContainer &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyTrackContainer_3C_20ActsPlugins_3A_3AMutablePodioTrackContainer_20_3E" id="r_IsReadOnlyTrackContainer_3C_20ActsPlugins_3A_3AMutablePodioTrackContainer_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_track_container_3_01_acts_plugins_1_1_mutable_podio_track_container_01_4.html">IsReadOnlyTrackContainer&lt; ActsPlugins::MutablePodioTrackContainer &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyTrackContainer_3C_20ConstVectorTrackContainer_20_3E" id="r_IsReadOnlyTrackContainer_3C_20ConstVectorTrackContainer_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_track_container_3_01_const_vector_track_container_01_4.html">IsReadOnlyTrackContainer&lt; ConstVectorTrackContainer &gt;</a></td></tr>
<tr class="memitem:IsReadOnlyTrackContainer_3C_20VectorTrackContainer_20_3E" id="r_IsReadOnlyTrackContainer_3C_20VectorTrackContainer_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_is_read_only_track_container_3_01_vector_track_container_01_4.html">IsReadOnlyTrackContainer&lt; VectorTrackContainer &gt;</a></td></tr>
<tr class="memitem:ISurfaceMaterial" id="r_ISurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all surface-based material description.  <a href="class_acts_1_1_i_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:ISurfaceMaterialAccumulater" id="r_ISurfaceMaterialAccumulater"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_surface_material_accumulater.html">ISurfaceMaterialAccumulater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the material mapping, this is the accumulation step.  <a href="class_acts_1_1_i_surface_material_accumulater.html#details">More...</a><br /></td></tr>
<tr class="memitem:IterativeVertexFinder" id="r_IterativeVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_iterative_vertex_finder.html">IterativeVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an iterative vertex finder.  <a href="class_acts_1_1_iterative_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITrackingGeometryBuilder" id="r_ITrackingGeometryBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_tracking_geometry_builder.html">ITrackingGeometryBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class for the TrackingGeometry building, this is used by the TrackingGeometrySvc to build the geometry.  <a href="class_acts_1_1_i_tracking_geometry_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITrackingGeometryJsonDecorator" id="r_ITrackingGeometryJsonDecorator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_tracking_geometry_json_decorator.html">ITrackingGeometryJsonDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class to add extra information to surface or volume json objects  <a href="class_acts_1_1_i_tracking_geometry_json_decorator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITrackingGeometryVisitor" id="r_ITrackingGeometryVisitor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_tracking_geometry_visitor.html">ITrackingGeometryVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tracking geometry visitors.  <a href="class_acts_1_1_i_tracking_geometry_visitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITrackingVolumeArrayCreator" id="r_ITrackingVolumeArrayCreator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_tracking_volume_array_creator.html">ITrackingVolumeArrayCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class ITrackingVolumeArrayCreators It inherits from IAlgTool.  <a href="class_acts_1_1_i_tracking_volume_array_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITrackingVolumeBuilder" id="r_ITrackingVolumeBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_tracking_volume_builder.html">ITrackingVolumeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class ITrackingVolumeBuilders.  <a href="class_acts_1_1_i_tracking_volume_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITrackingVolumeHelper" id="r_ITrackingVolumeHelper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_tracking_volume_helper.html">ITrackingVolumeHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface class ITrackingVolumeHelper tools, it inherits from IAlgTool.  <a href="class_acts_1_1_i_tracking_volume_helper.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITripletSeedCuts" id="r_ITripletSeedCuts"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_triplet_seed_cuts.html">ITripletSeedCuts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>ITripletSeedCuts</code> can be used to increase or decrease seed weights based on the space points used in a seed.  <a href="class_acts_1_1_i_triplet_seed_cuts.html#details">More...</a><br /></td></tr>
<tr class="memitem:ITripletSeedFilter" id="r_ITripletSeedFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_triplet_seed_filter.html">ITripletSeedFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for triplet seed filtering.  <a href="class_acts_1_1_i_triplet_seed_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:IVertexFinder" id="r_IVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_vertex_finder.html">IVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common interface for both vertex finders and vertex seed finders.  <a href="class_acts_1_1_i_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:IVisualization3D" id="r_IVisualization3D"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_visualization3_d.html">IVisualization3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially abstract base class which provides an interface to visualization helper classes.  <a href="class_acts_1_1_i_visualization3_d.html#details">More...</a><br /></td></tr>
<tr class="memitem:IVolumeMaterial" id="r_IVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_volume_material.html">IVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material associated with a Volume (homogeneous, binned, interpolated).  <a href="class_acts_1_1_i_volume_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:IVolumeMaterialJsonDecorator" id="r_IVolumeMaterialJsonDecorator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_volume_material_json_decorator.html">IVolumeMaterialJsonDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class to add extra information to surface or volume json objects  <a href="class_acts_1_1_i_volume_material_json_decorator.html#details">More...</a><br /></td></tr>
<tr class="memitem:JsonDetectorElement" id="r_JsonDetectorElement"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_json_detector_element.html">JsonDetectorElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A implementation of a detector element, that is constructed from a JSON description of a surface.  <a href="class_acts_1_1_json_detector_element.html#details">More...</a><br /></td></tr>
<tr class="memitem:jsonKey" id="r_jsonKey"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1json_key.html">jsonKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">store in a single place the different key used for the material mapping  <a href="struct_acts_1_1json_key.html#details">More...</a><br /></td></tr>
<tr class="memitem:JsonMaterialDecorator" id="r_JsonMaterialDecorator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_json_material_decorator.html">JsonMaterialDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material decorator from Json format.  <a href="class_acts_1_1_json_material_decorator.html#details">More...</a><br /></td></tr>
<tr class="memitem:KalmanFitter" id="r_KalmanFitter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_kalman_fitter.html">KalmanFitter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman fitter implementation.  <a href="class_acts_1_1_kalman_fitter.html#details">More...</a><br /></td></tr>
<tr class="memitem:KalmanFitterExtensions" id="r_KalmanFitterExtensions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_kalman_fitter_extensions.html">KalmanFitterExtensions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension struct which holds delegates to customise the KF behavior.  <a href="struct_acts_1_1_kalman_fitter_extensions.html#details">More...</a><br /></td></tr>
<tr class="memitem:KalmanFitterOptions" id="r_KalmanFitterOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_kalman_fitter_options.html">KalmanFitterOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined options for the Kalman fitter.  <a href="struct_acts_1_1_kalman_fitter_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:KalmanFitterResult" id="r_KalmanFitterResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_kalman_fitter_result.html">KalmanFitterResult</a></td></tr>
<tr class="memitem:KDTree" id="r_KDTree"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_k_d_tree.html">KDTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general k-d tree with fast range search.  <a href="class_acts_1_1_k_d_tree.html#details">More...</a><br /></td></tr>
<tr class="memitem:KdtSurfaces" id="r_KdtSurfaces"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_kdt_surfaces.html">KdtSurfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class around a KDTree of surfaces.  <a href="class_acts_1_1_kdt_surfaces.html#details">More...</a><br /></td></tr>
<tr class="memitem:Layer" id="r_Layer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_layer.html">Layer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base Class for a Detector Layer in the Tracking Geometry.  <a href="class_acts_1_1_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:LayerArrayCreator" id="r_LayerArrayCreator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_layer_array_creator.html">LayerArrayCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LayerArrayCreator is a simple Tool that helps to construct LayerArrays from std::vector of Acts::CylinderLayer, Acts::DiscLayer, Acts::PlaneLayer.  <a href="class_acts_1_1_layer_array_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:LayerCreator" id="r_LayerCreator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_layer_creator.html">LayerCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The LayerCreator is able to build cylinder disc layers or plane layers from detector elements.  <a href="class_acts_1_1_layer_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinCircle" id="r_LinCircle"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_lin_circle.html">LinCircle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial description of a circle in u-v space.  <a href="struct_acts_1_1_lin_circle.html#details">More...</a><br /></td></tr>
<tr class="memitem:LinearizedTrack" id="r_LinearizedTrack"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_linearized_track.html">LinearizedTrack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for linear expansion of track parameters in vicinity of vertex.  <a href="struct_acts_1_1_linearized_track.html#details">More...</a><br /></td></tr>
<tr class="memitem:LineBounds" id="r_LineBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_line_bounds.html">LineBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds for a LineSurface.  <a href="class_acts_1_1_line_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:LineSurface" id="r_LineSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_line_surface.html">LineSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a linear surfaces in the TrackingGeometry to describe dirft tube, straw like detectors or the Perigee It inherits from Surface.  <a href="class_acts_1_1_line_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:Logger" id="r_Logger"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for printing debug output  <a href="class_acts_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="memitem:MagneticFieldContext" id="r_MagneticFieldContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_magnetic_field_context.html">MagneticFieldContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object for lookup of magnetic field values.  <a href="class_acts_1_1_magnetic_field_context.html#details">More...</a><br /></td></tr>
<tr class="memitem:MagneticFieldProvider" id="r_MagneticFieldProvider"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_magnetic_field_provider.html">MagneticFieldProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all magnetic field providers.  <a href="class_acts_1_1_magnetic_field_provider.html#details">More...</a><br /></td></tr>
<tr class="memitem:Material" id="r_Material"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material.html">Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material description for interactions with matter.  <a href="class_acts_1_1_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialComposition" id="r_MaterialComposition"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material_composition.html">MaterialComposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material composed from multiple elements with varying factions.  <a href="class_acts_1_1_material_composition.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialInteraction" id="r_MaterialInteraction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_interaction.html">MaterialInteraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Material interaction struct It records the surface and the passed material This is only necessary recorded when configured.  <a href="struct_acts_1_1_material_interaction.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialInteractor" id="r_MaterialInteractor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_interactor.html">MaterialInteractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material interactor propagator action.  <a href="struct_acts_1_1_material_interactor.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialMapJsonConverter" id="r_MaterialMapJsonConverter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material_map_json_converter.html">MaterialMapJsonConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">read the material from Json  <a href="class_acts_1_1_material_map_json_converter.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialMapLookup" id="r_MaterialMapLookup"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for mapping global 3D positions to material values.  <a href="struct_acts_1_1_material_map_lookup.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialMapper" id="r_MaterialMapper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material_mapper.html">MaterialMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that implements the material mapping procedure.  <a href="class_acts_1_1_material_mapper.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialSlab" id="r_MaterialSlab"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material description for an object with defined thickness.  <a href="class_acts_1_1_material_slab.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialSurface" id="r_MaterialSurface"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_surface.html">MaterialSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">selector for finding surface  <a href="struct_acts_1_1_material_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialSurfaceIdentifier" id="r_MaterialSurfaceIdentifier"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_surface_identifier.html">MaterialSurfaceIdentifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">selector for finding surface  <a href="struct_acts_1_1_material_surface_identifier.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialValidater" id="r_MaterialValidater"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material_validater.html">MaterialValidater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The material validater is a tool that allows to record the material seen by a ray through a set of material surfaces.  <a href="class_acts_1_1_material_validater.html#details">More...</a><br /></td></tr>
<tr class="memitem:MaterialVolume" id="r_MaterialVolume"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_volume.html">MaterialVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">selector for finding volume  <a href="struct_acts_1_1_material_volume.html#details">More...</a><br /></td></tr>
<tr class="memitem:MbfSmoother" id="r_MbfSmoother"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_mbf_smoother.html">MbfSmoother</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman trajectory smoother based on the Modified BrysonFrazier (mBF) smoother.  <a href="class_acts_1_1_mbf_smoother.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeasurementSelector" id="r_MeasurementSelector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_measurement_selector.html">MeasurementSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measurement selection struct selecting those measurements compatible with the given track parameter against provided criteria on one surface.  <a href="class_acts_1_1_measurement_selector.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeasurementSelectorCuts" id="r_MeasurementSelectorCuts"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_measurement_selector_cuts.html">MeasurementSelectorCuts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection cuts for associating measurements with predicted track parameters on a surface.  <a href="struct_acts_1_1_measurement_selector_cuts.html#details">More...</a><br /></td></tr>
<tr class="memitem:MiddleSpInfo" id="r_MiddleSpInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_middle_sp_info.html">MiddleSpInfo</a></td></tr>
<tr class="memitem:missing_5Fspecialization" id="r_missing_5Fspecialization"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1missing__specialization.html">missing_specialization</a></td></tr>
<tr class="memitem:MultiComponentBoundTrackParameters" id="r_MultiComponentBoundTrackParameters"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_component_bound_track_parameters.html">MultiComponentBoundTrackParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is only a light wrapper around a surface and a vector of parameters.  <a href="class_acts_1_1_multi_component_bound_track_parameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiIndex" id="r_MultiIndex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_index.html">MultiIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of (hierarchical) indices bitpacked into a single value.  <a href="class_acts_1_1_multi_index.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiIntersection" id="r_MultiIntersection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_intersection.html">MultiIntersection</a></td></tr>
<tr class="memitem:MultiNavigationPolicy" id="r_MultiNavigationPolicy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_navigation_policy.html">MultiNavigationPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined navigation policy that calls all contained other navigation policies.  <a href="class_acts_1_1_multi_navigation_policy.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiRangeBField" id="r_MultiRangeBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_range_b_field.html">MultiRangeBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetic field provider modelling a magnetic field consisting of several (potentially overlapping) regions of constant values.  <a href="class_acts_1_1_multi_range_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiStepperLoop" id="r_MultiStepperLoop"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_stepper_loop.html">MultiStepperLoop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stepper based on a single-component stepper, but can handle Multi-Component Tracks (e.g., for the GSF).  <a href="class_acts_1_1_multi_stepper_loop.html#details">More...</a><br /></td></tr>
<tr class="memitem:MultiStepperSurfaceReached" id="r_MultiStepperSurfaceReached"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_multi_stepper_surface_reached.html">MultiStepperSurfaceReached</a></td></tr>
<tr class="memitem:MultiTrajectory" id="r_MultiTrajectory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a trajectory of track states with multiple components.  <a href="class_acts_1_1_multi_trajectory.html#details">More...</a><br /></td></tr>
<tr class="memitem:MutableProtoLayer" id="r_MutableProtoLayer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_mutable_proto_layer.html">MutableProtoLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable proto layer that can be modified after construction.  <a href="struct_acts_1_1_mutable_proto_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigationArguments" id="r_NavigationArguments"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_navigation_arguments.html">NavigationArguments</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that serves as the argument to the navigation delegate.  <a href="struct_acts_1_1_navigation_arguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigationLayer" id="r_NavigationLayer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_navigation_layer.html">NavigationLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to be used for gaps in Volumes as a navigational link.  <a href="class_acts_1_1_navigation_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigationOptions" id="r_NavigationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_navigation_options.html">NavigationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The navigation options for the tracking geometry.  <a href="struct_acts_1_1_navigation_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigationPolicyFactory" id="r_NavigationPolicyFactory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_navigation_policy_factory.html">NavigationPolicyFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for navigation policy factories.  <a href="class_acts_1_1_navigation_policy_factory.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigationStream" id="r_NavigationStream"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_navigation_stream.html">NavigationStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The NavigationStream is a container for the navigation candidates that are currentlu processed in a given context.  <a href="class_acts_1_1_navigation_stream.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigationTarget" id="r_NavigationTarget"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_navigation_target.html">NavigationTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The navigation target.  <a href="class_acts_1_1_navigation_target.html#details">More...</a><br /></td></tr>
<tr class="memitem:Navigator" id="r_Navigator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_navigator.html">Navigator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steers the propagation through the geometry by providing the next surface to be targeted.  <a href="class_acts_1_1_navigator.html#details">More...</a><br /></td></tr>
<tr class="memitem:NavigatorPlainOptions" id="r_NavigatorPlainOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_navigator_plain_options.html">NavigatorPlainOptions</a></td></tr>
<tr class="memitem:NavigatorStatistics" id="r_NavigatorStatistics"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_navigator_statistics.html">NavigatorStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold statistics of the navigator.  <a href="struct_acts_1_1_navigator_statistics.html#details">More...</a><br /></td></tr>
<tr class="memitem:NeighborHoodIndices" id="r_NeighborHoodIndices"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_neighbor_hood_indices.html">NeighborHoodIndices</a></td></tr>
<tr class="memitem:Neighbour" id="r_Neighbour"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_neighbour.html">Neighbour</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that helps in processing the neighbours, given a collection of middle space points The idea here is that in the seeding we look for compatible b-m and m-t doublets.  <a href="struct_acts_1_1_neighbour.html#details">More...</a><br /></td></tr>
<tr class="memitem:Neutral" id="r_Neutral"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_neutral.html">Neutral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charge and momentum interpretation for neutral particles.  <a href="struct_acts_1_1_neutral.html#details">More...</a><br /></td></tr>
<tr class="memitem:NeutralParticleHypothesis" id="r_NeutralParticleHypothesis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_neutral_particle_hypothesis.html">NeutralParticleHypothesis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized particle hypothesis for neutral particles.  <a href="class_acts_1_1_neutral_particle_hypothesis.html#details">More...</a><br /></td></tr>
<tr class="memitem:NonNeutralCharge" id="r_NonNeutralCharge"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_non_neutral_charge.html">NonNeutralCharge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charge and momentum interpretation for arbitrarily charged but not neutral particles.  <a href="class_acts_1_1_non_neutral_charge.html#details">More...</a><br /></td></tr>
<tr class="memitem:NonNeutralChargedParticleHypothesis" id="r_NonNeutralChargedParticleHypothesis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_non_neutral_charged_particle_hypothesis.html">NonNeutralChargedParticleHypothesis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized particle hypothesis for non-neutral particles.  <a href="class_acts_1_1_non_neutral_charged_particle_hypothesis.html#details">More...</a><br /></td></tr>
<tr class="memitem:NullBField" id="r_NullBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_null_b_field.html">NullBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null bfield which returns 0 always.  <a href="class_acts_1_1_null_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:NumericalTrackLinearizer" id="r_NumericalTrackLinearizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_numerical_track_linearizer.html">NumericalTrackLinearizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearizes the track parameters at the PCA to a user-provided point (linPoint).  <a href="class_acts_1_1_numerical_track_linearizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ObjectSorterT" id="r_ObjectSorterT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_object_sorter_t.html">ObjectSorterT</a></td></tr>
<tr class="memitem:ObjVisualization3D" id="r_ObjVisualization3D"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_obj_visualization3_d.html">ObjVisualization3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper produces output in the OBJ format.  <a href="class_acts_1_1_obj_visualization3_d.html#details">More...</a><br /></td></tr>
<tr class="memitem:OrientedSurface" id="r_OrientedSurface"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_oriented_surface.html">OrientedSurface</a></td></tr>
<tr class="memitem:overloaded" id="r_overloaded"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1overloaded.html">overloaded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct that can turn a set of lambdas into a single entity with overloaded call operator.  <a href="struct_acts_1_1overloaded.html#details">More...</a><br /></td></tr>
<tr class="memitem:OwningDelegate" id="r_OwningDelegate"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_owning_delegate.html">OwningDelegate</a></td></tr>
<tr class="memitem:OwningDelegate_3C_20R_28Args_2E_2E_2E_29_2C_20H_20_3E" id="r_OwningDelegate_3C_20R_28Args_2E_2E_2E_29_2C_20H_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_owning_delegate_3_01_r_07_args_8_8_8_08_00_01_h_01_4.html">OwningDelegate&lt; R(Args...), H &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an owning delegate.  <a href="class_acts_1_1_owning_delegate_3_01_r_07_args_8_8_8_08_00_01_h_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:ParticleData" id="r_ParticleData"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_particle_data.html">ParticleData</a></td></tr>
<tr class="memitem:ParticleHypothesis" id="r_ParticleHypothesis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized particle hypothesis for any kind of charged particles.  <a href="class_acts_1_1_particle_hypothesis.html#details">More...</a><br /></td></tr>
<tr class="memitem:PassiveLayerBuilder" id="r_PassiveLayerBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_passive_layer_builder.html">PassiveLayerBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The PassiveLayerBuilder is able to build cylinder &amp; disc layers with given dimensions and material.  <a href="class_acts_1_1_passive_layer_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:PathLimitReached" id="r_PathLimitReached"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_path_limit_reached.html">PathLimitReached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the condition that the pathLimit has been reached.  <a href="struct_acts_1_1_path_limit_reached.html#details">More...</a><br /></td></tr>
<tr class="memitem:PathSeeder" id="r_PathSeeder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_path_seeder.html">PathSeeder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seeding algorigthm that extracts the IP parameters and sorts the source links into possible track candidates.  <a href="class_acts_1_1_path_seeder.html#details">More...</a><br /></td></tr>
<tr class="memitem:PerigeeSurface" id="r_PerigeeSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_perigee_surface.html">PerigeeSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class describing the Line to which the Perigee refers to.  <a href="class_acts_1_1_perigee_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:PlanarBounds" id="r_PlanarBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_planar_bounds.html">PlanarBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">common base class for all bounds that are in a local x/y cartesian frame  <a href="class_acts_1_1_planar_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:PlaneLayer" id="r_PlaneLayer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_plane_layer.html">PlaneLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to describe a planar detector layer for tracking, it inherits from both, Layer base class and PlaneSurface class.  <a href="class_acts_1_1_plane_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:PlaneSurface" id="r_PlaneSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_plane_surface.html">PlaneSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a planaer in the TrackingGeometry.  <a href="class_acts_1_1_plane_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:PlyVisualization3D" id="r_PlyVisualization3D"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_ply_visualization3_d.html">PlyVisualization3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to write out PlyVisualization3D visualization format.  <a href="class_acts_1_1_ply_visualization3_d.html#details">More...</a><br /></td></tr>
<tr class="memitem:Polyhedron" id="r_Polyhedron"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_polyhedron.html">Polyhedron</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct which contains a cartesian approximation for any surface type.  <a href="struct_acts_1_1_polyhedron.html#details">More...</a><br /></td></tr>
<tr class="memitem:PolyhedronReferenceGenerator" id="r_PolyhedronReferenceGenerator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_polyhedron_reference_generator.html">PolyhedronReferenceGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to access generated vertices from surface polyhedrons These vertices are then used to find the bin boundary box for the indexed grid.  <a href="struct_acts_1_1_polyhedron_reference_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Portal" id="r_Portal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_portal.html">Portal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A portal connects two or more neighboring volumes.  <a href="class_acts_1_1_portal.html#details">More...</a><br /></td></tr>
<tr class="memitem:PortalFusingException" id="r_PortalFusingException"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_portal_fusing_exception.html">PortalFusingException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when portals cannot be fused.  <a href="class_acts_1_1_portal_fusing_exception.html#details">More...</a><br /></td></tr>
<tr class="memitem:PortalLinkBase" id="r_PortalLinkBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_portal_link_base.html">PortalLinkBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PortalLinkBase is the abstract base class for all portal links.  <a href="class_acts_1_1_portal_link_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:PortalMergingException" id="r_PortalMergingException"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_portal_merging_exception.html">PortalMergingException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when portals cannot be merged.  <a href="class_acts_1_1_portal_merging_exception.html#details">More...</a><br /></td></tr>
<tr class="memitem:PortalShellBase" id="r_PortalShellBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_portal_shell_base.html">PortalShellBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portal shell of a volume is the set of portals that describes connections "outside" of the volume.  <a href="class_acts_1_1_portal_shell_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProjectedReferenceGenerator" id="r_ProjectedReferenceGenerator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_projected_reference_generator.html">ProjectedReferenceGenerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Projected reference generator which projects the polyhedron vertices onto a given reference surface.  <a href="struct_acts_1_1_projected_reference_generator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Propagator" id="r_Propagator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_propagator.html">Propagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagator for particles (optionally in a magnetic field).  <a href="class_acts_1_1_propagator.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropagatorMaterialAssigner" id="r_PropagatorMaterialAssigner"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_propagator_material_assigner.html">PropagatorMaterialAssigner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Propagator based material assigner that uses the navigation and transport of the propagator to assign the material to the surface or the volume.  <a href="class_acts_1_1_propagator_material_assigner.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropagatorOptions" id="r_PropagatorOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_propagator_options.html">PropagatorOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for propagate() call.  <a href="struct_acts_1_1_propagator_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropagatorPlainOptions" id="r_PropagatorPlainOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_propagator_plain_options.html">PropagatorPlainOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the generic propagator options.  <a href="struct_acts_1_1_propagator_plain_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropagatorResult" id="r_PropagatorResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_propagator_result.html">PropagatorResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class holding result of propagation call.  <a href="struct_acts_1_1_propagator_result.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropagatorState" id="r_PropagatorState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_propagator_state.html">PropagatorState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">private Propagator state for navigation and debugging  <a href="struct_acts_1_1_propagator_state.html#details">More...</a><br /></td></tr>
<tr class="memitem:PropagatorStatistics" id="r_PropagatorStatistics"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_propagator_statistics.html">PropagatorStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold statistics of the propagator.  <a href="struct_acts_1_1_propagator_statistics.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProtoAxis" id="r_ProtoAxis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a pure run-time placeholder for the axis definition.  <a href="class_acts_1_1_proto_axis.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProtoLayer" id="r_ProtoLayer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_proto_layer.html">ProtoLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward-declaration friendly class for backward compatibility This class does not allow modification of the underlying surfaces.  <a href="struct_acts_1_1_proto_layer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProtoLayerHelper" id="r_ProtoLayerHelper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_proto_layer_helper.html">ProtoLayerHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is designed to parse a vector of Surfaces and sort them into corresponding proto layers.  <a href="class_acts_1_1_proto_layer_helper.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProtoSurfaceMaterialT" id="r_ProtoSurfaceMaterialT"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_proto_surface_material_t.html">ProtoSurfaceMaterialT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">proxy to SurfaceMaterial hand over BinUtility or other suitable binning description  <a href="class_acts_1_1_proto_surface_material_t.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProtoVolumeMaterial" id="r_ProtoVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_proto_volume_material.html">ProtoVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">proxy to VolumeMaterial hand over BinUtility  <a href="class_acts_1_1_proto_volume_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:ProxyAccessorBase" id="r_ProxyAccessorBase"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_proxy_accessor_base.html">ProxyAccessorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that eases accessing dynamic columns in track and track state containers.  <a href="struct_acts_1_1_proxy_accessor_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:RadialBounds" id="r_RadialBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_radial_bounds.html">RadialBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to describe the bounds for a planar DiscSurface.  <a href="class_acts_1_1_radial_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:RangeXD" id="r_RangeXD"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_range_x_d.html">RangeXD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An orthogonal range in an arbitrary number of dimensions.  <a href="class_acts_1_1_range_x_d.html#details">More...</a><br /></td></tr>
<tr class="memitem:Ray" id="r_Ray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_ray.html">Ray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which models a ray.  <a href="class_acts_1_1_ray.html#details">More...</a><br /></td></tr>
<tr class="memitem:RecordedMaterial" id="r_RecordedMaterial"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_recorded_material.html">RecordedMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple result struct to be returned It mainly acts as an internal state which is created for every propagation/extrapolation step.  <a href="struct_acts_1_1_recorded_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:RectangleBounds" id="r_RectangleBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_rectangle_bounds.html">RectangleBounds</a></td></tr>
<tr class="memitem:RegularSurface" id="r_RegularSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_regular_surface.html">RegularSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A physical surface which does not depend on the direction you look at it from.  <a href="class_acts_1_1_regular_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:RemovePointer" id="r_RemovePointer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_remove_pointer.html">RemovePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduce the Acts version of the pointer remove type trait because we want to fetch the underlying type for the pointer concept and std::library does not allow for an extension of the std::remove_pointer;.  <a href="struct_acts_1_1_remove_pointer.html#details">More...</a><br /></td></tr>
<tr class="memitem:RemovePointer_3C_20T_20_3E" id="r_RemovePointer_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_remove_pointer_3_01_t_01_4.html">RemovePointer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization allows std::remove_pointer to work with types satisfying Acts::SmartPointerConcept, similar to how it works with raw pointers.  <a href="struct_acts_1_1_remove_pointer_3_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:Result" id="r_Result"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_result.html">Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which encapsulates either a valid result, or an error.  <a href="class_acts_1_1_result.html#details">More...</a><br /></td></tr>
<tr class="memitem:Result_3C_20void_2C_20E_20_3E" id="r_Result_3C_20void_2C_20E_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_result_3_01void_00_01_e_01_4.html">Result&lt; void, E &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for the void case.  <a href="class_acts_1_1_result_3_01void_00_01_e_01_4.html#details">More...</a><br /></td></tr>
<tr class="memitem:RiddersPropagator" id="r_RiddersPropagator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_ridders_propagator.html">RiddersPropagator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs the Ridders algorithm to estimate the propagation of the covariance to a certain point in space.  <a href="class_acts_1_1_ridders_propagator.html#details">More...</a><br /></td></tr>
<tr class="memitem:RiddersPropagatorOptions" id="r_RiddersPropagatorOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_ridders_propagator_options.html">RiddersPropagatorOptions</a></td></tr>
<tr class="memitem:ScopedTimer" id="r_ScopedTimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_scoped_timer.html">ScopedTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A RAII timer class for measuring execution time of code blocks.  <a href="class_acts_1_1_scoped_timer.html#details">More...</a><br /></td></tr>
<tr class="memitem:ScoreBasedAmbiguityResolution" id="r_ScoreBasedAmbiguityResolution"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_score_based_ambiguity_resolution.html">ScoreBasedAmbiguityResolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic implementation of the score based ambiguity resolution.  <a href="class_acts_1_1_score_based_ambiguity_resolution.html#details">More...</a><br /></td></tr>
<tr class="memitem:Seed" id="r_Seed"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_seed.html">Seed</a></td></tr>
<tr class="memitem:SeedConfirmationRangeConfig" id="r_SeedConfirmationRangeConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_seed_confirmation_range_config.html">SeedConfirmationRangeConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains parameters for quality seed confirmation.  <a href="struct_acts_1_1_seed_confirmation_range_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:SeedContainer2" id="r_SeedContainer2"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_seed_container2.html">SeedContainer2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container of seeds.  <a href="class_acts_1_1_seed_container2.html#details">More...</a><br /></td></tr>
<tr class="memitem:SeedFilter" id="r_SeedFilter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_seed_filter.html">SeedFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter seeds at various stages with the currently available information.  <a href="class_acts_1_1_seed_filter.html#details">More...</a><br /></td></tr>
<tr class="memitem:SeedFilterConfig" id="r_SeedFilterConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_seed_filter_config.html">SeedFilterConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds configuration parameters for the seed filter algorithm.  <a href="struct_acts_1_1_seed_filter_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:SeedFilterState" id="r_SeedFilterState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_seed_filter_state.html">SeedFilterState</a></td></tr>
<tr class="memitem:SeedFinder" id="r_SeedFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_seed_finder.html">SeedFinder</a></td></tr>
<tr class="memitem:SeedFinderConfig" id="r_SeedFinderConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_seed_finder_config.html">SeedFinderConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds configuration parameters for the seed finder algorithm.  <a href="struct_acts_1_1_seed_finder_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:SeedFinderOptions" id="r_SeedFinderOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_seed_finder_options.html">SeedFinderOptions</a></td></tr>
<tr class="memitem:SeedFinderOrthogonal" id="r_SeedFinderOrthogonal"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_seed_finder_orthogonal.html">SeedFinderOrthogonal</a></td></tr>
<tr class="memitem:SeedFinderOrthogonalConfig" id="r_SeedFinderOrthogonalConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_seed_finder_orthogonal_config.html">SeedFinderOrthogonalConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that holds configuration parameters for the orthogonal seed finder algorithm.  <a href="struct_acts_1_1_seed_finder_orthogonal_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:SeedProxy2" id="r_SeedProxy2"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_seed_proxy2.html">SeedProxy2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for accessing individual seeds.  <a href="class_acts_1_1_seed_proxy2.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleCuboidPortalShell" id="r_SingleCuboidPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_single_cuboid_portal_shell.html">SingleCuboidPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a cuboid shell containing a single volume.  <a href="class_acts_1_1_single_cuboid_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleCylinderPortalShell" id="r_SingleCylinderPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_single_cylinder_portal_shell.html">SingleCylinderPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a cylinder shell containing a single volume.  <a href="class_acts_1_1_single_cylinder_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleDiamondPortalShell" id="r_SingleDiamondPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_single_diamond_portal_shell.html">SingleDiamondPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a portal shell class for a single convex polygon volume.  <a href="class_acts_1_1_single_diamond_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:SingleTrapezoidPortalShell" id="r_SingleTrapezoidPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_single_trapezoid_portal_shell.html">SingleTrapezoidPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a trapezoid shell containing a single volume.  <a href="class_acts_1_1_single_trapezoid_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:SinglyCharged" id="r_SinglyCharged"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_singly_charged.html">SinglyCharged</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Charge and momentum interpretation for particles with +-e charge.  <a href="struct_acts_1_1_singly_charged.html#details">More...</a><br /></td></tr>
<tr class="memitem:SinglyChargedParticleHypothesis" id="r_SinglyChargedParticleHypothesis"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_singly_charged_particle_hypothesis.html">SinglyChargedParticleHypothesis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized particle hypothesis for singly charged particles.  <a href="class_acts_1_1_singly_charged_particle_hypothesis.html#details">More...</a><br /></td></tr>
<tr class="memitem:SolenoidBField" id="r_SolenoidBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_solenoid_b_field.html">SolenoidBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytical solenoid magnetic field implementation.  <a href="class_acts_1_1_solenoid_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:SourceLink" id="r_SourceLink"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a></td></tr>
<tr class="memitem:SourceLinkAdapterIterator" id="r_SourceLinkAdapterIterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_source_link_adapter_iterator.html">SourceLinkAdapterIterator</a></td></tr>
<tr class="memitem:SpacePointBuilder" id="r_SpacePointBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_builder.html">SpacePointBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">After the particle interaction with surfaces are recorded and digitized measurements on the pixel or strip detectors need further treatment.  <a href="class_acts_1_1_space_point_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointBuilderConfig" id="r_SpacePointBuilderConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_space_point_builder_config.html">SpacePointBuilderConfig</a></td></tr>
<tr class="memitem:SpacePointBuilderOptions" id="r_SpacePointBuilderOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_space_point_builder_options.html">SpacePointBuilderOptions</a></td></tr>
<tr class="memitem:SpacePointColumnProxy" id="r_SpacePointColumnProxy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_column_proxy.html">SpacePointColumnProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional column of data that can be added to the space point container.  <a href="class_acts_1_1_space_point_column_proxy.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointContainer" id="r_SpacePointContainer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_container.html">SpacePointContainer</a></td></tr>
<tr class="memitem:SpacePointContainer2" id="r_SpacePointContainer2"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_container2.html">SpacePointContainer2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for space points, which can hold additional columns of data and allows for efficient access to space points and their associated source links.  <a href="class_acts_1_1_space_point_container2.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointContainerConfig" id="r_SpacePointContainerConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_space_point_container_config.html">SpacePointContainerConfig</a></td></tr>
<tr class="memitem:SpacePointContainerOptions" id="r_SpacePointContainerOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_space_point_container_options.html">SpacePointContainerOptions</a></td></tr>
<tr class="memitem:SpacePointData" id="r_SpacePointData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_data.html">SpacePointData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains auxiliary data associated to the external space points provided by the customers These variables are used internally by the seeding algorithm, that reads them The variables collected here are also dynamic variables only present for strip space points.  <a href="class_acts_1_1_space_point_data.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointMutableData" id="r_SpacePointMutableData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_mutable_data.html">SpacePointMutableData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains mutable data associated to the external space points provided by the customers These variables are used mainly internally by the seeding algorithm, that reads and updates them for seed selection purposes.  <a href="class_acts_1_1_space_point_mutable_data.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointParameters" id="r_SpacePointParameters"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_space_point_parameters.html">SpacePointParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage container for variables related to the calculation of space points.  <a href="struct_acts_1_1_space_point_parameters.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointProxy" id="r_SpacePointProxy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_proxy.html">SpacePointProxy</a></td></tr>
<tr class="memitem:SpacePointProxy2" id="r_SpacePointProxy2"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_proxy2.html">SpacePointProxy2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy class for accessing individual space points.  <a href="class_acts_1_1_space_point_proxy2.html#details">More...</a><br /></td></tr>
<tr class="memitem:SpacePointUtility" id="r_SpacePointUtility"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_space_point_utility.html">SpacePointUtility</a></td></tr>
<tr class="memitem:StepperPlainOptions" id="r_StepperPlainOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_stepper_plain_options.html">StepperPlainOptions</a></td></tr>
<tr class="memitem:StepperStatistics" id="r_StepperStatistics"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_stepper_statistics.html">StepperStatistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to hold statistics of the stepper.  <a href="struct_acts_1_1_stepper_statistics.html#details">More...</a><br /></td></tr>
<tr class="memitem:StraightLineStepper" id="r_StraightLineStepper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_straight_line_stepper.html">StraightLineStepper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">straight line stepper based on Surface intersection  <a href="class_acts_1_1_straight_line_stepper.html#details">More...</a><br /></td></tr>
<tr class="memitem:StrawSurface" id="r_StrawSurface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_straw_surface.html">StrawSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for a StrawSurface in the TrackingGeometry to describe dirft tube and straw like detectors.  <a href="class_acts_1_1_straw_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:StripPairOptions" id="r_StripPairOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_strip_pair_options.html">StripPairOptions</a></td></tr>
<tr class="memitem:SupportsBoundParameters" id="r_SupportsBoundParameters"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_supports_bound_parameters.html">SupportsBoundParameters</a></td></tr>
<tr class="memitem:SupportsBoundParameters_3C_20EigenStepper_3C_3E_20_3E" id="r_SupportsBoundParameters_3C_20EigenStepper_3C_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_supports_bound_parameters_3_01_eigen_stepper_3_4_01_4.html">SupportsBoundParameters&lt; EigenStepper&lt;&gt; &gt;</a></td></tr>
<tr class="memitem:SupportsBoundParameters_3C_20StraightLineStepper_20_3E" id="r_SupportsBoundParameters_3C_20StraightLineStepper_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_supports_bound_parameters_3_01_straight_line_stepper_01_4.html">SupportsBoundParameters&lt; StraightLineStepper &gt;</a></td></tr>
<tr class="memitem:SupportsBoundParameters_3C_20SympyStepper_20_3E" id="r_SupportsBoundParameters_3C_20SympyStepper_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_supports_bound_parameters_3_01_sympy_stepper_01_4.html">SupportsBoundParameters&lt; SympyStepper &gt;</a></td></tr>
<tr class="memitem:Surface" id="r_Surface"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface.html">Surface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract Base Class for tracking surfaces.  <a href="class_acts_1_1_surface.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceArray" id="r_SurfaceArray"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface_array.html">SurfaceArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides Surface binning in 2 dimensions.  <a href="class_acts_1_1_surface_array.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceArrayCreator" id="r_SurfaceArrayCreator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface_array_creator.html">SurfaceArrayCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is designed create sub surface arrays to be ordered on Surfaces.  <a href="class_acts_1_1_surface_array_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceArrayNavigationPolicy" id="r_SurfaceArrayNavigationPolicy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface_array_navigation_policy.html">SurfaceArrayNavigationPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A navigation policy that internally uses the Gen1 <code>SurfaceArray</code> class.  <a href="class_acts_1_1_surface_array_navigation_policy.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceBinningMatcher" id="r_SurfaceBinningMatcher"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_surface_binning_matcher.html">SurfaceBinningMatcher</a></td></tr>
<tr class="memitem:SurfaceBounds" id="r_SurfaceBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface_bounds.html">SurfaceBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for surface bounds.  <a href="class_acts_1_1_surface_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceCollector" id="r_SurfaceCollector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_surface_collector.html">SurfaceCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Surface Collector struct templated with a Selector type.  <a href="struct_acts_1_1_surface_collector.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceHit" id="r_SurfaceHit"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_surface_hit.html">SurfaceHit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information to be writtern out per hit surface.  <a href="struct_acts_1_1_surface_hit.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceMaterialMapper" id="r_SurfaceMaterialMapper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface_material_mapper.html">SurfaceMaterialMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SurfaceMaterialMapper.  <a href="class_acts_1_1_surface_material_mapper.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceMergingException" id="r_SurfaceMergingException"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_surface_merging_exception.html">SurfaceMergingException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception type failures to merge two surfaces.  <a href="class_acts_1_1_surface_merging_exception.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceReached" id="r_SurfaceReached"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_surface_reached.html">SurfaceReached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the condition that the Surface has been reached it then triggers a propagation abort.  <a href="struct_acts_1_1_surface_reached.html#details">More...</a><br /></td></tr>
<tr class="memitem:SurfaceSelector" id="r_SurfaceSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_surface_selector.html">SurfaceSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple struct to select surfaces.  <a href="struct_acts_1_1_surface_selector.html#details">More...</a><br /></td></tr>
<tr class="memitem:SympyStepper" id="r_SympyStepper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_sympy_stepper.html">SympyStepper</a></td></tr>
<tr class="memitem:Table" id="r_Table"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_table.html">Table</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for creating formatted markdown tables with automatic column sizing and alignment.  <a href="class_acts_1_1_table.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackAtVertex" id="r_TrackAtVertex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_track_at_vertex.html">TrackAtVertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a track at vertex object.  <a href="struct_acts_1_1_track_at_vertex.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackContainer" id="r_TrackContainer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_container.html">TrackContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track container interface class.  <a href="class_acts_1_1_track_container.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackDensityVertexFinder" id="r_TrackDensityVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_density_vertex_finder.html">TrackDensityVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex seed based on the maximum of a track density function.  <a href="class_acts_1_1_track_density_vertex_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackingGeometry" id="r_TrackingGeometry"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_tracking_geometry.html">TrackingGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TrackingGeometry class is the owner of the constructed TrackingVolumes.  <a href="class_acts_1_1_tracking_geometry.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackingGeometryBuilder" id="r_TrackingGeometryBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_tracking_geometry_builder.html">TrackingGeometryBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Acts::TrackingGeometry Builder for volumes that wrap around another.  <a href="class_acts_1_1_tracking_geometry_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackingGeometryMutableVisitor" id="r_TrackingGeometryMutableVisitor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_tracking_geometry_mutable_visitor.html">TrackingGeometryMutableVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable visitor interface for modifying the tracking geometry hierarchy.  <a href="class_acts_1_1_tracking_geometry_mutable_visitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackingGeometryVisitor" id="r_TrackingGeometryVisitor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_tracking_geometry_visitor.html">TrackingGeometryVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor interface for traversing the tracking geometry hierarchy.  <a href="class_acts_1_1_tracking_geometry_visitor.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackingVolume" id="r_TrackingVolume"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full Volume description used in Tracking, it inherits from Volume to get the geometrical structure.  <a href="class_acts_1_1_tracking_volume.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackingVolumeArrayCreator" id="r_TrackingVolumeArrayCreator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_tracking_volume_array_creator.html">TrackingVolumeArrayCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TrackingVolumeArrayCreator is a simple Tool that helps to construct binned arrays of TrackingVolumes for both, confinement in another volume and navigation issues.  <a href="class_acts_1_1_tracking_volume_array_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackParamsLookupAccumulator" id="r_TrackParamsLookupAccumulator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_params_lookup_accumulator.html">TrackParamsLookupAccumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate and average track lookup tables.  <a href="class_acts_1_1_track_params_lookup_accumulator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackProxy" id="r_TrackProxy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_proxy.html">TrackProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class representing a single track.  <a href="class_acts_1_1_track_proxy.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackProxyCommon" id="r_TrackProxyCommon"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_proxy_common.html">TrackProxyCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common CRTP implementation shared by the various track proxy front-ends.  <a href="class_acts_1_1_track_proxy_common.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackSelector" id="r_TrackSelector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_selector.html">TrackSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which performs filtering of tracks.  <a href="class_acts_1_1_track_selector.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackStateCreator" id="r_TrackStateCreator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_track_state_creator.html">TrackStateCreator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create track states for selected measurements associated to a surface.  <a href="struct_acts_1_1_track_state_creator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackStateProxy" id="r_TrackStateProxy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy.html">TrackStateProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy object to access a single point on the trajectory.  <a href="class_acts_1_1_track_state_proxy.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackStateProxyCommon" id="r_TrackStateProxyCommon"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html">TrackStateProxyCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common CRTP implementation shared by track state proxy front-ends.  <a href="class_acts_1_1_track_state_proxy_common.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrackStateTraits" id="r_TrackStateTraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a></td></tr>
<tr class="memitem:TrackStateType" id="r_TrackStateType"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_type.html">TrackStateType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View type over a bitset stored in a 64 bit integer This view allows modifications.  <a href="class_acts_1_1_track_state_type.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrapezoidBounds" id="r_TrapezoidBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_trapezoid_bounds.html">TrapezoidBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds for a trapezoidal, planar Surface.  <a href="class_acts_1_1_trapezoid_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrapezoidPortalShell" id="r_TrapezoidPortalShell"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_trapezoid_portal_shell.html">TrapezoidPortalShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for trapezoid shaped portal shells, e.g.  <a href="class_acts_1_1_trapezoid_portal_shell.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrapezoidVolumeBounds" id="r_TrapezoidVolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_trapezoid_volume_bounds.html">TrapezoidVolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounds for a trapezoidal shaped Volume, the orientedSurface(...) method creates a vector of 6 surfaces:  <a href="class_acts_1_1_trapezoid_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:TripletCandidate" id="r_TripletCandidate"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_triplet_candidate.html">TripletCandidate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a triplet candidate.  <a href="struct_acts_1_1_triplet_candidate.html#details">More...</a><br /></td></tr>
<tr class="memitem:TripletSeeder" id="r_TripletSeeder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_triplet_seeder.html">TripletSeeder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full triplet seeder which depends on a doublet and triplet seed finder, and a triplet seed filter.  <a href="class_acts_1_1_triplet_seeder.html#details">More...</a><br /></td></tr>
<tr class="memitem:TripletSeedFinder" id="r_TripletSeedFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_triplet_seed_finder.html">TripletSeedFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface and a collection of standard implementations for a triplet seed finder.  <a href="class_acts_1_1_triplet_seed_finder.html#details">More...</a><br /></td></tr>
<tr class="memitem:TripletTopCandidates" id="r_TripletTopCandidates"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_triplet_top_candidates.html">TripletTopCandidates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for triplet candidates found by the triplet seed finder.  <a href="class_acts_1_1_triplet_top_candidates.html#details">More...</a><br /></td></tr>
<tr class="memitem:TrivialPortalLink" id="r_TrivialPortalLink"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_trivial_portal_link.html">TrivialPortalLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial portal link links to a single target volume on every point on a surface.  <a href="class_acts_1_1_trivial_portal_link.html#details">More...</a><br /></td></tr>
<tr class="memitem:TryAllNavigationPolicy" id="r_TryAllNavigationPolicy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_try_all_navigation_policy.html">TryAllNavigationPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy which adds <b>all</b> candidates of the configured type to the stream.  <a href="class_acts_1_1_try_all_navigation_policy.html#details">More...</a><br /></td></tr>
<tr class="memitem:TryAllNavigator" id="r_TryAllNavigator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_try_all_navigator.html">TryAllNavigator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative <code>Navigator</code> which tries all possible intersections.  <a href="class_acts_1_1_try_all_navigator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TryAllNavigatorBase" id="r_TryAllNavigatorBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_try_all_navigator_base.html">TryAllNavigatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures the common functionality of the try-all navigators.  <a href="class_acts_1_1_try_all_navigator_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:TryAllOverstepNavigator" id="r_TryAllOverstepNavigator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_try_all_overstep_navigator.html">TryAllOverstepNavigator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative <code>Navigator</code> which tries all possible intersections.  <a href="class_acts_1_1_try_all_overstep_navigator.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeDispatcher" id="r_TypeDispatcher"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_type_dispatcher.html">TypeDispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for type-based function dispatch.  <a href="class_acts_1_1_type_dispatcher.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeDispatcher_3C_20base_5Ft_2C_20return_5Ft_28args_5Ft_2E_2E_2E_29_3E" id="r_TypeDispatcher_3C_20base_5Ft_2C_20return_5Ft_28args_5Ft_2E_2E_2E_29_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_type_dispatcher_3_01base__t_00_01return__t_07args__t_8_8_8_08_4.html">TypeDispatcher&lt; base_t, return_t(args_t...)&gt;</a></td></tr>
<tr class="memitem:TypeList" id="r_TypeList"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_type_list.html">TypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">type list implementation  <a href="struct_acts_1_1_type_list.html#details">More...</a><br /></td></tr>
<tr class="memitem:TypeTag" id="r_TypeTag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a></td></tr>
<tr class="memitem:VariableSubspaceHelper" id="r_VariableSubspaceHelper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_variable_subspace_helper.html">VariableSubspaceHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for variable subspace operations.  <a href="class_acts_1_1_variable_subspace_helper.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorMultiTrajectory" id="r_VectorMultiTrajectory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_vector_multi_trajectory.html">VectorMultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-memory transient multi-trajectory implementation using <code>std::vector</code> as backend.  <a href="class_acts_1_1_vector_multi_trajectory.html#details">More...</a><br /></td></tr>
<tr class="memitem:VectorTrackContainer" id="r_VectorTrackContainer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_vector_track_container.html">VectorTrackContainer</a></td></tr>
<tr class="memitem:Vertex" id="r_Vertex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_vertex.html">Vertex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for storing vertex objects.  <a href="class_acts_1_1_vertex.html#details">More...</a><br /></td></tr>
<tr class="memitem:VertexInfo" id="r_VertexInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_vertex_info.html">VertexInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct for storing vertex related information.  <a href="struct_acts_1_1_vertex_info.html#details">More...</a><br /></td></tr>
<tr class="memitem:VertexingOptions" id="r_VertexingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_vertexing_options.html">VertexingOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vertex Finder Options.  <a href="struct_acts_1_1_vertexing_options.html#details">More...</a><br /></td></tr>
<tr class="memitem:ViewConfig" id="r_ViewConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to concentrate all visualization configurations in order to harmonize visualization interfaces.  <a href="struct_acts_1_1_view_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:VoidNavigator" id="r_VoidNavigator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_void_navigator.html">VoidNavigator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A navigator that does nothing.  <a href="class_acts_1_1_void_navigator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Volume" id="r_Volume"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_volume.html">Volume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It inherits from GeometryObject for geometry identification.  <a href="class_acts_1_1_volume.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeBounds" id="r_VolumeBounds"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure Absract Base Class for Volume bounds.  <a href="class_acts_1_1_volume_bounds.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeCollector" id="r_VolumeCollector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_volume_collector.html">VolumeCollector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Volume Collector struct templated with a Selector type.  <a href="struct_acts_1_1_volume_collector.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeConfig" id="r_VolumeConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_volume_config.html">VolumeConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeConfig struct to understand the layer config.  <a href="struct_acts_1_1_volume_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeConstraintAborter" id="r_VolumeConstraintAborter"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_volume_constraint_aborter.html">VolumeConstraintAborter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the condition that the end of world has been reached it then triggers a propagation abort.  <a href="struct_acts_1_1_volume_constraint_aborter.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeHit" id="r_VolumeHit"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_volume_hit.html">VolumeHit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The information to be writtern out per hit volume.  <a href="struct_acts_1_1_volume_hit.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeMaterialMapper" id="r_VolumeMaterialMapper"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_volume_material_mapper.html">VolumeMaterialMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VolumeMaterialMapper.  <a href="class_acts_1_1_volume_material_mapper.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeSelector" id="r_VolumeSelector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_volume_selector.html">VolumeSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple struct to select volumes.  <a href="struct_acts_1_1_volume_selector.html#details">More...</a><br /></td></tr>
<tr class="memitem:VolumeStack" id="r_VolumeStack"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_volume_stack.html">VolumeStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack of volumes.  <a href="class_acts_1_1_volume_stack.html#details">More...</a><br /></td></tr>
<tr class="memitem:WrappingConfig" id="r_WrappingConfig"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_wrapping_config.html">WrappingConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The WrappingSetup that is happening here.  <a href="struct_acts_1_1_wrapping_config.html#details">More...</a><br /></td></tr>
<tr class="memitem:ZScanVertexFinder" id="r_ZScanVertexFinder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_z_scan_vertex_finder.html">ZScanVertexFinder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a vertex finder based on the mode of z0 values:  <a href="class_acts_1_1_z_scan_vertex_finder.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-concepts" class="groupheader"><a id="concepts" name="concepts"></a>
Concepts</h2></td></tr>
<tr class="memitem:Actor" id="r_Actor"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor.html">Actor</a></td></tr>
<tr class="memitem:ActorHasAbort" id="r_ActorHasAbort"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_abort.html">ActorHasAbort</a></td></tr>
<tr class="memitem:ActorHasAbortWithoutResult" id="r_ActorHasAbortWithoutResult"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_abort_without_result.html">ActorHasAbortWithoutResult</a></td></tr>
<tr class="memitem:ActorHasAbortWithResult" id="r_ActorHasAbortWithResult"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_abort_with_result.html">ActorHasAbortWithResult</a></td></tr>
<tr class="memitem:ActorHasAct" id="r_ActorHasAct"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_act.html">ActorHasAct</a></td></tr>
<tr class="memitem:ActorHasActWithoutResult" id="r_ActorHasActWithoutResult"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_act_without_result.html">ActorHasActWithoutResult</a></td></tr>
<tr class="memitem:ActorHasActWithResult" id="r_ActorHasActWithResult"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_act_with_result.html">ActorHasActWithResult</a></td></tr>
<tr class="memitem:ActorHasOldVoidInterface" id="r_ActorHasOldVoidInterface"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_old_void_interface.html">ActorHasOldVoidInterface</a></td></tr>
<tr class="memitem:ActorHasResult" id="r_ActorHasResult"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_actor_has_result.html">ActorHasResult</a></td></tr>
<tr class="memitem:AmbiguityNetworkConcept" id="r_AmbiguityNetworkConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_ambiguity_network_concept.html">AmbiguityNetworkConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for the ambiguity network used in the ambiguity resolution. <br /></td></tr>
<tr class="memitem:AxisConcept" id="r_AxisConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_axis_concept.html">AxisConcept</a></td></tr>
<tr class="memitem:BoundTrackParametersConcept" id="r_BoundTrackParametersConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_bound_track_parameters_concept.html">BoundTrackParametersConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that asserts that a given type meets the requirements to be considered bound track parameters in Acts. <br /></td></tr>
<tr class="memitem:ChargeConcept" id="r_ChargeConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_charge_concept.html">ChargeConcept</a></td></tr>
<tr class="memitem:CollectionStoresSeedsTo" id="r_CollectionStoresSeedsTo"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_collection_stores_seeds_to.html">CollectionStoresSeedsTo</a></td></tr>
<tr class="memitem:CommonMultiTrajectoryBackend" id="r_CommonMultiTrajectoryBackend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_common_multi_trajectory_backend.html">CommonMultiTrajectoryBackend</a></td></tr>
<tr class="memitem:ConstMultiTrajectoryBackend" id="r_ConstMultiTrajectoryBackend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_const_multi_trajectory_backend.html">ConstMultiTrajectoryBackend</a></td></tr>
<tr class="memitem:ConstTrackContainerBackend" id="r_ConstTrackContainerBackend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_const_track_container_backend.html">ConstTrackContainerBackend</a></td></tr>
<tr class="memitem:ConstTrackProxyConcept" id="r_ConstTrackProxyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_const_track_proxy_concept.html">ConstTrackProxyConcept</a></td></tr>
<tr class="memitem:ConstTrackStateProxyConcept" id="r_ConstTrackStateProxyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_const_track_state_proxy_concept.html">ConstTrackStateProxyConcept</a></td></tr>
<tr class="memitem:FreeTrackParametersConcept" id="r_FreeTrackParametersConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_free_track_parameters_concept.html">FreeTrackParametersConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that asserts that a given type meets the requirements to be considered free track parameters in Acts. <br /></td></tr>
<tr class="memitem:GridBinCollection" id="r_GridBinCollection"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_grid_bin_collection.html">GridBinCollection</a></td></tr>
<tr class="memitem:hasPrintOperator" id="r_hasPrintOperator"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1has_print_operator.html">hasPrintOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a generic concept whether an object can be piped to an ostream / cout. <br /></td></tr>
<tr class="memitem:isValidConvexPolygonSize" id="r_isValidConvexPolygonSize"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1is_valid_convex_polygon_size.html">isValidConvexPolygonSize</a></td></tr>
<tr class="memitem:MutableMultiTrajectoryBackend" id="r_MutableMultiTrajectoryBackend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_mutable_multi_trajectory_backend.html">MutableMultiTrajectoryBackend</a></td></tr>
<tr class="memitem:MutableSurfaceVisitor" id="r_MutableSurfaceVisitor"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_mutable_surface_visitor.html">MutableSurfaceVisitor</a></td></tr>
<tr class="memitem:MutableTrackContainerBackend" id="r_MutableTrackContainerBackend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_mutable_track_container_backend.html">MutableTrackContainerBackend</a></td></tr>
<tr class="memitem:MutableTrackProxyConcept" id="r_MutableTrackProxyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_mutable_track_proxy_concept.html">MutableTrackProxyConcept</a></td></tr>
<tr class="memitem:MutableTrackStateProxyConcept" id="r_MutableTrackStateProxyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_mutable_track_state_proxy_concept.html">MutableTrackStateProxyConcept</a></td></tr>
<tr class="memitem:NavigationPolicyConcept" id="r_NavigationPolicyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_navigation_policy_concept.html">NavigationPolicyConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept for a navigation policy This exists so <span class="tt">updateState</span> can be a non-virtual method and we still have a way to enforce it exists. <br /></td></tr>
<tr class="memitem:PointerConcept" id="r_PointerConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_pointer_concept.html">PointerConcept</a></td></tr>
<tr class="memitem:RegularSurfaceConcept" id="r_RegularSurfaceConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_regular_surface_concept.html">RegularSurfaceConcept</a></td></tr>
<tr class="memitem:SatisfyCandidateConcept" id="r_SatisfyCandidateConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_satisfy_candidate_concept.html">SatisfyCandidateConcept</a></td></tr>
<tr class="memitem:SmartPointerConcept" id="r_SmartPointerConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_smart_pointer_concept.html">SmartPointerConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Pointer concept is an extension of the usual std::is_pointer_v type trait to also include the smart pointers like std::shared_ptr&lt;T&gt;, std::unique_ptr&lt;T&gt; The smart pointer is required to have an element_type typedef indicating over which data type the pointer is constructed, the arrow operator. <br /></td></tr>
<tr class="memitem:StepperConcept" id="r_StepperConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_stepper_concept.html">StepperConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is satisfied by steppers. <br /></td></tr>
<tr class="memitem:StepperStateConcept" id="r_StepperStateConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_stepper_state_concept.html">StepperStateConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that is satisfied by stepper states. <br /></td></tr>
<tr class="memitem:SurfaceConcept" id="r_SurfaceConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_surface_concept.html">SurfaceConcept</a></td></tr>
<tr class="memitem:SurfaceVisitor" id="r_SurfaceVisitor"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_surface_visitor.html">SurfaceVisitor</a></td></tr>
<tr class="memitem:TrackContainerBackend" id="r_TrackContainerBackend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_track_container_backend.html">TrackContainerBackend</a></td></tr>
<tr class="memitem:TrackContainerFrontend" id="r_TrackContainerFrontend"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_track_container_frontend.html">TrackContainerFrontend</a></td></tr>
<tr class="memitem:TrackingVolumeVisitor" id="r_TrackingVolumeVisitor"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_tracking_volume_visitor.html">TrackingVolumeVisitor</a></td></tr>
<tr class="memitem:TrackProxyConcept" id="r_TrackProxyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_track_proxy_concept.html">TrackProxyConcept</a></td></tr>
<tr class="memitem:TrackStateProxyConcept" id="r_TrackStateProxyConcept"><td class="memItemLeft" align="right" valign="top">concept &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="concept_acts_1_1_track_state_proxy_concept.html">TrackStateProxyConcept</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf15191675bb2966bbd872040097b1bdd" id="r_gaf15191675bb2966bbd872040097b1bdd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gaf15191675bb2966bbd872040097b1bdd">ActsDynamicMatrix</a> = Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt;</td></tr>
<tr class="memdesc:gaf15191675bb2966bbd872040097b1bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic-sized matrix type.  <br /></td></tr>
<tr class="memitem:ga18de0b258c3f7da012a164e8a4cdb75c" id="r_ga18de0b258c3f7da012a164e8a4cdb75c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga18de0b258c3f7da012a164e8a4cdb75c">ActsDynamicVector</a> = Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;</td></tr>
<tr class="memdesc:ga18de0b258c3f7da012a164e8a4cdb75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic-sized vector type.  <br /></td></tr>
<tr class="memitem:ga99cd1a5ee6b7c5cf8a3aca54526ab67d" id="r_ga99cd1a5ee6b7c5cf8a3aca54526ab67d"><td class="memTemplParams" colspan="2">template&lt;unsigned int kRows, unsigned int kCols&gt; </td></tr>
<tr class="memitem:ga99cd1a5ee6b7c5cf8a3aca54526ab67d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a> = Eigen::Matrix&lt;double, kRows, kCols&gt;</td></tr>
<tr class="memdesc:ga99cd1a5ee6b7c5cf8a3aca54526ab67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size matrix type for NxM matrices.  <br /></td></tr>
<tr class="memitem:gacb25019f1218b9a96b29f897dfc5be7f" id="r_gacb25019f1218b9a96b29f897dfc5be7f"><td class="memTemplParams" colspan="2">template&lt;unsigned int kSize&gt; </td></tr>
<tr class="memitem:gacb25019f1218b9a96b29f897dfc5be7f template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a> = Eigen::Matrix&lt;double, kSize, kSize&gt;</td></tr>
<tr class="memdesc:gacb25019f1218b9a96b29f897dfc5be7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size square matrix type for NxN matrices.  <br /></td></tr>
<tr class="memitem:ga3656dcbf643d97f9dbd715aa9e06bf84" id="r_ga3656dcbf643d97f9dbd715aa9e06bf84"><td class="memTemplParams" colspan="2">template&lt;unsigned int kSize&gt; </td></tr>
<tr class="memitem:ga3656dcbf643d97f9dbd715aa9e06bf84 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a> = Eigen::Matrix&lt;double, kSize, 1&gt;</td></tr>
<tr class="memdesc:ga3656dcbf643d97f9dbd715aa9e06bf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed-size vector type for N-dimensional vectors.  <br /></td></tr>
<tr class="memitem:ad74665d2c9210b7b7c61b07a4b1d7882" id="r_ad74665d2c9210b7b7c61b07a4b1d7882"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad74665d2c9210b7b7c61b07a4b1d7882">AlignmentMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td></tr>
<tr class="memdesc:ad74665d2c9210b7b7c61b07a4b1d7882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square matrix type for alignment parameters.  <br /></td></tr>
<tr class="memitem:aa018f2e119b454c3cb4a886ee1738287" id="r_aa018f2e119b454c3cb4a886ee1738287"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa018f2e119b454c3cb4a886ee1738287">AlignmentRowVector</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;1, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td></tr>
<tr class="memdesc:aa018f2e119b454c3cb4a886ee1738287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row vector type for alignment parameters.  <br /></td></tr>
<tr class="memitem:afb10c5cb981e8a26821fd8afafc6d10f" id="r_afb10c5cb981e8a26821fd8afafc6d10f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb10c5cb981e8a26821fd8afafc6d10f">AlignmentToBoundMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td></tr>
<tr class="memdesc:afb10c5cb981e8a26821fd8afafc6d10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for transforming alignment parameters to bound parameters.  <br /></td></tr>
<tr class="memitem:ab42a56895184458a0c2b4de6f112469b" id="r_ab42a56895184458a0c2b4de6f112469b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab42a56895184458a0c2b4de6f112469b">AlignmentToPathMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;1, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td></tr>
<tr class="memdesc:ab42a56895184458a0c2b4de6f112469b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for transforming alignment parameters to path length.  <br /></td></tr>
<tr class="memitem:a53ac0eeb93f715e2cd742e45bbc6a706" id="r_a53ac0eeb93f715e2cd742e45bbc6a706"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ac0eeb93f715e2cd742e45bbc6a706">AlignmentToPositionMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;3, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td></tr>
<tr class="memdesc:a53ac0eeb93f715e2cd742e45bbc6a706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for transforming alignment parameters to position.  <br /></td></tr>
<tr class="memitem:afbb99f20f52947bab5a7b54c80510bad" id="r_afbb99f20f52947bab5a7b54c80510bad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb99f20f52947bab5a7b54c80510bad">AlignmentVector</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;<a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td></tr>
<tr class="memdesc:afbb99f20f52947bab5a7b54c80510bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for alignment parameters.  <br /></td></tr>
<tr class="memitem:gad51b61e2bb0e1f7a1a6216925133f0e2" id="r_gad51b61e2bb0e1f7a1a6216925133f0e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gad51b61e2bb0e1f7a1a6216925133f0e2">AngleAxis3</a> = Eigen::AngleAxis&lt;double&gt;</td></tr>
<tr class="memdesc:gad51b61e2bb0e1f7a1a6216925133f0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation defined by an angle around a rotation axis in 3D.  <br /></td></tr>
<tr class="memitem:gae6e6d5aeac9e4cb922c12f41d1f5529e" id="r_gae6e6d5aeac9e4cb922c12f41d1f5529e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae6e6d5aeac9e4cb922c12f41d1f5529e">Any</a> = <a class="el" href="class_acts_1_1_any_base.html">AnyBase</a>&lt;sizeof(void*)&gt;</td></tr>
<tr class="memdesc:gae6e6d5aeac9e4cb922c12f41d1f5529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type-safe container for single values of any type.  <br /></td></tr>
<tr class="memitem:a2db5437c93715c880d91e795ea966d15" id="r_a2db5437c93715c880d91e795ea966d15"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2db5437c93715c880d91e795ea966d15">AnyConstTrackProxy</a> = <a class="el" href="class_acts_1_1_any_track_proxy.html">AnyTrackProxy</a>&lt;true&gt;</td></tr>
<tr class="memdesc:a2db5437c93715c880d91e795ea966d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for read-only type-erased track.  <br /></td></tr>
<tr class="memitem:a58d7c5f9e29f5f51ece398952f4a2a6a" id="r_a58d7c5f9e29f5f51ece398952f4a2a6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58d7c5f9e29f5f51ece398952f4a2a6a">AnyConstTrackStateProxy</a> = <a class="el" href="class_acts_1_1_any_track_state_proxy.html">AnyTrackStateProxy</a>&lt;true&gt;</td></tr>
<tr class="memitem:a8d88b3de1937df196eae6628781ac437" id="r_a8d88b3de1937df196eae6628781ac437"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d88b3de1937df196eae6628781ac437">AnyMutableTrackProxy</a> = <a class="el" href="class_acts_1_1_any_track_proxy.html">AnyTrackProxy</a>&lt;false&gt;</td></tr>
<tr class="memdesc:a8d88b3de1937df196eae6628781ac437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for mutable type-erased track (though currently all operations are const).  <br /></td></tr>
<tr class="memitem:af82438c3ab8cfa7c43a00e2a821fa1bb" id="r_af82438c3ab8cfa7c43a00e2a821fa1bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af82438c3ab8cfa7c43a00e2a821fa1bb">AnyMutableTrackStateProxy</a> = <a class="el" href="class_acts_1_1_any_track_state_proxy.html">AnyTrackStateProxy</a>&lt;false&gt;</td></tr>
<tr class="memitem:af1f471897e11492ff0b12b6ff089225d" id="r_af1f471897e11492ff0b12b6ff089225d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1f471897e11492ff0b12b6ff089225d">AxisScalar</a> = Vector3::Scalar</td></tr>
<tr class="memdesc:af1f471897e11492ff0b12b6ff089225d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type used for axis values in surface array binning.  <br /></td></tr>
<tr class="memitem:a109a2348a2960bbf7f66f07d2da7dd8b" id="r_a109a2348a2960bbf7f66f07d2da7dd8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a109a2348a2960bbf7f66f07d2da7dd8b">BoundarySurface</a> = <a class="el" href="class_acts_1_1_boundary_surface_t.html">BoundarySurfaceT</a>&lt;<a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>&gt;</td></tr>
<tr class="memitem:a40a2ff0a11454e7af0dc0a4bcab7b1b0" id="r_a40a2ff0a11454e7af0dc0a4bcab7b1b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">BoundMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td></tr>
<tr class="memdesc:a40a2ff0a11454e7af0dc0a4bcab7b1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for bound track parameter transformations.  <br /></td></tr>
<tr class="memitem:a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0" id="r_a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0">BoundSquareMatrix</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td></tr>
<tr class="memdesc:a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square matrix type for bound track parameter covariance.  <br /></td></tr>
<tr class="memitem:a1b6c456f1650d94a2549251f1306dde4" id="r_a1b6c456f1650d94a2549251f1306dde4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a> = <a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td></tr>
<tr class="memdesc:a1b6c456f1650d94a2549251f1306dde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for bound parameter subspace indices.  <br /></td></tr>
<tr class="memitem:a528016d34d6df141f5cb73973d6edca0" id="r_a528016d34d6df141f5cb73973d6edca0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a528016d34d6df141f5cb73973d6edca0">BoundToFreeMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td></tr>
<tr class="memdesc:a528016d34d6df141f5cb73973d6edca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for mapping from bound to free track parameters.  <br /></td></tr>
<tr class="memitem:ad836aba005ba272c0a77227311e4a0ce" id="r_ad836aba005ba272c0a77227311e4a0ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a> = <a class="el" href="class_acts_1_1_generic_bound_track_parameters.html">GenericBoundTrackParameters</a>&lt;<a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a>&gt;</td></tr>
<tr class="memdesc:ad836aba005ba272c0a77227311e4a0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">BoundTrackParameters can hold any kind of charge.  <br /></td></tr>
<tr class="memitem:af2571f8c8ebccb37165c668fab4a1c4f" id="r_af2571f8c8ebccb37165c668fab4a1c4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td></tr>
<tr class="memdesc:af2571f8c8ebccb37165c668fab4a1c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for bound track parameters.  <br /></td></tr>
<tr class="memitem:gad038e458629a5cedf1f825940ffc5f76" id="r_gad038e458629a5cedf1f825940ffc5f76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gad038e458629a5cedf1f825940ffc5f76">ConfigPair</a></td></tr>
<tr class="memdesc:gad038e458629a5cedf1f825940ffc5f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a pair of detector configuration and ambiguity resolution configuration.  <br /></td></tr>
<tr class="memitem:abe4f9e4a5e3fd2a023039cbfec3ef858" id="r_abe4f9e4a5e3fd2a023039cbfec3ef858"><td class="memTemplParams" colspan="2">template&lt;bool C, typename T&gt; </td></tr>
<tr class="memitem:abe4f9e4a5e3fd2a023039cbfec3ef858 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe4f9e4a5e3fd2a023039cbfec3ef858">const_if_t</a> = std::conditional_t&lt;C, const T, T&gt;</td></tr>
<tr class="memdesc:abe4f9e4a5e3fd2a023039cbfec3ef858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that adds const qualifier to a type based on a boolean condition.  <br /></td></tr>
<tr class="memitem:a0471a5f2ee8a52d07049c3c014a76613" id="r_a0471a5f2ee8a52d07049c3c014a76613"><td class="memTemplParams" colspan="2">template&lt;PointerConcept T&gt; </td></tr>
<tr class="memitem:a0471a5f2ee8a52d07049c3c014a76613 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0471a5f2ee8a52d07049c3c014a76613">ConstDeRef_t</a> = std::add_const_t&lt;<a class="el" href="#af5dcde8c0f77a3ed6c7887d0c7e1a26d">RemovePointer_t</a>&lt;T&gt;&gt;&amp;</td></tr>
<tr class="memdesc:a0471a5f2ee8a52d07049c3c014a76613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a const pointer dereference.  <br /></td></tr>
<tr class="memitem:ae0e74469e9117c4b3731cf556cbf832a" id="r_ae0e74469e9117c4b3731cf556cbf832a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae0e74469e9117c4b3731cf556cbf832a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0e74469e9117c4b3731cf556cbf832a">ConstProxyAccessor</a> = <a class="el" href="struct_acts_1_1_proxy_accessor_base.html">ProxyAccessorBase</a>&lt;T, true&gt;</td></tr>
<tr class="memdesc:ae0e74469e9117c4b3731cf556cbf832a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a const proxy accessor.  <br /></td></tr>
<tr class="memitem:a7527bffb3304dc54973337127dcb0c1a" id="r_a7527bffb3304dc54973337127dcb0c1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7527bffb3304dc54973337127dcb0c1a">ConstSeedProxy2</a> = <a class="el" href="class_acts_1_1_seed_proxy2.html">SeedProxy2</a>&lt;true&gt;</td></tr>
<tr class="memitem:a5252cf9e661478d7ff7731b37a60cc4c" id="r_a5252cf9e661478d7ff7731b37a60cc4c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a5252cf9e661478d7ff7731b37a60cc4c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5252cf9e661478d7ff7731b37a60cc4c">ConstSpacePointColumnProxy</a> = <a class="el" href="class_acts_1_1_space_point_column_proxy.html">SpacePointColumnProxy</a>&lt;T, true&gt;</td></tr>
<tr class="memitem:acd104d9fd9886e714af3bf67c53e508f" id="r_acd104d9fd9886e714af3bf67c53e508f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd104d9fd9886e714af3bf67c53e508f">ConstSpacePointProxy2</a> = <a class="el" href="class_acts_1_1_space_point_proxy2.html">SpacePointProxy2</a>&lt;true&gt;</td></tr>
<tr class="memitem:ga9d088dc485a7212cbc281898214d46a1" id="r_ga9d088dc485a7212cbc281898214d46a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga9d088dc485a7212cbc281898214d46a1">DetectorConfig</a> = <a class="el" href="struct_acts_1_1_score_based_ambiguity_resolution_1_1_detector_config.html">ScoreBasedAmbiguityResolution::DetectorConfig</a></td></tr>
<tr class="memdesc:ga9d088dc485a7212cbc281898214d46a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for detector-specific ambiguity resolution configuration.  <br /></td></tr>
<tr class="memitem:a5d7e85d7c82a496bd6ae9f7560355973" id="r_a5d7e85d7c82a496bd6ae9f7560355973"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a> = <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt;<a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a>&gt;</td></tr>
<tr class="memdesc:a5d7e85d7c82a496bd6ae9f7560355973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for equidistant axis with open boundary type.  <br /></td></tr>
<tr class="memitem:aa009e51d59c1a881d343ba0f9fcacbbc" id="r_aa009e51d59c1a881d343ba0f9fcacbbc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa009e51d59c1a881d343ba0f9fcacbbc">Envelope</a> = std::array&lt;double, 2&gt;</td></tr>
<tr class="memdesc:aa009e51d59c1a881d343ba0f9fcacbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for envelope values in different directions.  <br /></td></tr>
<tr class="memitem:a9bc2353f4da72bb7afd4d868e278150c" id="r_a9bc2353f4da72bb7afd4d868e278150c"><td class="memTemplParams" colspan="2">template&lt;std::size_t SubspaceSize&gt; </td></tr>
<tr class="memitem:a9bc2353f4da72bb7afd4d868e278150c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bc2353f4da72bb7afd4d868e278150c">FixedBoundSubspaceHelper</a></td></tr>
<tr class="memdesc:a9bc2353f4da72bb7afd4d868e278150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for fixed-size bound parameter subspaces.  <br /></td></tr>
<tr class="memitem:acdde648ddc34cb68123733bebd224cb7" id="r_acdde648ddc34cb68123733bebd224cb7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdde648ddc34cb68123733bebd224cb7">FreeMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td></tr>
<tr class="memdesc:acdde648ddc34cb68123733bebd224cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for free track parameter transformations.  <br /></td></tr>
<tr class="memitem:a26b50b2b1278f282f32aa57b8ba98642" id="r_a26b50b2b1278f282f32aa57b8ba98642"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b50b2b1278f282f32aa57b8ba98642">FreeSquareMatrix</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td></tr>
<tr class="memdesc:a26b50b2b1278f282f32aa57b8ba98642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square matrix type for free track parameter covariance.  <br /></td></tr>
<tr class="memitem:a8d9bd328a23a650ba4dbe1b1bedcb276" id="r_a8d9bd328a23a650ba4dbe1b1bedcb276"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d9bd328a23a650ba4dbe1b1bedcb276">FreeToBoundMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td></tr>
<tr class="memdesc:a8d9bd328a23a650ba4dbe1b1bedcb276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for mapping from free to bound track parameters.  <br /></td></tr>
<tr class="memitem:a9fba2b6f3c302ad14749697283c510bd" id="r_a9fba2b6f3c302ad14749697283c510bd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fba2b6f3c302ad14749697283c510bd">FreeToPathMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;1, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td></tr>
<tr class="memdesc:a9fba2b6f3c302ad14749697283c510bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix type for mapping from free parameters to path length.  <br /></td></tr>
<tr class="memitem:a571167e3129b91100b194e36a1277f8d" id="r_a571167e3129b91100b194e36a1277f8d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a571167e3129b91100b194e36a1277f8d">FreeTrackParameters</a> = <a class="el" href="class_acts_1_1_generic_free_track_parameters.html">GenericFreeTrackParameters</a>&lt;<a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a>&gt;</td></tr>
<tr class="memdesc:a571167e3129b91100b194e36a1277f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FreeTrackParameters can hold any kind of charge.  <br /></td></tr>
<tr class="memitem:a34a846c2589150628ba6e05624221307" id="r_a34a846c2589150628ba6e05624221307"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td></tr>
<tr class="memdesc:a34a846c2589150628ba6e05624221307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector type for free track parameters.  <br /></td></tr>
<tr class="memitem:gac15aff2ad0a7029a89bd903885de3310" id="r_gac15aff2ad0a7029a89bd903885de3310"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:gac15aff2ad0a7029a89bd903885de3310 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#gac15aff2ad0a7029a89bd903885de3310">GloballyIndexedSurfaceMaterial</a></td></tr>
<tr class="memdesc:gac15aff2ad0a7029a89bd903885de3310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for surface material indexed by global coordinates.  <br /></td></tr>
<tr class="memitem:ab0989576baab7a8793e3f7cbeec08cae" id="r_ab0989576baab7a8793e3f7cbeec08cae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a> = <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt;<a class="el" href="class_acts_1_1_accumulated_volume_material.html">Acts::AccumulatedVolumeMaterial</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>&gt;</td></tr>
<tr class="memdesc:ab0989576baab7a8793e3f7cbeec08cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 2-dimensional grid.  <br /></td></tr>
<tr class="memitem:a9449d6ac28ec406ddfcf71fd50003e59" id="r_a9449d6ac28ec406ddfcf71fd50003e59"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a> = <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt;<a class="el" href="class_acts_1_1_accumulated_volume_material.html">Acts::AccumulatedVolumeMaterial</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>&gt;</td></tr>
<tr class="memdesc:a9449d6ac28ec406ddfcf71fd50003e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 3-dimensional grid.  <br /></td></tr>
<tr class="memitem:ga7f7ecaeb7a0b9e040e5de04892a1e1eb" id="r_ga7f7ecaeb7a0b9e040e5de04892a1e1eb"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:ga7f7ecaeb7a0b9e040e5de04892a1e1eb template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#ga7f7ecaeb7a0b9e040e5de04892a1e1eb">GridSurfaceMaterial</a></td></tr>
<tr class="memdesc:ga7f7ecaeb7a0b9e040e5de04892a1e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for grid-based surface material.  <br /></td></tr>
<tr class="memitem:a316aaac27fda3651c80ea8dfba83492a" id="r_a316aaac27fda3651c80ea8dfba83492a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> = std::uint32_t</td></tr>
<tr class="memdesc:a316aaac27fda3651c80ea8dfba83492a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for hashed string representation.  <br /></td></tr>
<tr class="memitem:gaad5c814e3aa3cfb77dd2dc46abc2099b" id="r_gaad5c814e3aa3cfb77dd2dc46abc2099b"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:gaad5c814e3aa3cfb77dd2dc46abc2099b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#gaad5c814e3aa3cfb77dd2dc46abc2099b">IndexedSurfaceMaterial</a></td></tr>
<tr class="memdesc:gaad5c814e3aa3cfb77dd2dc46abc2099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for surface material indexed by local coordinates.  <br /></td></tr>
<tr class="memitem:a2feee6c44d3778b3751ed293d4364986" id="r_a2feee6c44d3778b3751ed293d4364986"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2feee6c44d3778b3751ed293d4364986">Intersection2D</a> = <a class="el" href="class_acts_1_1_intersection.html">Intersection</a>&lt;2&gt;</td></tr>
<tr class="memdesc:a2feee6c44d3778b3751ed293d4364986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for 2D intersection.  <br /></td></tr>
<tr class="memitem:ac5af012605f2c07d2ccec54168574925" id="r_ac5af012605f2c07d2ccec54168574925"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5af012605f2c07d2ccec54168574925">Intersection3D</a> = <a class="el" href="class_acts_1_1_intersection.html">Intersection</a>&lt;3&gt;</td></tr>
<tr class="memdesc:ac5af012605f2c07d2ccec54168574925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for 3D intersection.  <br /></td></tr>
<tr class="memitem:af9169827ccc34e24679e5d48aa3cd8a1" id="r_af9169827ccc34e24679e5d48aa3cd8a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9169827ccc34e24679e5d48aa3cd8a1">IntersectionIndex</a> = std::uint8_t</td></tr>
<tr class="memitem:abb5a9cf5e2b49936d60e698d81fe6e0d" id="r_abb5a9cf5e2b49936d60e698d81fe6e0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a> = std::shared_ptr&lt;const <a class="el" href="class_acts_1_1_layer.html">Layer</a>&gt;</td></tr>
<tr class="memdesc:abb5a9cf5e2b49936d60e698d81fe6e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::shared_ptr to a Layer.  <br /></td></tr>
<tr class="memitem:a6bacc83149ffd31c3d1c02297b63a884" id="r_a6bacc83149ffd31c3d1c02297b63a884"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bacc83149ffd31c3d1c02297b63a884">MaterialGrid2D</a></td></tr>
<tr class="memdesc:a6bacc83149ffd31c3d1c02297b63a884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 2-dimensional material grid.  <br /></td></tr>
<tr class="memitem:ae34013557b3d2c0ee081ec4b1c408b38" id="r_ae34013557b3d2c0ee081ec4b1c408b38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae34013557b3d2c0ee081ec4b1c408b38">MaterialGrid3D</a></td></tr>
<tr class="memdesc:ae34013557b3d2c0ee081ec4b1c408b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 3-dimensional material grid.  <br /></td></tr>
<tr class="memitem:ae3b4d4995155fcbfd29d48adc9f73a0d" id="r_ae3b4d4995155fcbfd29d48adc9f73a0d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a> = std::tuple&lt;double, double, std::size_t&gt;</td></tr>
<tr class="memdesc:ae3b4d4995155fcbfd29d48adc9f73a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for the axis data in material grids.  <br /></td></tr>
<tr class="memitem:acda8cc2353ab952431bd685a4450c1dc" id="r_acda8cc2353ab952431bd685a4450c1dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acda8cc2353ab952431bd685a4450c1dc">MaterialSlabMatrix</a> = std::vector&lt;<a class="el" href="#ae02784ae49dd0d917418a3878453a4c1">MaterialSlabVector</a>&gt;</td></tr>
<tr class="memdesc:acda8cc2353ab952431bd685a4450c1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a matrix of material slabs.  <br /></td></tr>
<tr class="memitem:ae02784ae49dd0d917418a3878453a4c1" id="r_ae02784ae49dd0d917418a3878453a4c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae02784ae49dd0d917418a3878453a4c1">MaterialSlabVector</a> = std::vector&lt;<a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a>&gt;</td></tr>
<tr class="memdesc:ae02784ae49dd0d917418a3878453a4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a vector of material slabs.  <br /></td></tr>
<tr class="memitem:a4db7019218e46140392e9e7c6061081c" id="r_a4db7019218e46140392e9e7c6061081c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db7019218e46140392e9e7c6061081c">MaxMomentumReducerLoop</a></td></tr>
<tr class="memdesc:a4db7019218e46140392e9e7c6061081c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for loop reducer based on maximum momentum.  <br /></td></tr>
<tr class="memitem:a8c6ffaa75197866a88bcc862b93306e3" id="r_a8c6ffaa75197866a88bcc862b93306e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c6ffaa75197866a88bcc862b93306e3">MaxWeightReducerLoop</a></td></tr>
<tr class="memdesc:a8c6ffaa75197866a88bcc862b93306e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for loop reducer based on maximum weight.  <br /></td></tr>
<tr class="memitem:ae9408494e498cfa4e752006ca788b3f6" id="r_ae9408494e498cfa4e752006ca788b3f6"><td class="memTemplParams" colspan="2">template&lt;typename extension_t = EigenStepperDefaultExtension, typename reducer_t = MaxWeightReducerLoop&gt; </td></tr>
<tr class="memitem:ae9408494e498cfa4e752006ca788b3f6 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9408494e498cfa4e752006ca788b3f6">MultiEigenStepperLoop</a></td></tr>
<tr class="memdesc:ae9408494e498cfa4e752006ca788b3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stepper based on the EigenStepper, but handles Multi-Component Tracks (e.g., for the GSF).  <br /></td></tr>
<tr class="memitem:ae9759fe2150d6d2442c1270dbabc1976" id="r_ae9759fe2150d6d2442c1270dbabc1976"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9759fe2150d6d2442c1270dbabc1976">MultiIntersection2D</a> = <a class="el" href="class_acts_1_1_multi_intersection.html">MultiIntersection</a>&lt;2&gt;</td></tr>
<tr class="memitem:ae4e962ae4108b1150b697ebcc6132bff" id="r_ae4e962ae4108b1150b697ebcc6132bff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4e962ae4108b1150b697ebcc6132bff">MultiIntersection3D</a> = <a class="el" href="class_acts_1_1_multi_intersection.html">MultiIntersection</a>&lt;3&gt;</td></tr>
<tr class="memitem:a09af7e6b42a9e8ebf8b9ac931e7d866b" id="r_a09af7e6b42a9e8ebf8b9ac931e7d866b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09af7e6b42a9e8ebf8b9ac931e7d866b">MutableLayerPtr</a> = std::shared_ptr&lt;<a class="el" href="class_acts_1_1_layer.html">Layer</a>&gt;</td></tr>
<tr class="memdesc:a09af7e6b42a9e8ebf8b9ac931e7d866b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a mutable pointer to a layer.  <br /></td></tr>
<tr class="memitem:abcfecfc26529b706b3ba31042e4c2948" id="r_abcfecfc26529b706b3ba31042e4c2948"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcfecfc26529b706b3ba31042e4c2948">MutableSeedProxy2</a> = <a class="el" href="class_acts_1_1_seed_proxy2.html">SeedProxy2</a>&lt;false&gt;</td></tr>
<tr class="memitem:ae99c57a7ceaaba03e0f89b978851f98c" id="r_ae99c57a7ceaaba03e0f89b978851f98c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae99c57a7ceaaba03e0f89b978851f98c template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae99c57a7ceaaba03e0f89b978851f98c">MutableSpacePointColumnProxy</a> = <a class="el" href="class_acts_1_1_space_point_column_proxy.html">SpacePointColumnProxy</a>&lt;T, false&gt;</td></tr>
<tr class="memitem:aab89f1e4f2b712860bba81478a4861cd" id="r_aab89f1e4f2b712860bba81478a4861cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab89f1e4f2b712860bba81478a4861cd">MutableSpacePointProxy2</a> = <a class="el" href="class_acts_1_1_space_point_proxy2.html">SpacePointProxy2</a>&lt;false&gt;</td></tr>
<tr class="memitem:a3c7053506015dae00ae1b4273764fb86" id="r_a3c7053506015dae00ae1b4273764fb86"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c7053506015dae00ae1b4273764fb86">NavigationDelegate</a></td></tr>
<tr class="memdesc:a3c7053506015dae00ae1b4273764fb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Central alias for the navigation delegate.  <br /></td></tr>
<tr class="memitem:a5a251193de228b8045bfae4dea56eeaa" id="r_a5a251193de228b8045bfae4dea56eeaa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a251193de228b8045bfae4dea56eeaa">NeutralBoundTrackParameters</a></td></tr>
<tr class="memdesc:a5a251193de228b8045bfae4dea56eeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for bound track parameters of neutral particles.  <br /></td></tr>
<tr class="memitem:a250e93cd47012384de7861dfa23d7706" id="r_a250e93cd47012384de7861dfa23d7706"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250e93cd47012384de7861dfa23d7706">NeutralFreeTrackParameters</a></td></tr>
<tr class="memdesc:a250e93cd47012384de7861dfa23d7706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for free track parameters of neutral particles.  <br /></td></tr>
<tr class="memitem:a474fe95e07bff5d2bd907ffb6ff3bea9" id="r_a474fe95e07bff5d2bd907ffb6ff3bea9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a474fe95e07bff5d2bd907ffb6ff3bea9">NextLayers</a> = std::pair&lt;const <a class="el" href="class_acts_1_1_layer.html">Layer</a>*, const <a class="el" href="class_acts_1_1_layer.html">Layer</a>*&gt;</td></tr>
<tr class="memdesc:a474fe95e07bff5d2bd907ffb6ff3bea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for adjacent layer pointers.  <br /></td></tr>
<tr class="memitem:a02a4498acaa3e08fdd9553867bb6fd8e" id="r_a02a4498acaa3e08fdd9553867bb6fd8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a4498acaa3e08fdd9553867bb6fd8e">ParamCovAccessor</a></td></tr>
<tr class="memdesc:a02a4498acaa3e08fdd9553867bb6fd8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for accessing parameter covariance matrices.  <br /></td></tr>
<tr class="memitem:a1e6b3622ce6e2c9fea228f7b3678e5f4" id="r_a1e6b3622ce6e2c9fea228f7b3678e5f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e6b3622ce6e2c9fea228f7b3678e5f4">ProjectorBitset</a> = std::uint64_t</td></tr>
<tr class="memdesc:a1e6b3622ce6e2c9fea228f7b3678e5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for bitset representing parameter projections.  <br /></td></tr>
<tr class="memitem:gadfa3ab1557fc9f1b6d7227d617a1ef4f" id="r_gadfa3ab1557fc9f1b6d7227d617a1ef4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#gadfa3ab1557fc9f1b6d7227d617a1ef4f">ProtoGridSurfaceMaterial</a></td></tr>
<tr class="memdesc:gadfa3ab1557fc9f1b6d7227d617a1ef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a prototype surface material using a grid of ProtoAxis A surface material implementation that uses a vector of ProtoAxis for grid-based binning.  <br /></td></tr>
<tr class="memitem:gabad517c3d330be68557175bbe3e71402" id="r_gabad517c3d330be68557175bbe3e71402"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#gabad517c3d330be68557175bbe3e71402">ProtoSurfaceMaterial</a> = <a class="el" href="class_acts_1_1_proto_surface_material_t.html">ProtoSurfaceMaterialT</a>&lt;<a class="el" href="class_acts_1_1_bin_utility.html">Acts::BinUtility</a>&gt;</td></tr>
<tr class="memdesc:gabad517c3d330be68557175bbe3e71402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a prototype surface material using BinUtility A surface material implementation that uses BinUtility for binning.  <br /></td></tr>
<tr class="memitem:a79f3daeca2329cfd19dc3baa49e667d0" id="r_a79f3daeca2329cfd19dc3baa49e667d0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a79f3daeca2329cfd19dc3baa49e667d0 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79f3daeca2329cfd19dc3baa49e667d0">ProxyAccessor</a> = <a class="el" href="struct_acts_1_1_proxy_accessor_base.html">ProxyAccessorBase</a>&lt;T, false&gt;</td></tr>
<tr class="memdesc:a79f3daeca2329cfd19dc3baa49e667d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a mutable proxy accessor.  <br /></td></tr>
<tr class="memitem:a81478db625a7b35501d5f651f5d1d4fd" id="r_a81478db625a7b35501d5f651f5d1d4fd"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </td></tr>
<tr class="memitem:a81478db625a7b35501d5f651f5d1d4fd template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81478db625a7b35501d5f651f5d1d4fd">Range1D</a> = <a class="el" href="class_acts_1_1_range_x_d.html">RangeXD</a>&lt;1, <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector&gt;</td></tr>
<tr class="memdesc:a81478db625a7b35501d5f651f5d1d4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a one-dimensional range.  <br /></td></tr>
<tr class="memitem:a0e3bc17e57fdc272a17b43714e85adeb" id="r_a0e3bc17e57fdc272a17b43714e85adeb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e3bc17e57fdc272a17b43714e85adeb">Ray3D</a> = <a class="el" href="class_acts_1_1_ray.html">Ray</a>&lt;double, 3&gt;</td></tr>
<tr class="memdesc:a0e3bc17e57fdc272a17b43714e85adeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a 3D ray using double precision.  <br /></td></tr>
<tr class="memitem:a7c52cf739300a2e3988b6fbea63e17dd" id="r_a7c52cf739300a2e3988b6fbea63e17dd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c52cf739300a2e3988b6fbea63e17dd">RecordedMaterialTrack</a></td></tr>
<tr class="memdesc:a7c52cf739300a2e3988b6fbea63e17dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">And recorded material track.  <br /></td></tr>
<tr class="memitem:a9259c24825f667858a4397ffce0e6797" id="r_a9259c24825f667858a4397ffce0e6797"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9259c24825f667858a4397ffce0e6797">RecordedMaterialVolumePoint</a></td></tr>
<tr class="memdesc:a9259c24825f667858a4397ffce0e6797"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of point used in the mapping of a volume  <br /></td></tr>
<tr class="memitem:ae062b9b7f44f677427f86667becc8413" id="r_ae062b9b7f44f677427f86667becc8413"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae062b9b7f44f677427f86667becc8413">RegularCylinderIndexGrid</a></td></tr>
<tr class="memitem:a415481fd3fcf2ac7bcaadd2a93e6a38e" id="r_a415481fd3fcf2ac7bcaadd2a93e6a38e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415481fd3fcf2ac7bcaadd2a93e6a38e">RegularCylinderIndexGridNavigationPolicy</a></td></tr>
<tr class="memitem:a6f259b0a5c51bef5b087bce8b9a70916" id="r_a6f259b0a5c51bef5b087bce8b9a70916"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f259b0a5c51bef5b087bce8b9a70916">RegularDiscIndexGrid</a></td></tr>
<tr class="memitem:a06353fb21ac789b0651913a8fcea7ace" id="r_a06353fb21ac789b0651913a8fcea7ace"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06353fb21ac789b0651913a8fcea7ace">RegularDiscIndexGridNavigationPolicy</a></td></tr>
<tr class="memitem:a7a113ba88761207bc76f0539d17f4adc" id="r_a7a113ba88761207bc76f0539d17f4adc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a113ba88761207bc76f0539d17f4adc">RegularPlaneIndexGrid</a></td></tr>
<tr class="memitem:a98163fce2f835cc18b46a3dd61b1aca2" id="r_a98163fce2f835cc18b46a3dd61b1aca2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98163fce2f835cc18b46a3dd61b1aca2">RegularPlaneIndexGridNavigationPolicy</a></td></tr>
<tr class="memitem:aaec782f86c8422aa8c7aed76547087c3" id="r_aaec782f86c8422aa8c7aed76547087c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaec782f86c8422aa8c7aed76547087c3">RegularRingIndexGrid</a></td></tr>
<tr class="memitem:a323cd9fc4d1438e08a1b2caf5ab88ebc" id="r_a323cd9fc4d1438e08a1b2caf5ab88ebc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a323cd9fc4d1438e08a1b2caf5ab88ebc">RegularRingIndexGridNavigationPolicy</a></td></tr>
<tr class="memitem:af5dcde8c0f77a3ed6c7887d0c7e1a26d" id="r_af5dcde8c0f77a3ed6c7887d0c7e1a26d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:af5dcde8c0f77a3ed6c7887d0c7e1a26d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5dcde8c0f77a3ed6c7887d0c7e1a26d">RemovePointer_t</a> = <a class="el" href="struct_acts_1_1_remove_pointer.html">RemovePointer</a>&lt;T&gt;<a class="el" href="struct_acts_1_1_remove_pointer.html">::type</a></td></tr>
<tr class="memdesc:af5dcde8c0f77a3ed6c7887d0c7e1a26d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type alias for removing pointer from type.  <br /></td></tr>
<tr class="memitem:ga2b55eb1db420c7fb941dd1fe03065fba" id="r_ga2b55eb1db420c7fb941dd1fe03065fba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga2b55eb1db420c7fb941dd1fe03065fba">RotationMatrix2</a> = <a class="el" href="group__algebra__types.html#ga57a9cb002daaf227c693f2992fa5540c">SquareMatrix2</a></td></tr>
<tr class="memdesc:ga2b55eb1db420c7fb941dd1fe03065fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D rotation matrix  <br /></td></tr>
<tr class="memitem:ga04f891882a45afadbe07df33ad1c181c" id="r_ga04f891882a45afadbe07df33ad1c181c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga04f891882a45afadbe07df33ad1c181c">RotationMatrix3</a> = <a class="el" href="group__algebra__types.html#gaa9dacb7a0481f6908ad7fc61d3523c9f">SquareMatrix3</a></td></tr>
<tr class="memdesc:ga04f891882a45afadbe07df33ad1c181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D rotation matrix  <br /></td></tr>
<tr class="memitem:ac4045b2d1b45e4878781a1aef72ce245" id="r_ac4045b2d1b45e4878781a1aef72ce245"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4045b2d1b45e4878781a1aef72ce245">SeedIndex2</a> = std::uint32_t</td></tr>
<tr class="memitem:ac7fe124c6f6fda8fa31781f93cbd36b8" id="r_ac7fe124c6f6fda8fa31781f93cbd36b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7fe124c6f6fda8fa31781f93cbd36b8">SerializedSubspaceIndices</a> = std::uint64_t</td></tr>
<tr class="memdesc:ac7fe124c6f6fda8fa31781f93cbd36b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for serialized subspace indices.  <br /></td></tr>
<tr class="memitem:a5b56fc104eaff23f7abdd63943418113" id="r_a5b56fc104eaff23f7abdd63943418113"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b56fc104eaff23f7abdd63943418113">SinglyChargedBoundTrackParameters</a></td></tr>
<tr class="memdesc:a5b56fc104eaff23f7abdd63943418113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for bound track parameters of singly charged particles.  <br /></td></tr>
<tr class="memitem:aea0bf98374c4170e158eb7514d2bbf97" id="r_aea0bf98374c4170e158eb7514d2bbf97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea0bf98374c4170e158eb7514d2bbf97">SinglyChargedFreeTrackParameters</a></td></tr>
<tr class="memdesc:aea0bf98374c4170e158eb7514d2bbf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for free track parameters of singly charged particles.  <br /></td></tr>
<tr class="memitem:a5d7404f9e2ba75e16149f97ec4cfe62e" id="r_a5d7404f9e2ba75e16149f97ec4cfe62e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d7404f9e2ba75e16149f97ec4cfe62e">SourceLinkSurfaceAccessor</a> = <a class="el" href="class_acts_1_1_delegate.html">Delegate</a>&lt;const <a class="el" href="class_acts_1_1_surface.html">Surface</a>*(const <a class="el" href="class_acts_1_1_source_link.html">SourceLink</a>&amp;)&gt;</td></tr>
<tr class="memdesc:a5d7404f9e2ba75e16149f97ec4cfe62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegate to unpack the surface associated with a source link.  <br /></td></tr>
<tr class="memitem:a59d378bfaff7526c72743adf3da1bc1f" id="r_a59d378bfaff7526c72743adf3da1bc1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a> = std::uint32_t</td></tr>
<tr class="memitem:a0c354ee4f15c223b223dc14c4ff96f97" id="r_a0c354ee4f15c223b223dc14c4ff96f97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c354ee4f15c223b223dc14c4ff96f97">SpacePointIndexRange2</a> = std::pair&lt;<a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a>, <a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a>&gt;</td></tr>
<tr class="memitem:a61285991285178e9661e36267761d52d" id="r_a61285991285178e9661e36267761d52d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61285991285178e9661e36267761d52d">SpacePointIndexSubset2</a> = std::span&lt;const <a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a>&gt;</td></tr>
<tr class="memitem:ga57a9cb002daaf227c693f2992fa5540c" id="r_ga57a9cb002daaf227c693f2992fa5540c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga57a9cb002daaf227c693f2992fa5540c">SquareMatrix2</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;2&gt;</td></tr>
<tr class="memdesc:ga57a9cb002daaf227c693f2992fa5540c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2x2 square matrix type, typically used for 2D coordinate covariance  <br /></td></tr>
<tr class="memitem:gaa9dacb7a0481f6908ad7fc61d3523c9f" id="r_gaa9dacb7a0481f6908ad7fc61d3523c9f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gaa9dacb7a0481f6908ad7fc61d3523c9f">SquareMatrix3</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;3&gt;</td></tr>
<tr class="memdesc:gaa9dacb7a0481f6908ad7fc61d3523c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">3x3 square matrix type, typically used for 3D coordinate covariance  <br /></td></tr>
<tr class="memitem:ga1afbdebccbfa71435c541dab8d565108" id="r_ga1afbdebccbfa71435c541dab8d565108"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga1afbdebccbfa71435c541dab8d565108">SquareMatrix4</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;4&gt;</td></tr>
<tr class="memdesc:ga1afbdebccbfa71435c541dab8d565108"><td class="mdescLeft">&#160;</td><td class="mdescRight">4x4 square matrix type, typically used for 4D coordinate covariance  <br /></td></tr>
<tr class="memitem:a1670ec4e030e90f0bce7b5154a9d12bb" id="r_a1670ec4e030e90f0bce7b5154a9d12bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1670ec4e030e90f0bce7b5154a9d12bb">SubspaceIndex</a> = std::uint8_t</td></tr>
<tr class="memdesc:a1670ec4e030e90f0bce7b5154a9d12bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for subspace index.  <br /></td></tr>
<tr class="memitem:a6a670110d0ebb9267ec1256f8bd88b6e" id="r_a6a670110d0ebb9267ec1256f8bd88b6e"><td class="memTemplParams" colspan="2">template&lt;std::size_t measdim&gt; </td></tr>
<tr class="memitem:a6a670110d0ebb9267ec1256f8bd88b6e template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a> = std::array&lt;<a class="el" href="#a1670ec4e030e90f0bce7b5154a9d12bb">SubspaceIndex</a>, measdim&gt;</td></tr>
<tr class="memdesc:a6a670110d0ebb9267ec1256f8bd88b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template alias for subspace indices array.  <br /></td></tr>
<tr class="memitem:gab39fab40696fab1b03cca78f951db023" id="r_gab39fab40696fab1b03cca78f951db023"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gab39fab40696fab1b03cca78f951db023">SurfaceAndMaterialWithContext</a></td></tr>
<tr class="memdesc:gab39fab40696fab1b03cca78f951db023"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple containing a surface, its associated material, and geometry context.  <br /></td></tr>
<tr class="memitem:aff81cf741e697ab165fc3579cacda4aa" id="r_aff81cf741e697ab165fc3579cacda4aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff81cf741e697ab165fc3579cacda4aa">SurfaceBoundFactory</a> = <a class="el" href="class_acts_1_1_bound_factory.html">BoundFactory</a>&lt;const <a class="el" href="class_acts_1_1_surface_bounds.html">SurfaceBounds</a>&gt;</td></tr>
<tr class="memdesc:aff81cf741e697ab165fc3579cacda4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abrivation for a factory to construct surface bounds.  <br /></td></tr>
<tr class="memitem:a884d99e12205bfc04d2cc2a8501a3a39" id="r_a884d99e12205bfc04d2cc2a8501a3a39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a884d99e12205bfc04d2cc2a8501a3a39">SurfaceMatcher</a></td></tr>
<tr class="memdesc:a884d99e12205bfc04d2cc2a8501a3a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type for comparing two surfaces in a given geometry context and axis direction.  <br /></td></tr>
<tr class="memitem:a0ff605a935815bac9c0a18618e1f4b65" id="r_a0ff605a935815bac9c0a18618e1f4b65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ff605a935815bac9c0a18618e1f4b65">SurfaceMaterialMaps</a></td></tr>
<tr class="memdesc:a0ff605a935815bac9c0a18618e1f4b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for surface material maps indexed by geometry identifier.  <br /></td></tr>
<tr class="memitem:ga76d1cebc6f43c76e5aaa8ef77d474064" id="r_ga76d1cebc6f43c76e5aaa8ef77d474064"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga76d1cebc6f43c76e5aaa8ef77d474064">surfaceMaterialPointer</a> = const <a class="el" href="class_acts_1_1_i_surface_material.html">Acts::ISurfaceMaterial</a>*</td></tr>
<tr class="memdesc:ga76d1cebc6f43c76e5aaa8ef77d474064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant surface material object.  <br /></td></tr>
<tr class="memitem:aa80f2fb6a7e543af58af13eedf6fdbd0" id="r_aa80f2fb6a7e543af58af13eedf6fdbd0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa80f2fb6a7e543af58af13eedf6fdbd0">SurfaceMatrix</a> = std::vector&lt;<a class="el" href="#a24683289c06d2751edbef04f58b3fdcd">SurfaceVector</a>&gt;</td></tr>
<tr class="memdesc:aa80f2fb6a7e543af58af13eedf6fdbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix (2D vector) of pointers to constant Surface objects.  <br /></td></tr>
<tr class="memitem:a24683289c06d2751edbef04f58b3fdcd" id="r_a24683289c06d2751edbef04f58b3fdcd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24683289c06d2751edbef04f58b3fdcd">SurfaceVector</a> = std::vector&lt;const <a class="el" href="class_acts_1_1_surface.html">Surface</a>*&gt;</td></tr>
<tr class="memdesc:a24683289c06d2751edbef04f58b3fdcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of pointers to constant Surface objects.  <br /></td></tr>
<tr class="memitem:ab10f01c2759ff4e801d804fdf1a91199" id="r_ab10f01c2759ff4e801d804fdf1a91199"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a> = std::uint32_t</td></tr>
<tr class="memdesc:ab10f01c2759ff4e801d804fdf1a91199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for track index values.  <br /></td></tr>
<tr class="memitem:a4840b95a87ca15ddba7ceb31b16a4353" id="r_a4840b95a87ca15ddba7ceb31b16a4353"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4840b95a87ca15ddba7ceb31b16a4353">TrackingGeometryMaterial</a></td></tr>
<tr class="memdesc:a4840b95a87ca15ddba7ceb31b16a4353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for tracking geometry material containing surface and volume maps.  <br /></td></tr>
<tr class="memitem:ga493120b39f9605cd708b460b16a20c96" id="r_ga493120b39f9605cd708b460b16a20c96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga493120b39f9605cd708b460b16a20c96">TrackingVolumeAndMaterial</a></td></tr>
<tr class="memdesc:ga493120b39f9605cd708b460b16a20c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair containing a tracking volume and its associated material.  <br /></td></tr>
<tr class="memitem:adf2d7adffd50e2d6dd1dbeb65fb658ed" id="r_adf2d7adffd50e2d6dd1dbeb65fb658ed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf2d7adffd50e2d6dd1dbeb65fb658ed">TrackingVolumeOrderPosition</a> = std::pair&lt;<a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a>, <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&gt;</td></tr>
<tr class="memdesc:adf2d7adffd50e2d6dd1dbeb65fb658ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair associating a tracking volume with its position vector.  <br /></td></tr>
<tr class="memitem:a852fc4a2512213a43398b39341378a1d" id="r_a852fc4a2512213a43398b39341378a1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a852fc4a2512213a43398b39341378a1d">TrackLinearizer</a></td></tr>
<tr class="memdesc:a852fc4a2512213a43398b39341378a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A delegate for linearizing a track at a given point in time and surface.  <br /></td></tr>
<tr class="memitem:gab094aafdf215d4e0bd0fa31fb4428418" id="r_gab094aafdf215d4e0bd0fa31fb4428418"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gab094aafdf215d4e0bd0fa31fb4428418">Transform2</a> = Eigen::Transform&lt;double, 2, Eigen::AffineCompact&gt;</td></tr>
<tr class="memdesc:gab094aafdf215d4e0bd0fa31fb4428418"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D affine transformation stored as a compact 2x3 matrix  <br /></td></tr>
<tr class="memitem:ga0b5cf144852112b0c7f251a493d8877e" id="r_ga0b5cf144852112b0c7f251a493d8877e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> = Eigen::Transform&lt;double, 3, Eigen::Affine&gt;</td></tr>
<tr class="memdesc:ga0b5cf144852112b0c7f251a493d8877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D affine transformation stored as a 4x4 matrix  <br /></td></tr>
<tr class="memitem:gac9f6a028bde4d2d18b7ab554471df6c2" id="r_gac9f6a028bde4d2d18b7ab554471df6c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gac9f6a028bde4d2d18b7ab554471df6c2">Translation2</a> = Eigen::Translation&lt;double, 2&gt;</td></tr>
<tr class="memdesc:gac9f6a028bde4d2d18b7ab554471df6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D translation transformation  <br /></td></tr>
<tr class="memitem:ga1a7960bfb4807cba616fd8bdf81d3d00" id="r_ga1a7960bfb4807cba616fd8bdf81d3d00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga1a7960bfb4807cba616fd8bdf81d3d00">Translation3</a> = Eigen::Translation&lt;double, 3&gt;</td></tr>
<tr class="memdesc:ga1a7960bfb4807cba616fd8bdf81d3d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D translation transformation  <br /></td></tr>
<tr class="memitem:ab89ce687d622245c5610b79701471285" id="r_ab89ce687d622245c5610b79701471285"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab89ce687d622245c5610b79701471285">V3Matrix</a> = std::vector&lt;<a class="el" href="#a6173fd5678f75d05d96cd30cfb5bab0a">V3Vector</a>&gt;</td></tr>
<tr class="memdesc:ab89ce687d622245c5610b79701471285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix (2D vector) of 3D vectors, used for storing grid-like collections of 3D points.  <br /></td></tr>
<tr class="memitem:a6173fd5678f75d05d96cd30cfb5bab0a" id="r_a6173fd5678f75d05d96cd30cfb5bab0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6173fd5678f75d05d96cd30cfb5bab0a">V3Vector</a> = std::vector&lt;<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&gt;</td></tr>
<tr class="memdesc:a6173fd5678f75d05d96cd30cfb5bab0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of 3D vectors, used for storing collections of 3D points.  <br /></td></tr>
<tr class="memitem:aaaa9c77f4dd9efc1ac464d9a941f2ef2" id="r_aaaa9c77f4dd9efc1ac464d9a941f2ef2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaaa9c77f4dd9efc1ac464d9a941f2ef2">VariableBoundSubspaceHelper</a></td></tr>
<tr class="memdesc:aaaa9c77f4dd9efc1ac464d9a941f2ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for variable-size bound parameter subspaces.  <br /></td></tr>
<tr class="memitem:gabb76f2d48e0590ef82a8afaad39a77b5" id="r_gabb76f2d48e0590ef82a8afaad39a77b5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;2&gt;</td></tr>
<tr class="memdesc:gabb76f2d48e0590ef82a8afaad39a77b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-dimensional vector type for 2D coordinates  <br /></td></tr>
<tr class="memitem:ga8183a99dab8a7c6fff67d7c6c05bfb22" id="r_ga8183a99dab8a7c6fff67d7c6c05bfb22"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;3&gt;</td></tr>
<tr class="memdesc:ga8183a99dab8a7c6fff67d7c6c05bfb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">3-dimensional vector type for e.g. spatial coordinates and momenta  <br /></td></tr>
<tr class="memitem:ga3a320a58e0d6145e3f7ecf78c289dfd7" id="r_ga3a320a58e0d6145e3f7ecf78c289dfd7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga3a320a58e0d6145e3f7ecf78c289dfd7">Vector4</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;4&gt;</td></tr>
<tr class="memdesc:ga3a320a58e0d6145e3f7ecf78c289dfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">4-dimensional vector type for space-time coordinates  <br /></td></tr>
<tr class="memitem:aca88659ee97e667013784c4fac8475f2" id="r_aca88659ee97e667013784c4fac8475f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca88659ee97e667013784c4fac8475f2">VolumeBoundFactory</a> = <a class="el" href="class_acts_1_1_bound_factory.html">BoundFactory</a>&lt;<a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a>&gt;</td></tr>
<tr class="memdesc:aca88659ee97e667013784c4fac8475f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abrivation for a factory to construct volume bounds.  <br /></td></tr>
<tr class="memitem:adab8ee0743a2872f4ca6888b37c65f04" id="r_adab8ee0743a2872f4ca6888b37c65f04"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adab8ee0743a2872f4ca6888b37c65f04">VolumeMaterialMaps</a></td></tr>
<tr class="memdesc:adab8ee0743a2872f4ca6888b37c65f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for volume material maps indexed by geometry identifier.  <br /></td></tr>
<tr class="memitem:ga06973c0a57ed2cedc63a4e66a33eb4ae" id="r_ga06973c0a57ed2cedc63a4e66a33eb4ae"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga06973c0a57ed2cedc63a4e66a33eb4ae">volumeMaterialPointer</a> = const <a class="el" href="class_acts_1_1_i_volume_material.html">Acts::IVolumeMaterial</a>*</td></tr>
<tr class="memdesc:ga06973c0a57ed2cedc63a4e66a33eb4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a constant volume material object.  <br /></td></tr>
<tr id="typedef-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a2d207ef0f7109becc8fba98cb145ed9d" id="r_a2d207ef0f7109becc8fba98cb145ed9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a> = std::shared_ptr&lt;const <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>&gt;</td></tr>
<tr class="memdesc:a2d207ef0f7109becc8fba98cb145ed9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::shared_ptr to a tracking volume.  <br /></td></tr>
<tr class="memitem:a28648357639285c87a2440debff326f3" id="r_a28648357639285c87a2440debff326f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28648357639285c87a2440debff326f3">TrackingVolumeArray</a> = <a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a>&lt;<a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a>&gt;</td></tr>
<tr class="memdesc:a28648357639285c87a2440debff326f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BinnedArray of a std::shared_tr to a TrackingVolume.  <br /></td></tr>
<tr class="memitem:a813d99d294c94b676e4e7763b4af7901" id="r_a813d99d294c94b676e4e7763b4af7901"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a813d99d294c94b676e4e7763b4af7901">MutableTrackingVolumePtr</a> = std::shared_ptr&lt;<a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>&gt;</td></tr>
<tr class="memdesc:a813d99d294c94b676e4e7763b4af7901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a mutable TrackingVolume.  <br /></td></tr>
<tr class="memitem:a75b87c7a3396f68139b33fe375e4d3b8" id="r_a75b87c7a3396f68139b33fe375e4d3b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b87c7a3396f68139b33fe375e4d3b8">MutableTrackingVolumeVector</a> = std::vector&lt;<a class="el" href="#a813d99d294c94b676e4e7763b4af7901">MutableTrackingVolumePtr</a>&gt;</td></tr>
<tr class="memdesc:a75b87c7a3396f68139b33fe375e4d3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of shared pointers to mutable TrackingVolumes.  <br /></td></tr>
<tr class="memitem:ab749c2bd4901201fd7cc09b7f370a34e" id="r_ab749c2bd4901201fd7cc09b7f370a34e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab749c2bd4901201fd7cc09b7f370a34e">LayerArray</a> = <a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a>&lt;<a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a>&gt;</td></tr>
<tr class="memdesc:ab749c2bd4901201fd7cc09b7f370a34e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A BinnedArray to a std::shared_ptr of a layer.  <br /></td></tr>
<tr class="memitem:a98ab2a52542f2ff29cb738cfefc2a7d2" id="r_a98ab2a52542f2ff29cb738cfefc2a7d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98ab2a52542f2ff29cb738cfefc2a7d2">LayerVector</a> = std::vector&lt;<a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a>&gt;</td></tr>
<tr class="memdesc:a98ab2a52542f2ff29cb738cfefc2a7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of std::shared_ptr to layers.  <br /></td></tr>
<tr class="memitem:a4230ba1191701d7b7fbed04b39a8d2f2" id="r_a4230ba1191701d7b7fbed04b39a8d2f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4230ba1191701d7b7fbed04b39a8d2f2">TrackingVolumeVector</a> = std::vector&lt;<a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a>&gt;</td></tr>
<tr class="memdesc:a4230ba1191701d7b7fbed04b39a8d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector of a std::shared_ptr to a TrackingVolume.  <br /></td></tr>
<tr class="memitem:a46aee760d4a254ba395540f5500b7a74" id="r_a46aee760d4a254ba395540f5500b7a74"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46aee760d4a254ba395540f5500b7a74">TrackingVolumeBoundaryPtr</a></td></tr>
<tr class="memdesc:a46aee760d4a254ba395540f5500b7a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to a constant BoundarySurfaceT of a TrackingVolume.  <br /></td></tr>
<tr class="memitem:ab10f820874384c7566b692cc40f9d30f" id="r_ab10f820874384c7566b692cc40f9d30f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab10f820874384c7566b692cc40f9d30f">TrackingVolumeBoundaries</a> = std::vector&lt;<a class="el" href="#a46aee760d4a254ba395540f5500b7a74">TrackingVolumeBoundaryPtr</a>&gt;</td></tr>
<tr class="memdesc:ab10f820874384c7566b692cc40f9d30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for collection of tracking volume boundaries.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a578206dbf1d765d06d19c1ec233a4159" id="r_a578206dbf1d765d06d19c1ec233a4159"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a578206dbf1d765d06d19c1ec233a4159">AlignmentIndices</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="#a578206dbf1d765d06d19c1ec233a4159aaef292026444af947478c571db012acd">eAlignmentCenter0</a> = 0u
, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159ac75845e02a00fcf3d8a1e8579b550f06">eAlignmentCenter1</a> = eAlignmentCenter0 + 1u
, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a617f7adc10f363908f07af4ec7bc8633">eAlignmentCenter2</a> = eAlignmentCenter0 + 2u
, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a597a8de9dee10809695ff4bd6df486d4">eAlignmentRotation0</a> = 3u
, <br />
&#160;&#160;<a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a8ad05c974aec053517f0da995ba14d1d">eAlignmentRotation1</a> = eAlignmentRotation0 + 1u
, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159ad497001f2d872027a1ee296173d125ef">eAlignmentRotation2</a> = eAlignmentRotation0 + 2u
, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>
<br />
 }</td></tr>
<tr class="memdesc:a578206dbf1d765d06d19c1ec233a4159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Components of alignment parameters vector.  <a href="#a578206dbf1d765d06d19c1ec233a4159">More...</a><br /></td></tr>
<tr class="memitem:a8cacb654fb3407f6911cfcf424f69ba7" id="r_a8cacb654fb3407f6911cfcf424f69ba7"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a> { <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">Open</a>
, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7a685d1f2146dd079015e81918414e8971">Bound</a>
, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7a03f4a47830f97377a35321051685071e">Closed</a>
 }</td></tr>
<tr class="memdesc:a8cacb654fb3407f6911cfcf424f69ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum which determines how the axis handle its outer boundaries possible values values.  <a href="#a8cacb654fb3407f6911cfcf424f69ba7">More...</a><br /></td></tr>
<tr class="memitem:a1462738699cb376ae92c59811987f4ea" id="r_a1462738699cb376ae92c59811987f4ea"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> : int { <br />
&#160;&#160;<a class="el" href="#a1462738699cb376ae92c59811987f4eaa38b0844100a915cd3c87159b391161b9">AxisX</a> = 0
, <a class="el" href="#a1462738699cb376ae92c59811987f4eaab30a50c686982b3b209cf1234f4247cd">AxisY</a> = 1
, <a class="el" href="#a1462738699cb376ae92c59811987f4eaadd1071c1aa89157c2386d3303413218f">AxisZ</a> = 2
, <a class="el" href="#a1462738699cb376ae92c59811987f4eaa66964a770b69520967ff845d6a141d7b">AxisR</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a1462738699cb376ae92c59811987f4eaa767ac49408b49422cdfdfa90582e7c50">AxisPhi</a> = 4
, <a class="el" href="#a1462738699cb376ae92c59811987f4eaaac2cc7059f8482e8c68cc9849e8a9883">AxisRPhi</a> = 5
, <a class="el" href="#a1462738699cb376ae92c59811987f4eaaa6a30a95d4c241fdfd6baf44cb77c03a">AxisTheta</a> = 6
, <a class="el" href="#a1462738699cb376ae92c59811987f4eaaec435e5ddb1e69ebe1aeb7a9302fa4fa">AxisEta</a> = 7
, <br />
&#160;&#160;<a class="el" href="#a1462738699cb376ae92c59811987f4eaa8f7ef15062f2d841678dc6358d2691c9">AxisMag</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a1462738699cb376ae92c59811987f4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">to specify a local axis direction  <a href="#a1462738699cb376ae92c59811987f4ea">More...</a><br /></td></tr>
<tr class="memitem:a2472b7e663ee623501edad0bbcd8a32f" id="r_a2472b7e663ee623501edad0bbcd8a32f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2472b7e663ee623501edad0bbcd8a32f">AxisType</a> { <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Equidistant</a>
, <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9">Variable</a>
 }</td></tr>
<tr class="memdesc:a2472b7e663ee623501edad0bbcd8a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum which determines the binning type of the axis.  <a href="#a2472b7e663ee623501edad0bbcd8a32f">More...</a><br /></td></tr>
<tr class="memitem:a3aaee285dd8963f35f05db5e6bf23769" id="r_a3aaee285dd8963f35f05db5e6bf23769"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aaee285dd8963f35f05db5e6bf23769">BinningOption</a> { <a class="el" href="#a3aaee285dd8963f35f05db5e6bf23769a67f93521db5cc254387b8e1437c0691e">open</a>
, <a class="el" href="#a3aaee285dd8963f35f05db5e6bf23769a612c34ec7764ae1c94b0382e8bd7534c">closed</a>
 }</td></tr>
<tr class="memdesc:a3aaee285dd8963f35f05db5e6bf23769"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag for open/closed bins  <a href="#a3aaee285dd8963f35f05db5e6bf23769">More...</a><br /></td></tr>
<tr class="memitem:a137e6814b0021a40f572aeb4922a7b81" id="r_a137e6814b0021a40f572aeb4922a7b81"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137e6814b0021a40f572aeb4922a7b81">BinningType</a> { <a class="el" href="#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">equidistant</a>
, <a class="el" href="#a137e6814b0021a40f572aeb4922a7b81a3fb230d5b902fe93692b1f49e7175330">arbitrary</a>
 }</td></tr>
<tr class="memdesc:a137e6814b0021a40f572aeb4922a7b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">, BinningOption &amp; BinningAccess  <a href="#a137e6814b0021a40f572aeb4922a7b81">More...</a><br /></td></tr>
<tr class="memitem:a324b54b2d52fbc9244d94e305d9203d3" id="r_a324b54b2d52fbc9244d94e305d9203d3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3">BoundarySurfaceFace</a> { <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a5d700bbf3210b96dff5d012da022356e">negativeFaceXY</a> = 0
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a3badb5ad699267cc1a28104441d94b54">positiveFaceXY</a> = 1
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a3294c592ff615ee3c44b46e7efc22127">negativeFaceYZ</a> = 2
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a4e27416cba7eb8a49ab97d922973dc4d">positiveFaceYZ</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a2bb138735d0be5d1b535262344472a62">negativeFaceZX</a> = 4
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3ab2b6bf00a36b9daf9c8ecef5bbf9f5fe">positiveFaceZX</a> = 5
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a43c803702f6b49fe865151617ae1cf81">cylinderCover</a> = 2
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3ae9823396740c5ac0ec5530c5f5f692ef">tubeInnerCover</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3aceff7580baab43d7f4b284d71e76dd2c">tubeOuterCover</a> = 2
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a486df768d6da0470744a1061c973ea17">tubeSectorNegativePhi</a> = 4
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3afeaf47f7a139d2f5fe67a66429d62e49">tubeSectorPositivePhi</a> = 5
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3af68f13975eeb1abccb155ef5b06c09ea">tubeSectorInnerCover</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3ac40da2094a0ce562c252a8f883c4439c">tubeSectorOuterCover</a> = 2
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a5161a0d6a21c039846664ebcb9f10ad5">trapezoidFaceAlpha</a> = 2
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3aba35a7a655d5560cbbcbb657680e4089">trapezoidFaceBeta</a> = 3
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a0f93dcc0cf89a91eed40a82af3184e72">index0</a> = 0
, <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a0b93936a59efef879bf69ab34f755964">index1</a> = 1
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a312584e16590945fb13813268f963d4a">index2</a> = 2
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3ac618d3184185f1567e2af0bf1e196189">index3</a> = 3
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3ab5d6337bb7ba571539ca9fe73132dd70">index4</a> = 4
, <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a34dc1389401d5d65bc4a1afb71e0f898">index5</a> = 5
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a3285c51c14f80248857d027ba6306b32">index6</a> = 6
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a658371a18be45142005f224715810b79">index7</a> = 7
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a3f62b73ba16ca67d539b0eea46f82564">index8</a> = 8
, <br />
&#160;&#160;<a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3a6322b794b9e4e6e6934526a2ed3651ad">index9</a> = 9
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3ae71bbf8540421d745ac7154811ae8181">index10</a> = 10
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3adf5b663d9a4d3b2593032dcaebfac7a9">index11</a> = 11
, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3af0f501d6c9600e66c267af09f0574e8a">undefinedFace</a> = 99
<br />
 }</td></tr>
<tr class="memdesc:a324b54b2d52fbc9244d94e305d9203d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to describe the position of the BoundarySurface respectively to the frame orientatin of the volume, this is mainly meant for code readability.  <a href="#a324b54b2d52fbc9244d94e305d9203d3">More...</a><br /></td></tr>
<tr class="memitem:ad2b38e86cfd40fa19fe61c74e8ca9fc7" id="r_ad2b38e86cfd40fa19fe61c74e8ca9fc7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7">BoundIndices</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a319222836e2703f23f7abbec507ea82e">eBoundLoc0</a> = 0
, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a4259ac51b5652240e3102b8f32de1e58">eBoundLoc1</a> = 1
, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a66c6483e3948c3bf8284289300e30375">eBoundPhi</a> = 2
, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a9ca150ef5e671d4463771fb250fffdb7">eBoundTheta</a> = 3
, <br />
&#160;&#160;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a4391499f36e0f4817927d2bca12ece83">eBoundQOverP</a> = 4
, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a31c17ef85d34327f7da749b96b1f0f5f">eBoundTime</a> = 5
, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>
<br />
 }</td></tr>
<tr class="memdesc:ad2b38e86cfd40fa19fe61c74e8ca9fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Components of a bound track parameters vector.  <a href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7">More...</a><br /></td></tr>
<tr class="memitem:gaeebbf038ee135dbf867fe05d0f61d09b" id="r_gaeebbf038ee135dbf867fe05d0f61d09b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__track__finding.html#gaeebbf038ee135dbf867fe05d0f61d09b">CombinatorialKalmanFilterBranchStopperResult</a> { <a class="el" href="group__track__finding.html#ggaeebbf038ee135dbf867fe05d0f61d09baa0bfb8e59e6c13fc8d990781f77694fe">CombinatorialKalmanFilterBranchStopperResult::Continue</a>
, <a class="el" href="group__track__finding.html#ggaeebbf038ee135dbf867fe05d0f61d09ba1d92ea9652ee828fa2b40c68b9fe8623">CombinatorialKalmanFilterBranchStopperResult::StopAndDrop</a>
, <a class="el" href="group__track__finding.html#ggaeebbf038ee135dbf867fe05d0f61d09badbf311296df3376417089a7fb1da6ffd">CombinatorialKalmanFilterBranchStopperResult::StopAndKeep</a>
 }</td></tr>
<tr class="memdesc:gaeebbf038ee135dbf867fe05d0f61d09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type of the <span class="tt">BranchStopper</span> delegate for the CombinatorialKalmanFilter.  <a href="group__track__finding.html#gaeebbf038ee135dbf867fe05d0f61d09b">More...</a><br /></td></tr>
<tr class="memitem:ga5708898bc604b9dfedc12319218b8c1b" id="r_ga5708898bc604b9dfedc12319218b8c1b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga5708898bc604b9dfedc12319218b8c1b">CombinatorialKalmanFilterError</a> { <br />
&#160;&#160;<a class="el" href="group__errors.html#gga5708898bc604b9dfedc12319218b8c1bab1699d129532c7c6294a1f26fd4032d9">CombinatorialKalmanFilterError::UpdateFailed</a> = 1
, <a class="el" href="group__errors.html#gga5708898bc604b9dfedc12319218b8c1bab91834cc99e0c4508dfebaadb2980b7c">CombinatorialKalmanFilterError::SmoothFailed</a>
, <a class="el" href="group__errors.html#gga5708898bc604b9dfedc12319218b8c1ba9a1dae01a56ad58a9db7ea93bb3c7a1c">CombinatorialKalmanFilterError::OutputConversionFailed</a>
, <a class="el" href="group__errors.html#gga5708898bc604b9dfedc12319218b8c1ba2ff410cc0e0ef7f55e8353551458922e">CombinatorialKalmanFilterError::MeasurementSelectionFailed</a>
, <br />
&#160;&#160;<a class="el" href="group__errors.html#gga5708898bc604b9dfedc12319218b8c1bacad57a44b12889a25020a697b8b3aa25">CombinatorialKalmanFilterError::PropagationReachesMaxSteps</a>
, <a class="el" href="group__errors.html#gga5708898bc604b9dfedc12319218b8c1ba3b19dd219405eef6b47cac8bbc764d82">CombinatorialKalmanFilterError::NoMeasurementExpected</a>
<br />
 }</td></tr>
<tr class="memdesc:ga5708898bc604b9dfedc12319218b8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for combinatorial Kalman filter operations.  <a href="group__errors.html#ga5708898bc604b9dfedc12319218b8c1b">More...</a><br /></td></tr>
<tr class="memitem:ga920082397516a41a551b2a9883131d66" id="r_ga920082397516a41a551b2a9883131d66"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__track__fitting.html#ga920082397516a41a551b2a9883131d66">ComponentMergeMethod</a> { <a class="el" href="group__track__fitting.html#gga920082397516a41a551b2a9883131d66a3777ecb542bc8383bb318326dc78543d">ComponentMergeMethod::eMean</a>
, <a class="el" href="group__track__fitting.html#gga920082397516a41a551b2a9883131d66a94c1ac5c5a71671cad67049d837a4da7">ComponentMergeMethod::eMaxWeight</a>
 }</td></tr>
<tr class="memdesc:ga920082397516a41a551b2a9883131d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available reduction methods for the reduction of a Gaussian mixture.  <a href="group__track__fitting.html#ga920082397516a41a551b2a9883131d66">More...</a><br /></td></tr>
<tr class="memitem:a07a86fac65395a5f95452259e7872ecc" id="r_a07a86fac65395a5f95452259e7872ecc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07a86fac65395a5f95452259e7872ecc">CoordinateIndices</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="#a07a86fac65395a5f95452259e7872eccac46dd3bdcb88e54d86077aa499e4a84d">ePos0</a> = 0
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca85bf6038f2eee2fb999303930ca53005">ePos1</a> = 1
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca1485bf9e3844cb8613b7c8a3db1a8658">ePos2</a> = 2
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca42f43e4f9334887d02a4f321975e5af3">eTime</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a07a86fac65395a5f95452259e7872ecca2499a9f1c7c7c4479671ef8460cae0fb">eMom0</a> = ePos0
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca46e52afdf781a6081758894aa7b932f1">eMom1</a> = ePos1
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca8254871e7ee04710d4c9b89ad973bc2d">eMom2</a> = ePos2
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca8d77cea2a8b00c8305dc21dc92c19620">eEnergy</a> = eTime
, <br />
&#160;&#160;<a class="el" href="#a07a86fac65395a5f95452259e7872ecca14506a1394164c5803e7f6db4e7a225b">eX</a> = ePos0
, <a class="el" href="#a07a86fac65395a5f95452259e7872ecca044d957dc4b3a5e03bbc2f48fe6c143d">eY</a> = ePos1
, <a class="el" href="#a07a86fac65395a5f95452259e7872eccac492522bc7badaffc0024a54070e5a97">eZ</a> = ePos2
<br />
 }</td></tr>
<tr class="memdesc:a07a86fac65395a5f95452259e7872ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Components of coordinate vectors.  <a href="#a07a86fac65395a5f95452259e7872ecc">More...</a><br /></td></tr>
<tr class="memitem:abd2611d6c7dda89bd26dd00c64538490" id="r_abd2611d6c7dda89bd26dd00c64538490"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd2611d6c7dda89bd26dd00c64538490">DelegateType</a> { <a class="el" href="#abd2611d6c7dda89bd26dd00c64538490ae0fdb994c5952ea712f1509aeb7ba380">Owning</a>
, <a class="el" href="#abd2611d6c7dda89bd26dd00c64538490a64a6a344ccce441462a47f08e206df86">NonOwning</a>
 }</td></tr>
<tr class="memdesc:abd2611d6c7dda89bd26dd00c64538490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ownership enum for <code>Delegate</code>.  <a href="#abd2611d6c7dda89bd26dd00c64538490">More...</a><br /></td></tr>
<tr class="memitem:a940f149b53e1e3b9e3c4302f082e0fe9" id="r_a940f149b53e1e3b9e3c4302f082e0fe9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a940f149b53e1e3b9e3c4302f082e0fe9">DetectorMeasurementInfo</a> : short { <a class="el" href="#a940f149b53e1e3b9e3c4302f082e0fe9aaf71f03861810014d736fcbae9d6050e">eDefault</a>
, <a class="el" href="#a940f149b53e1e3b9e3c4302f082e0fe9acaf83905292e2bacf405591fb8b79727">eDetailed</a>
 }</td></tr>
<tr class="memdesc:a940f149b53e1e3b9e3c4302f082e0fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of detector measurement information for seeding.  <a href="#a940f149b53e1e3b9e3c4302f082e0fe9">More...</a><br /></td></tr>
<tr class="memitem:ga21cb0f3d4dc02db3af0291385e70d4e0" id="r_ga21cb0f3d4dc02db3af0291385e70d4e0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga21cb0f3d4dc02db3af0291385e70d4e0">EigenStepperError</a> { <a class="el" href="group__errors.html#gga21cb0f3d4dc02db3af0291385e70d4e0ac96e8be3a0e8b6f5dd6d219249a81180">EigenStepperError::StepSizeStalled</a> = 1
, <a class="el" href="group__errors.html#gga21cb0f3d4dc02db3af0291385e70d4e0adec88b388126e180a1d7807815c6c8dd">EigenStepperError::StepInvalid</a>
, <a class="el" href="group__errors.html#gga21cb0f3d4dc02db3af0291385e70d4e0a2c4a5f9ada6b6941b6f25ba17affbab7">EigenStepperError::StepSizeAdjustmentFailed</a>
 }</td></tr>
<tr class="memdesc:ga21cb0f3d4dc02db3af0291385e70d4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for Eigen stepper operations.  <a href="group__errors.html#ga21cb0f3d4dc02db3af0291385e70d4e0">More...</a><br /></td></tr>
<tr class="memitem:a6c086a09086424ffb3ace68710e8e92c" id="r_a6c086a09086424ffb3ace68710e8e92c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c086a09086424ffb3ace68710e8e92c">FreeIndices</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca4f1d0ebd2431f946d8f901bac6617db9">eFreePos0</a> = 0u
, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca45d56ebce4df7ade3176b2c0b6e6c90e">eFreePos1</a> = eFreePos0 + 1u
, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca5a25393ea9eb37898e45369ea02ae6fd">eFreePos2</a> = eFreePos0 + 2u
, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca73bbfd1eb6084375bbd8cf207abcf2d2">eFreeTime</a> = 3u
, <br />
&#160;&#160;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca3994d4b5c6c143561e23cd964d61f916">eFreeDir0</a> = 4u
, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca21c44b4c6040114e447c024a5bdc4c88">eFreeDir1</a> = eFreeDir0 + 1u
, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92cac12a01ff06374c51606d4761c1ff0421">eFreeDir2</a> = eFreeDir0 + 2u
, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92cab2fad9ef29e2cec612213d6174338fed">eFreeQOverP</a> = 7u
, <br />
&#160;&#160;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>
<br />
 }</td></tr>
<tr class="memdesc:a6c086a09086424ffb3ace68710e8e92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Components of a free track parameters vector.  <a href="#a6c086a09086424ffb3ace68710e8e92c">More...</a><br /></td></tr>
<tr class="memitem:ga83f8b59ffc557631bb7fdd01c18431ca" id="r_ga83f8b59ffc557631bb7fdd01c18431ca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga83f8b59ffc557631bb7fdd01c18431ca">GsfError</a> { <a class="el" href="group__errors.html#gga83f8b59ffc557631bb7fdd01c18431caacd3ce8112cc132a6786646eff9689454">GsfError::StartParametersHaveNoCovariance</a>
, <a class="el" href="group__errors.html#gga83f8b59ffc557631bb7fdd01c18431caa6d0086586e767bdd2adbe51bfe8a6a51">GsfError::NoMeasurementStatesCreatedForward</a>
, <a class="el" href="group__errors.html#gga83f8b59ffc557631bb7fdd01c18431caa77854eb69cd722eed562c1deaf1db15f">GsfError::NoMeasurementStatesCreatedBackward</a>
, <a class="el" href="group__errors.html#gga83f8b59ffc557631bb7fdd01c18431caa78b62f76aa8053db68df72c21e0c71fa">GsfError::NoMeasurementStatesCreatedFinal</a>
 }</td></tr>
<tr class="memdesc:ga83f8b59ffc557631bb7fdd01c18431ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for Gaussian Sum Filter operations.  <a href="group__errors.html#ga83f8b59ffc557631bb7fdd01c18431ca">More...</a><br /></td></tr>
<tr class="memitem:af38a8ff832aa2393884b0dbed498973c" id="r_af38a8ff832aa2393884b0dbed498973c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af38a8ff832aa2393884b0dbed498973c">HadronType</a> { <br />
&#160;&#160;<a class="el" href="#af38a8ff832aa2393884b0dbed498973ca05fd33582850f21e2bac245a57bbcae3">Hadron</a> = 1
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973ca18a3f4d13a168be3fdc6e6760c9d70c8">BBbarMeson</a> = 2
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973cafe4b1b6a56ba9f1d9b3c68b9fd4fd050">CCbarMeson</a> = 3
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973cabda747bb379bd7a6c7c91ae3e0c9ad6d">BottomMeson</a> = 4
, <br />
&#160;&#160;<a class="el" href="#af38a8ff832aa2393884b0dbed498973ca3d0d31ea59ea13b6d0e3ce5cfba8ba0e">BottomBaryon</a> = 5
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973caeb2955155f246ef86400cc8045f3c18a">CharmedMeson</a> = 6
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973ca36871f11d12474317be626854e8335c8">CharmedBaryon</a> = 7
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973ca15b2a12bd2d6241cabca2a828dc01f63">StrangeMeson</a> = 8
, <br />
&#160;&#160;<a class="el" href="#af38a8ff832aa2393884b0dbed498973caf0cd241c4882b44a45437d98659451ad">StrangeBaryon</a> = 9
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973caaf0ffccf43f99415f875121886d30ce3">LightMeson</a> = 10
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973ca1c084319d0244f24aa37338cbc757308">LightBaryon</a> = 11
, <a class="el" href="#af38a8ff832aa2393884b0dbed498973ca88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a> = 12
<br />
 }</td></tr>
<tr class="memdesc:af38a8ff832aa2393884b0dbed498973c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hadron type classification for B, C, strange and light hadrons.  <a href="#af38a8ff832aa2393884b0dbed498973c">More...</a><br /></td></tr>
<tr class="memitem:a52191edec34daa17746d1937fb06c1fb" id="r_a52191edec34daa17746d1937fb06c1fb"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52191edec34daa17746d1937fb06c1fb">IntersectionStatus</a> : int { <a class="el" href="#a52191edec34daa17746d1937fb06c1fbab748f56cf76526f8606d7463b9df9f2e">unreachable</a> = 0
, <a class="el" href="#a52191edec34daa17746d1937fb06c1fbaa0fefe3b7423f88d38b84c1558ed4880">reachable</a> = 1
, <a class="el" href="#a52191edec34daa17746d1937fb06c1fbab03a0aa5a9868274aece083944113f96">onSurface</a> = 2
 }</td></tr>
<tr class="memdesc:a52191edec34daa17746d1937fb06c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status enum.  <a href="#a52191edec34daa17746d1937fb06c1fb">More...</a><br /></td></tr>
<tr class="memitem:gac3f65a46059b0f9516370f5bdcb9bddd" id="r_gac3f65a46059b0f9516370f5bdcb9bddd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#gac3f65a46059b0f9516370f5bdcb9bddd">KalmanFitterError</a> { <br />
&#160;&#160;<a class="el" href="group__errors.html#ggac3f65a46059b0f9516370f5bdcb9bdddab1699d129532c7c6294a1f26fd4032d9">KalmanFitterError::UpdateFailed</a> = 1
, <a class="el" href="group__errors.html#ggac3f65a46059b0f9516370f5bdcb9bdddab91834cc99e0c4508dfebaadb2980b7c">KalmanFitterError::SmoothFailed</a>
, <a class="el" href="group__errors.html#ggac3f65a46059b0f9516370f5bdcb9bddda9a1dae01a56ad58a9db7ea93bb3c7a1c">KalmanFitterError::OutputConversionFailed</a>
, <a class="el" href="group__errors.html#ggac3f65a46059b0f9516370f5bdcb9bddda0a5bbca22e12682affb21d70ecb3c465">KalmanFitterError::NoMeasurementFound</a>
, <br />
&#160;&#160;<a class="el" href="group__errors.html#ggac3f65a46059b0f9516370f5bdcb9bddda210024a5a0be9f5a6cd5824097e286e9">KalmanFitterError::ReversePropagationFailed</a>
, <a class="el" href="group__errors.html#ggac3f65a46059b0f9516370f5bdcb9bddda9d3db6a24d28f29f1ffa6c8ce8606971">KalmanFitterError::InconsistentTrackStates</a>
<br />
 }</td></tr>
<tr class="memdesc:gac3f65a46059b0f9516370f5bdcb9bddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for Kalman filter operations.  <a href="group__errors.html#gac3f65a46059b0f9516370f5bdcb9bddd">More...</a><br /></td></tr>
<tr class="memitem:ab59015c67d930641de6f1bb7e31e2873" id="r_ab59015c67d930641de6f1bb7e31e2873"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab59015c67d930641de6f1bb7e31e2873">LayerType</a> { <a class="el" href="#ab59015c67d930641de6f1bb7e31e2873a7eee8a5290452963e3934c132a800094">navigation</a> = -1
, <a class="el" href="#ab59015c67d930641de6f1bb7e31e2873a75938f0b93068f7d9012f32aff225069">passive</a> = 0
, <a class="el" href="#ab59015c67d930641de6f1bb7e31e2873aff33a3aaf8fc2bb1ae64bf505338a843">active</a> = 1
 }</td></tr>
<tr class="memdesc:ab59015c67d930641de6f1bb7e31e2873"><td class="mdescLeft">&#160;</td><td class="mdescRight">For code readability, it distinguishes between different type of layers, which steers the behaviour in the navigation.  <a href="#ab59015c67d930641de6f1bb7e31e2873">More...</a><br /></td></tr>
<tr class="memitem:ad7711ff8b0a2ed1a71deaa920bf8de53" id="r_ad7711ff8b0a2ed1a71deaa920bf8de53"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53">LinIndices</a> : unsigned int { <br />
&#160;&#160;<a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53ab61ccb9775fba63767ea82991f2a4aa8">eLinPos0</a> = 0u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53a69def383f20e8b9915d8ef079cf9b5fc">eLinPos1</a> = eLinPos0 + 1u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53afdcdc15b4f318d666f6054195345ddf5">eLinPos2</a> = eLinPos0 + 2u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53a964cd218b4f8977c94a74127040f4889">eLinTime</a> = 3u
, <br />
&#160;&#160;<a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53aaaebd448f83490d1a3aab1754d7c86c8">eLinPhi</a> = 4u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53aa502ce288aaa601d0c5ed8b50f8842bc">eLinTheta</a> = eLinPhi + 1u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53a1fa05a18a7a067f7f835e59deb2343d8">eLinQOverP</a> = 6u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53a032dc8fb65e403795ae6c9d212a9ec99">eLinSize</a> = 7u
, <br />
&#160;&#160;<a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53a286de5443484550d3526a78083ac78e9">eLinPosSize</a> = 4u
, <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53a535cc24e8940862d22a62dad726a2d22">eLinMomSize</a> = 3u
<br />
 }</td></tr>
<tr class="memdesc:ad7711ff8b0a2ed1a71deaa920bf8de53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to access the components of a track parameter vector.  <a href="#ad7711ff8b0a2ed1a71deaa920bf8de53">More...</a><br /></td></tr>
<tr class="memitem:ga62dad9323721a81699d3f7fdca7a9f91" id="r_ga62dad9323721a81699d3f7fdca7a9f91"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga62dad9323721a81699d3f7fdca7a9f91">MagneticFieldError</a> { <a class="el" href="group__errors.html#gga62dad9323721a81699d3f7fdca7a9f91a46dc1018ac1d8fca7c2752a61ce2fd0f">MagneticFieldError::OutOfBounds</a> = 1
, <a class="el" href="group__errors.html#gga62dad9323721a81699d3f7fdca7a9f91a997ca4ce119685f40f03a9a8a6c5346e">MagneticFieldError::NotImplemented</a> = 2
 }</td></tr>
<tr class="memdesc:ga62dad9323721a81699d3f7fdca7a9f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for magnetic field operations.  <a href="group__errors.html#ga62dad9323721a81699d3f7fdca7a9f91">More...</a><br /></td></tr>
<tr class="memitem:aa512dd166058e0512c8c3fb3195bf1f1" id="r_aa512dd166058e0512c8c3fb3195bf1f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1">MappingType</a> { <a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1a4b89096cd32efd26f913e96e61b96e77">PreMapping</a> = -1
, <a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1a879c8d57398ac17a2d7ecaea65021e85">Default</a> = 0
, <a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1ae9a8b8024c5ca45ba5848e8f46dc38fe">PostMapping</a> = 1
, <a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1aaeef76ca06f887c6eb3fcc9d41de53cd">Sensor</a> = 2
 }</td></tr>
<tr class="memdesc:aa512dd166058e0512c8c3fb3195bf1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum describes the type of surface material mapping.  <a href="#aa512dd166058e0512c8c3fb3195bf1f1">More...</a><br /></td></tr>
<tr class="memitem:ab0d37c993fdcfd74f77026bbee8e6d02" id="r_ab0d37c993fdcfd74f77026bbee8e6d02"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02">MaterialUpdateStage</a> : int { <a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02a4d6938dc46ac97dde005fab44a01386c">PreUpdate</a> = -1
, <a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02a6d52930efc1d9c5bdf5424d98f7cd0dd">FullUpdate</a> = 0
, <a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02ad1265336b66d91a1fc4f5904e34591f4">PostUpdate</a> = 1
 }</td></tr>
<tr class="memdesc:ab0d37c993fdcfd74f77026bbee8e6d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a steering enum to tell which material update stage:  <a href="#ab0d37c993fdcfd74f77026bbee8e6d02">More...</a><br /></td></tr>
<tr class="memitem:gaf2646ee646a0b70b9c7ebe6e7f473629" id="r_gaf2646ee646a0b70b9c7ebe6e7f473629"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#gaf2646ee646a0b70b9c7ebe6e7f473629">MultiStepperError</a> { <br />
&#160;&#160;<a class="el" href="group__errors.html#ggaf2646ee646a0b70b9c7ebe6e7f473629a5eaae0a19b450f5e78e7c92df5993ae5">MultiStepperError::ComponentNotOnSurface</a> = 1
, <a class="el" href="group__errors.html#ggaf2646ee646a0b70b9c7ebe6e7f473629acb4aac268e70e319ab0f9c729892e841">MultiStepperError::StateOfMultipleComponentsRequested</a> = 2
, <a class="el" href="group__errors.html#ggaf2646ee646a0b70b9c7ebe6e7f473629aeee15646060f246fb74042fd33493e3e">MultiStepperError::AverageTrackLeftCurrentVolume</a> = 3
, <a class="el" href="group__errors.html#ggaf2646ee646a0b70b9c7ebe6e7f473629a6a7ea3e1e957ceba5dff740af6894cb0">MultiStepperError::AllComponentsSteppingError</a> = 4
, <br />
&#160;&#160;<a class="el" href="group__errors.html#ggaf2646ee646a0b70b9c7ebe6e7f473629a7ac064d72c54b96c24ff6d868012e712">MultiStepperError::AllComponentsConversionToBoundFailed</a> = 5
, <a class="el" href="group__errors.html#ggaf2646ee646a0b70b9c7ebe6e7f473629a0268957bd873958df11f8dd8816d4ce2">MultiStepperError::SomeComponentsConversionToBoundFailed</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:gaf2646ee646a0b70b9c7ebe6e7f473629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for multi-stepper operations.  <a href="group__errors.html#gaf2646ee646a0b70b9c7ebe6e7f473629">More...</a><br /></td></tr>
<tr class="memitem:ga2cc876d4889b5c6656ed7d5e0c1fca19" id="r_ga2cc876d4889b5c6656ed7d5e0c1fca19"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga2cc876d4889b5c6656ed7d5e0c1fca19">NavigatorError</a> { <a class="el" href="group__errors.html#gga2cc876d4889b5c6656ed7d5e0c1fca19a77fd0ff5599a44c8cd17ffb15f2de120">NavigatorError::NotInsideExpectedVolume</a> = 1
, <a class="el" href="group__errors.html#gga2cc876d4889b5c6656ed7d5e0c1fca19a7d447f6eb40d640d8d86a78220a2c96a">NavigatorError::NotOnExpectedSurface</a> = 2
 }</td></tr>
<tr class="memdesc:ga2cc876d4889b5c6656ed7d5e0c1fca19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for navigator operations.  <a href="group__errors.html#ga2cc876d4889b5c6656ed7d5e0c1fca19">More...</a><br /></td></tr>
<tr class="memitem:ae866cb8853468d56eec07abde7529017" id="r_ae866cb8853468d56eec07abde7529017"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae866cb8853468d56eec07abde7529017">NoiseUpdateMode</a> : int { <a class="el" href="#ae866cb8853468d56eec07abde7529017a6cead0401bac5c1c67415a40ec3e6ef8">removeNoise</a> = -1
, <a class="el" href="#ae866cb8853468d56eec07abde7529017a524abb48de7322499dcaefc3f1703f41">addNoise</a> = 1
 }</td></tr>
<tr class="memdesc:ae866cb8853468d56eec07abde7529017"><td class="mdescLeft">&#160;</td><td class="mdescRight">to tell how to deal with noise term in covariance transport  <a href="#ae866cb8853468d56eec07abde7529017">More...</a><br /></td></tr>
<tr class="memitem:a9be1c6a7aba3d2c58133f9f2f10db45a" id="r_a9be1c6a7aba3d2c58133f9f2f10db45a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> : std::int32_t { <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa13a6d0b0ebf11ef63492283b62f06980">eInvalid</a> = 0
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa37d22ad8c1c4d8f9978fb361dc0afd97">eElectron</a> = 11
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa7ad9d5e84f03e12c6975bd9d777b2bae">eAntiElectron</a> = -eElectron
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa2fb00d1e473c1551df098fbec5799821">ePositron</a> = -eElectron
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aabd17e2bdce82e55f45068a7d2b2f9b7d">eMuon</a> = 13
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa54358b25b4d27f147aca846e51ebcd64">eAntiMuon</a> = -eMuon
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa98d074094e790340c26424143eed5027">eTau</a> = 15
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aaa4c0641c077f3dd69c074c61e32f6aa0">eAntiTau</a> = -eTau
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa93b2449a6d5111598190a4c5ee9aa9f4">eGamma</a> = 22
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aaf1358b190ecf758556ccc6487184f6d0">ePionZero</a> = 111
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aaf08fabfa0dde26e4cc054f5628edf9da">ePionPlus</a> = 211
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa3540c2184257b4bb0fbfabf3d04a6703">ePionMinus</a> = -ePionPlus
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aacae7f3de2b60dfc8d6d8bff99a7d5992">eKaonPlus</a> = 321
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa9f390790c94434763ff0a21a3543c1b2">eKaonMinus</a> = -eKaonPlus
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa53098b2a6aa14ce2fa1d6d0a6850ebd2">eNeutron</a> = 2112
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa2887b3f033a578994325bd49bd918b16">eAntiNeutron</a> = -eNeutron
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aadaa2c708e4438ed9b8c0146c5c2e7b47">eProton</a> = 2212
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aaffdb7d1ac82a29b8a83b4356f2302a1a">eAntiProton</a> = -eProton
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa2c1d791271000b6be35a03f5174fc05c">eLead</a> = 1000822080
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aae10b772b24a08619b6fac59a704cffc3">eJPsi</a> = 443
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa8f0bbf2aca73f4ace66a179b8f4a69e7">eB0</a> = 511
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aadbf51e07b8eb6e3142922ef908362a87">eBPlus</a> = 521
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aab6968f1400c64c29c7cb6a71885cf301">eD0</a> = 421
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa65e442ad8935aa7f1282d63903279639">eDPlus</a> = 411
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa21c3e8341cb36bb0b70e32c7b6182e60">eAntiB0</a> = -eB0
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aab990975b83ba30997cce3ec1a694aa59">eAntiD0</a> = -eD0
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa349ae6e855149993b77aa6dc43972357">eNeutrinoE</a> = 12
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa7dae5dacbd97034404b762d7f6f6e1af">eNeutrinoMu</a> = 14
, <br />
&#160;&#160;<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aac1c88472c153a63ab704929618b8db94">eNeutrinoTau</a> = 16
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa23ea58bf613804f599e55e53b2317512">eAntiNeutrinoE</a> = -eNeutrinoE
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aaf488ada9f417f7d9bebfbee0311e6723">eAntiNeutrinoMu</a> = -eNeutrinoMu
, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45aa08d9b0340d013b6b8a82c9b2ab1fbe5f">eAntiNeutrinoTau</a> = -eNeutrinoTau
<br />
 }</td></tr>
<tr class="memdesc:a9be1c6a7aba3d2c58133f9f2f10db45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic values for commonly used PDG particle numbers.  <a href="#a9be1c6a7aba3d2c58133f9f2f10db45a">More...</a><br /></td></tr>
<tr class="memitem:gad9ea430c0897aa29fcaccb4fa68aa459" id="r_gad9ea430c0897aa29fcaccb4fa68aa459"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#gad9ea430c0897aa29fcaccb4fa68aa459">PortalError</a> { <a class="el" href="group__errors.html#ggad9ea430c0897aa29fcaccb4fa68aa459a2fb2d2aa3fefe80d75ca568b29f43bb1">PortalError::PositionNotOnAnyChildPortalLink</a> = 1
 }</td></tr>
<tr class="memdesc:gad9ea430c0897aa29fcaccb4fa68aa459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for portal operations.  <a href="group__errors.html#gad9ea430c0897aa29fcaccb4fa68aa459">More...</a><br /></td></tr>
<tr class="memitem:gae4af8513760690d2518f3e01355beb88" id="r_gae4af8513760690d2518f3e01355beb88"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#gae4af8513760690d2518f3e01355beb88">PropagatorError</a> { <a class="el" href="group__errors.html#ggae4af8513760690d2518f3e01355beb88ae139a585510a502bbf1841cf589f5086">PropagatorError::Failure</a> = 1
, <a class="el" href="group__errors.html#ggae4af8513760690d2518f3e01355beb88a1b43b4fba722947169471747934a6740">PropagatorError::StepCountLimitReached</a>
, <a class="el" href="group__errors.html#ggae4af8513760690d2518f3e01355beb88ae26e9cd0f7d932b1121993fe395d2195">PropagatorError::NextTargetLimitReached</a>
 }</td></tr>
<tr class="memdesc:gae4af8513760690d2518f3e01355beb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for propagator operations.  <a href="group__errors.html#gae4af8513760690d2518f3e01355beb88">More...</a><br /></td></tr>
<tr class="memitem:ad71ecb37457c7761afe0fea9e203d05b" id="r_ad71ecb37457c7761afe0fea9e203d05b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad71ecb37457c7761afe0fea9e203d05b">PropagatorStage</a> { <br />
&#160;&#160;<a class="el" href="#ad71ecb37457c7761afe0fea9e203d05bafedb2d84cafe20862cb4399751a8a7e3">invalid</a>
, <a class="el" href="#ad71ecb37457c7761afe0fea9e203d05baefeca9e9053d4d39ed0a7b73b04d076a">prePropagation</a>
, <a class="el" href="#ad71ecb37457c7761afe0fea9e203d05ba3b5645e433f7f9bc6947d24d27d87ed7">postPropagation</a>
, <a class="el" href="#ad71ecb37457c7761afe0fea9e203d05baac36043718849057413af081e5880a60">preStep</a>
, <br />
&#160;&#160;<a class="el" href="#ad71ecb37457c7761afe0fea9e203d05ba6611d3ea55ba2b9a3c8daeec0e77a35f">postStep</a>
<br />
 }</td></tr>
<tr class="memdesc:ad71ecb37457c7761afe0fea9e203d05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different stages during propagation.  <a href="#ad71ecb37457c7761afe0fea9e203d05b">More...</a><br /></td></tr>
<tr class="memitem:a71eb0dc21ee83a011a86dbd801338057" id="r_a71eb0dc21ee83a011a86dbd801338057"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71eb0dc21ee83a011a86dbd801338057">SpacePointCandidateType</a> : short { <a class="el" href="#a71eb0dc21ee83a011a86dbd801338057a776f50b8d2af1233e8900eb42f93adab">eBottom</a>
, <a class="el" href="#a71eb0dc21ee83a011a86dbd801338057ae64af3a3ced78854860e9eccf0322873">eTop</a>
 }</td></tr>
<tr class="memdesc:a71eb0dc21ee83a011a86dbd801338057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of space point candidates for seeding.  <a href="#a71eb0dc21ee83a011a86dbd801338057">More...</a><br /></td></tr>
<tr class="memitem:a7a6813a649567fb613b8214ad5e7399c" id="r_a7a6813a649567fb613b8214ad5e7399c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a6813a649567fb613b8214ad5e7399c">SpacePointColumns</a> : std::uint32_t { <br />
&#160;&#160;<a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca3084fee3544f80ff6a40e639984e89f9">SourceLinks</a> = 1 &lt;&lt; 0
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca02129bb861061d1a052c592e2dc6b383">X</a> = 1 &lt;&lt; 1
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca57cec4137b614c87cb4e24a3d003a3e0">Y</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca21c2e59531c8710156d34a3c30ac81d5">Z</a> = 1 &lt;&lt; 3
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399cae1e1d3d40573127e9ee0480caf1283d6">R</a> = 1 &lt;&lt; 4
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca5a82bece4586ad7cb17ba739a2db7f67">Phi</a> = 1 &lt;&lt; 5
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399caa76d4ef5f3f6a672bbfab2865563e530">Time</a> = 1 &lt;&lt; 6
, <br />
&#160;&#160;<a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca40d203bf0d98e07fc2dfbf12d880b13b">VarianceZ</a> = 1 &lt;&lt; 7
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca72bb52f0a15dd8981987d49e5e306c31">VarianceR</a> = 1 &lt;&lt; 8
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca3fa9ae8939cd9d4e3d80ba71a28ea27d">TopStripVector</a> = 1 &lt;&lt; 9
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca08e690ae1ee43bbbf2fd36c5f78e9b13">BottomStripVector</a> = 1 &lt;&lt; 10
, <br />
&#160;&#160;<a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca60970c94d2fa3ff8904f6ee13a88c506">StripCenterDistance</a> = 1 &lt;&lt; 11
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca3496d756018104f2c4ed750e892621d0">TopStripCenter</a> = 1 &lt;&lt; 12
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399cab64faa7d3e7fdfda97f3cf4ebb2ccbe8">CopyFromIndex</a> = 1 &lt;&lt; 13
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca74c53bcd3dcb2bb79993b2fec37d362a">XY</a> = 1 &lt;&lt; 14
, <br />
&#160;&#160;<a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca50390e75aac138ff69bd26a338e042a4">ZR</a> = 1 &lt;&lt; 15
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399cae65075d550f9b5bf9992fa1d71a131be">XYZ</a> = 1 &lt;&lt; 16
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399cadcebc0530c8af8d1c3ba8511b85e17f9">XYZR</a> = 1 &lt;&lt; 17
, <a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca3aaf7978eaca2bad55d906b6f6d57f37">VarianceZR</a> = 1 &lt;&lt; 18
, <br />
&#160;&#160;<a class="el" href="#a7a6813a649567fb613b8214ad5e7399ca031b9e77f5c85a66723c832a06ba2735">Strip</a>
<br />
 }</td></tr>
<tr class="memitem:ga15d42dcaa6c43d68f6d711f04f9594bd" id="r_ga15d42dcaa6c43d68f6d711f04f9594bd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga15d42dcaa6c43d68f6d711f04f9594bd">SpacePointFormationError</a> { <br />
&#160;&#160;<a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bda59498ee016767b03b39eb220b31f8ef0">SpacePointFormationError::ClusterPairDistanceExceeded</a> = 1
, <a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bdade8af8f801c3abfe52aee93e9a927452">SpacePointFormationError::ClusterPairThetaDistanceExceeded</a> = 2
, <a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bda467960d2bf6d66ed0188b57b8f9d6dc3">SpacePointFormationError::ClusterPairPhiDistanceExceeded</a> = 3
, <a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bda389044e77222f05ac507da372e64fc4f">SpacePointFormationError::CosmicToleranceNotMet</a> = 4
, <br />
&#160;&#160;<a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bda6aa0b7866598ceff6309c52acabd105d">SpacePointFormationError::OutsideLimits</a> = 5
, <a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bda40e84eb6404c960f5004dcd0fe1394c1">SpacePointFormationError::OutsideRelaxedLimits</a> = 6
, <a class="el" href="group__errors.html#gga15d42dcaa6c43d68f6d711f04f9594bdaa803f77097064e7f7ce933bc02415134">SpacePointFormationError::NoSolutionFound</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:ga15d42dcaa6c43d68f6d711f04f9594bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for space point formation operations.  <a href="group__errors.html#ga15d42dcaa6c43d68f6d711f04f9594bd">More...</a><br /></td></tr>
<tr class="memitem:gac32894235c42ab9d5e6bf5c5cd1f6f3d" id="r_gac32894235c42ab9d5e6bf5c5cd1f6f3d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#gac32894235c42ab9d5e6bf5c5cd1f6f3d">SurfaceError</a> { <a class="el" href="group__errors.html#ggac32894235c42ab9d5e6bf5c5cd1f6f3dae3446c971b61f402878421556af2d52c">SurfaceError::GlobalPositionNotOnSurface</a> = 1
 }</td></tr>
<tr class="memdesc:gac32894235c42ab9d5e6bf5c5cd1f6f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for surface operations.  <a href="group__errors.html#gac32894235c42ab9d5e6bf5c5cd1f6f3d">More...</a><br /></td></tr>
<tr class="memitem:ga6a0e61fbedc5e6713e2830a03af01032" id="r_ga6a0e61fbedc5e6713e2830a03af01032"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga6a0e61fbedc5e6713e2830a03af01032">TrackExtrapolationError</a> { <a class="el" href="group__errors.html#gga6a0e61fbedc5e6713e2830a03af01032ab6bd1ff221b63b4603c92c095bfd0339">TrackExtrapolationError::CompatibleTrackStateNotFound</a> = 1
, <a class="el" href="group__errors.html#gga6a0e61fbedc5e6713e2830a03af01032a01e340a582a939ceb8a9e86cf879b029">TrackExtrapolationError::ReferenceSurfaceUnreachable</a> = 2
 }</td></tr>
<tr class="memdesc:ga6a0e61fbedc5e6713e2830a03af01032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for track extrapolation operations.  <a href="group__errors.html#ga6a0e61fbedc5e6713e2830a03af01032">More...</a><br /></td></tr>
<tr class="memitem:a086febf882ea487434374ef548a90661" id="r_a086febf882ea487434374ef548a90661"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a> { <a class="el" href="#a086febf882ea487434374ef548a90661a8b04d5e3775d298e78455efc5ca404d5">first</a>
, <a class="el" href="#a086febf882ea487434374ef548a90661a98bd1c45684cf587ac2347a92dd7bb51">last</a>
, <a class="el" href="#a086febf882ea487434374ef548a90661a6fc382933a0480bdfa5eb85b743e3018">firstOrLast</a>
 }</td></tr>
<tr class="memdesc:a086febf882ea487434374ef548a90661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy for track extrapolation to target surface.  <a href="#a086febf882ea487434374ef548a90661">More...</a><br /></td></tr>
<tr class="memitem:a4cc469694ff29fb3f7c7128ad09264a4" id="r_a4cc469694ff29fb3f7c7128ad09264a4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4">TrackStateFlag</a> { <br />
&#160;&#160;<a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a61c2d35b2b78000035892533a0d84c1b">MeasurementFlag</a> = 0
, <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a05c96f3f141ed07147a10e824053defe">ParameterFlag</a> = 1
, <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a8ea62dde4ffd73859274aa60475ed51e">OutlierFlag</a> = 2
, <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a4b4d351fff1cc5c67b8bc0fb8b0fa68b">HoleFlag</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a12593f1e94d940cd98d868507e14bcaa">MaterialFlag</a> = 4
, <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4af521a474f0c773060e30ea91d0d52524">SharedHitFlag</a> = 5
, <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a7371bfebbf5ce839fbf93e44466b24ee">SplitHitFlag</a> = 6
, <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a57fea0596d2e3beed9a65b9569fe9496">NoExpectedHitFlag</a> = 7
, <br />
&#160;&#160;<a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4a22052cbf9db3a1ac37c9ed360acbc6ee">NumTrackStateFlags</a> = 8
<br />
 }</td></tr>
<tr class="memdesc:a4cc469694ff29fb3f7c7128ad09264a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum describes the type of TrackState.  <a href="#a4cc469694ff29fb3f7c7128ad09264a4">More...</a><br /></td></tr>
<tr class="memitem:ac57de10a165c0a56408fd3de93e013e2" id="r_ac57de10a165c0a56408fd3de93e013e2"><td class="memItemLeft" align="right" valign="top">enum struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> : std::uint8_t { <br />
&#160;&#160;<a class="el" href="#ac57de10a165c0a56408fd3de93e013e2a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2a015e111693f10da4f3fc32814a41e7ad">Predicted</a> = 1 &lt;&lt; 0
, <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2afe84ed3d6baffd193df85d308e5e908c">Filtered</a> = 1 &lt;&lt; 1
, <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2ac5d48c613aa395e2f92d06e97b85aa97">Smoothed</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="#ac57de10a165c0a56408fd3de93e013e2ae54aa0f510685bd0be4cbe3750fa7fc5">Jacobian</a> = 1 &lt;&lt; 3
, <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2aa4002a60656b604f448b7794842c8fb4">Calibrated</a> = 1 &lt;&lt; 4
, <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">All</a> = std::numeric_limits&lt;std::uint8_t&gt;::max()
<br />
 }</td></tr>
<tr class="memdesc:ac57de10a165c0a56408fd3de93e013e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of bit masks to enable steering which components of a track state should be initialized, and which should be left invalid.  <a href="#ac57de10a165c0a56408fd3de93e013e2">More...</a><br /></td></tr>
<tr class="memitem:ga1f61f3856fa7ffded6d06723801cf8e6" id="r_ga1f61f3856fa7ffded6d06723801cf8e6"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__errors.html#ga1f61f3856fa7ffded6d06723801cf8e6">VertexingError</a> { <br />
&#160;&#160;<a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6a86ee367cb35b917fcebcb19bbfe6bf93">VertexingError::NumericFailure</a> = 1
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6ace1e7d82baa32665deec88097ce70f3e">VertexingError::EmptyInput</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6ab56f3a5e1762955a164fd9ef356395d6">VertexingError::SeedingError</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6adbbde5ea220b09db210c62e8926a02c5">VertexingError::NotConverged</a>
, <br />
&#160;&#160;<a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6a673139bdc2587ecbe62795a58e6210f6">VertexingError::ElementNotFound</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6aaccd0c2127ab1e6f988b33e690715462">VertexingError::NoCovariance</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6ade2e45aece7bcbb9fe7540cc9e11c40f">VertexingError::SingularMatrix</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6a8aa64b33a3ad296b27c7ae99f16a091e">VertexingError::NonPositiveVariance</a>
, <br />
&#160;&#160;<a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6a4ae16931882a9e9f8225c7480a468438">VertexingError::MatrixNotPositiveDefinite</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6ad8f78ca9a692a9411afbc7584b69d043">VertexingError::InvalidInput</a>
, <a class="el" href="group__errors.html#gga1f61f3856fa7ffded6d06723801cf8e6ab14502cfd96d47cdc55f055e7114a105">VertexingError::CouldNotRemoveTrack</a>
<br />
 }</td></tr>
<tr class="memdesc:ga1f61f3856fa7ffded6d06723801cf8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for vertexing operations.  <a href="group__errors.html#ga1f61f3856fa7ffded6d06723801cf8e6">More...</a><br /></td></tr>
<tr class="memitem:a281bb3932c0b5a0fb38fdab58f043848" id="r_a281bb3932c0b5a0fb38fdab58f043848"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848">VolumeAttachmentStrategy</a> { <a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848a7fb55ed0b7a30342ba6da306428cae04">First</a>
, <a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848ac22cf8376b1893dcfcef0649fe1a7d87">Second</a>
, <a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848a7f56c02b34d312867e3f63c9f21fe5c8">Midpoint</a>
, <a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848a466b98ca0f38bd8bf2260246c91f6882">Gap</a>
 }</td></tr>
<tr class="memdesc:a281bb3932c0b5a0fb38fdab58f043848"><td class="mdescLeft">&#160;</td><td class="mdescRight">The attachment strategy defines how the volumes are attached Attachment always happens pair-wise.  <a href="#a281bb3932c0b5a0fb38fdab58f043848">More...</a><br /></td></tr>
<tr class="memitem:a8e7b9ba567f3fce3fb39c1c9ce093e93" id="r_a8e7b9ba567f3fce3fb39c1c9ce093e93"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e7b9ba567f3fce3fb39c1c9ce093e93">VolumeResizeStrategy</a> { <a class="el" href="#a8e7b9ba567f3fce3fb39c1c9ce093e93a8098b34f582537833b36b58273c3545b">Expand</a>
, <a class="el" href="#a8e7b9ba567f3fce3fb39c1c9ce093e93a466b98ca0f38bd8bf2260246c91f6882">Gap</a>
 }</td></tr>
<tr class="memdesc:a8e7b9ba567f3fce3fb39c1c9ce093e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resize strategy defines how the volumes are resized.  <a href="#a8e7b9ba567f3fce3fb39c1c9ce093e93">More...</a><br /></td></tr>
<tr class="memitem:ac067c47704bdb1b88dd0c21c0e8fd8c2" id="r_ac067c47704bdb1b88dd0c21c0e8fd8c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2">WrappingCondition</a> { <br />
&#160;&#160;<a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2a343ba1ac75989650550b2f56e557113c">Undefined</a> = 0
, <a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2ac4b9fe4314b7cc00ea9953d6d2f1ec05">Attaching</a> = 1
, <a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2a32e361fc46c1b1b2d1d4c4698c9337f0">Inserting</a> = 2
, <a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2a650eda96ea9b43a530919bf0a5210d38">Wrapping</a> = 3
, <br />
&#160;&#160;<a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2a5b7bdfc822b40c4f237c1d376172945a">CentralInserting</a> = 4
, <a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2acc7765cc3777a384b6a9a93f4cc140f8">CentralWrapping</a> = 5
, <a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2a8d9c18bc517435f25750e460525b60e7">NoWrapping</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:ac067c47704bdb1b88dd0c21c0e8fd8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume wrapping conditions for cylinder volume building.  <a href="#ac067c47704bdb1b88dd0c21c0e8fd8c2">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aee44b83052f88cd1f6fe38ad464439d0" id="r_aee44b83052f88cd1f6fe38ad464439d0"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aee44b83052f88cd1f6fe38ad464439d0 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee44b83052f88cd1f6fe38ad464439d0">abs</a> (const T n)</td></tr>
<tr class="memdesc:aee44b83052f88cd1f6fe38ad464439d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute of a number (Can be removed for c++ 23).  <br /></td></tr>
<tr class="memitem:a07cc9c5a52b7ad024117cee0d1dd664f" id="r_a07cc9c5a52b7ad024117cee0d1dd664f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07cc9c5a52b7ad024117cee0d1dd664f">ACTS_DEFINE_ENUM_BITWISE_OPERATORS</a> (<a class="el" href="#a7a6813a649567fb613b8214ad5e7399c">SpacePointColumns</a>)</td></tr>
<tr class="memitem:a7e485245a070df5a95f113e9ada82f40" id="r_a7e485245a070df5a95f113e9ada82f40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e485245a070df5a95f113e9ada82f40">addBoundParameters</a> (const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;lhs, const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a7e485245a070df5a95f113e9ada82f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add bound parameters and take care of angle periodicity for phi and theta.  <br /></td></tr>
<tr class="memitem:ac693aa8941b4cbb04d9fda037650199a" id="r_ac693aa8941b4cbb04d9fda037650199a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac693aa8941b4cbb04d9fda037650199a">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_cuboid_volume_bounds.html">CuboidVolumeBounds</a> &amp;cBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:ac693aa8941b4cbb04d9fda037650199a"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of cuboid volume bounds  <br /></td></tr>
<tr class="memitem:a29c8e88a9e25c5f72ee73239695a6e66" id="r_a29c8e88a9e25c5f72ee73239695a6e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c8e88a9e25c5f72ee73239695a6e66">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_cutout_cylinder_volume_bounds.html">CutoutCylinderVolumeBounds</a> &amp;cBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:a29c8e88a9e25c5f72ee73239695a6e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of cutout cylinder volume bounds  <br /></td></tr>
<tr class="memitem:a00c1bda0e98b2e133600784dbb185048" id="r_a00c1bda0e98b2e133600784dbb185048"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00c1bda0e98b2e133600784dbb185048">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_cylinder_bounds.html">CylinderBounds</a> &amp;cBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:a00c1bda0e98b2e133600784dbb185048"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of cylinder bounds  <br /></td></tr>
<tr class="memitem:a15aee0a999a8184c1d937d20290661d4" id="r_a15aee0a999a8184c1d937d20290661d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15aee0a999a8184c1d937d20290661d4">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_cylinder_volume_bounds.html">CylinderVolumeBounds</a> &amp;cBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:a15aee0a999a8184c1d937d20290661d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of cylinder volume bounds  <br /></td></tr>
<tr class="memitem:ac017c44f5305e61ef807eb2da620ba89" id="r_ac017c44f5305e61ef807eb2da620ba89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac017c44f5305e61ef807eb2da620ba89">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_radial_bounds.html">RadialBounds</a> &amp;rBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:ac017c44f5305e61ef807eb2da620ba89"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of radial bounds  <br /></td></tr>
<tr class="memitem:a83a4f6fbbc917b45e62349df43858f83" id="r_a83a4f6fbbc917b45e62349df43858f83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83a4f6fbbc917b45e62349df43858f83">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_rectangle_bounds.html">RectangleBounds</a> &amp;pBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:a83a4f6fbbc917b45e62349df43858f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of plane bounds  <br /></td></tr>
<tr class="memitem:af4d9c22f5aa9a180415576374f06da6e" id="r_af4d9c22f5aa9a180415576374f06da6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4d9c22f5aa9a180415576374f06da6e">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx)</td></tr>
<tr class="memdesc:af4d9c22f5aa9a180415576374f06da6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to a surface  <br /></td></tr>
<tr class="memitem:af203de69e977c5ee39b61a19a6118f34" id="r_af203de69e977c5ee39b61a19a6118f34"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af203de69e977c5ee39b61a19a6118f34">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_trapezoid_bounds.html">TrapezoidBounds</a> &amp;pBounds, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform)</td></tr>
<tr class="memdesc:af203de69e977c5ee39b61a19a6118f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to the dimensions of plane bounds  <br /></td></tr>
<tr class="memitem:a03a1428acbabf53542cf3f5b41d3f35f" id="r_a03a1428acbabf53542cf3f5b41d3f35f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a1428acbabf53542cf3f5b41d3f35f">adjustBinUtility</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu, const <a class="el" href="class_acts_1_1_volume.html">Volume</a> &amp;volume)</td></tr>
<tr class="memdesc:a03a1428acbabf53542cf3f5b41d3f35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust the BinUtility bu to a volume  <br /></td></tr>
<tr class="memitem:a307086a9afc40c3a9b019463924cb098" id="r_a307086a9afc40c3a9b019463924cb098"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307086a9afc40c3a9b019463924cb098">allAxisDirections</a> ()</td></tr>
<tr class="memdesc:a307086a9afc40c3a9b019463924cb098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all possible axis directions.  <br /></td></tr>
<tr class="memitem:a64261b76df37073220040fe3fa8b1db9" id="r_a64261b76df37073220040fe3fa8b1db9"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Axes&gt; </td></tr>
<tr class="memitem:a64261b76df37073220040fe3fa8b1db9 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64261b76df37073220040fe3fa8b1db9">AnyGridConstView</a> (const <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; T, Axes... &gt; &amp;grid) -&gt; AnyGridConstView&lt; T &gt;</td></tr>
<tr class="memdesc:a64261b76df37073220040fe3fa8b1db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for AnyGridConstView from const Grid.  <br /></td></tr>
<tr class="memitem:adaeded646732245db32f202c44527534" id="r_adaeded646732245db32f202c44527534"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Axes&gt; </td></tr>
<tr class="memitem:adaeded646732245db32f202c44527534 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaeded646732245db32f202c44527534">AnyGridView</a> (<a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; T, Axes... &gt; &amp;grid) -&gt; AnyGridView&lt; T &gt;</td></tr>
<tr class="memdesc:adaeded646732245db32f202c44527534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for AnyGridView from Grid.  <br /></td></tr>
<tr class="memitem:af22a25edcd447beaf9fe79dcf98cd9e6" id="r_af22a25edcd447beaf9fe79dcf98cd9e6"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:af22a25edcd447beaf9fe79dcf98cd9e6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af22a25edcd447beaf9fe79dcf98cd9e6">applyReferenceExpansion</a> (std::vector&lt; typename grid_type::point_t &gt; &amp;gridQueries, const std::vector&lt; double &gt; &amp;referenceExpansion)</td></tr>
<tr class="memdesc:af22a25edcd447beaf9fe79dcf98cd9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the reference expansion.  <br /></td></tr>
<tr class="memitem:a692f3bf198b75679e1051ae422c41869" id="r_a692f3bf198b75679e1051ae422c41869"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a692f3bf198b75679e1051ae422c41869">approximateHighlandScattering</a> (float xOverX0)</td></tr>
<tr class="memdesc:a692f3bf198b75679e1051ae422c41869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximate the core width of the projected planar scattering distribution with highland's formula.  <br /></td></tr>
<tr class="memitem:a1a37b45a601496b2b6a31387897c1e5a" id="r_a1a37b45a601496b2b6a31387897c1e5a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a> bdt&gt; </td></tr>
<tr class="memitem:a1a37b45a601496b2b6a31387897c1e5a template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a37b45a601496b2b6a31387897c1e5a">Axis</a> (<a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt; bdt &gt;, double min, double max, std::size_t bins) -&gt; Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a>, bdt &gt;</td></tr>
<tr class="memdesc:a1a37b45a601496b2b6a31387897c1e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for equidistant axis with specified boundary type.  <br /></td></tr>
<tr class="memitem:aed5a20ef25d66a3e59792f2086fa2066" id="r_aed5a20ef25d66a3e59792f2086fa2066"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a> bdt&gt; </td></tr>
<tr class="memitem:aed5a20ef25d66a3e59792f2086fa2066 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed5a20ef25d66a3e59792f2086fa2066">Axis</a> (<a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt; bdt &gt;, std::vector&lt; double &gt; bins) -&gt; Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9">AxisType::Variable</a>, bdt &gt;</td></tr>
<tr class="memdesc:aed5a20ef25d66a3e59792f2086fa2066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for variable axis with specified boundary type.  <br /></td></tr>
<tr class="memitem:a76e099f71248cb4af56fa6535db4881a" id="r_a76e099f71248cb4af56fa6535db4881a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e099f71248cb4af56fa6535db4881a">Axis</a> (double min, double max, std::size_t bins) -&gt; Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a>, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">AxisBoundaryType::Open</a> &gt;</td></tr>
<tr class="memdesc:a76e099f71248cb4af56fa6535db4881a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for equidistant axis with open boundaries.  <br /></td></tr>
<tr class="memitem:a6ddbbb068377c483f127deb5760fd10f" id="r_a6ddbbb068377c483f127deb5760fd10f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ddbbb068377c483f127deb5760fd10f">Axis</a> (std::vector&lt; double &gt; bins) -&gt; Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9">AxisType::Variable</a>, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">AxisBoundaryType::Open</a> &gt;</td></tr>
<tr class="memdesc:a6ddbbb068377c483f127deb5760fd10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for variable axis with open boundaries.  <br /></td></tr>
<tr class="memitem:a64dfd29b7fe0b00e8ac549675044383e" id="r_a64dfd29b7fe0b00e8ac549675044383e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64dfd29b7fe0b00e8ac549675044383e">axisDirectionFromName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a64dfd29b7fe0b00e8ac549675044383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an axis direction from its string name.  <br /></td></tr>
<tr class="memitem:ade6d8e84befdfc830b445832d13cfad6" id="r_ade6d8e84befdfc830b445832d13cfad6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade6d8e84befdfc830b445832d13cfad6">axisDirectionName</a> (<a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> aDir)</td></tr>
<tr class="memdesc:ade6d8e84befdfc830b445832d13cfad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a binning value as a string.  <br /></td></tr>
<tr class="memitem:a2e79325890b007508379e03efeb37a97" id="r_a2e79325890b007508379e03efeb37a97"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a2e79325890b007508379e03efeb37a97 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e79325890b007508379e03efeb37a97">binomial</a> (const T n, const T k)</td></tr>
<tr class="memdesc:a2e79325890b007508379e03efeb37a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the binomial coefficient n n!  <br /></td></tr>
<tr class="memitem:a91dd49594c44c4f09d8f2bce66889672" id="r_a91dd49594c44c4f09d8f2bce66889672"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91dd49594c44c4f09d8f2bce66889672">binSequence</a> (std::array&lt; std::size_t, 2u &gt; minMaxBins, std::size_t <a class="el" href="#a10e8cfcddde31768275e024c61f03a70">expand</a>, std::size_t nBins, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">Acts::AxisBoundaryType</a> <a class="el" href="struct_acts_1_1_remove_pointer.html">type</a>)</td></tr>
<tr class="memdesc:a91dd49594c44c4f09d8f2bce66889672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to generate completely populated bin sequences that respect the boundary type of the axis.  <br /></td></tr>
<tr class="memitem:a1faa0708be032bfc6c3a725525972191" id="r_a1faa0708be032bfc6c3a725525972191"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType&gt; </td></tr>
<tr class="memitem:a1faa0708be032bfc6c3a725525972191 template"><td class="memItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1faa0708be032bfc6c3a725525972191">bitsetToMatrix</a> (const std::bitset&lt; MatrixType::RowsAtCompileTime *MatrixType::ColsAtCompileTime &gt; bs)</td></tr>
<tr class="memdesc:a1faa0708be032bfc6c3a725525972191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bitset to a matrix of integers, with each element set to the bit value.  <br /></td></tr>
<tr class="memitem:a37d4a4f8919f71e49c4136b1a5877125" id="r_a37d4a4f8919f71e49c4136b1a5877125"><td class="memTemplParams" colspan="2">template&lt;typename A, typename B&gt; </td></tr>
<tr class="memitem:a37d4a4f8919f71e49c4136b1a5877125 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; A::RowsAtCompileTime, B::ColsAtCompileTime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d4a4f8919f71e49c4136b1a5877125">blockedMult</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:a37d4a4f8919f71e49c4136b1a5877125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a blocked matrix multiplication, avoiding Eigen GEMM methods.  <br /></td></tr>
<tr class="memitem:a73d5129d1a16a6e63564cdf881a9b647" id="r_a73d5129d1a16a6e63564cdf881a9b647"><td class="memTemplParams" colspan="2">template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:a73d5129d1a16a6e63564cdf881a9b647 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73d5129d1a16a6e63564cdf881a9b647">calculateFilteredChi2</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:a73d5129d1a16a6e63564cdf881a9b647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the filtered chi2.  <br /></td></tr>
<tr class="memitem:a605d198d063b46f931c36b96948e3f7f" id="r_a605d198d063b46f931c36b96948e3f7f"><td class="memTemplParams" colspan="2">template&lt;std::size_t nMeasurementDim, TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:a605d198d063b46f931c36b96948e3f7f template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt; nMeasurementDim &gt;, <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt; nMeasurementDim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605d198d063b46f931c36b96948e3f7f">calculateFilteredResidual</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:a605d198d063b46f931c36b96948e3f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the filtered residual and its covariance.  <br /></td></tr>
<tr class="memitem:adf94b572ac2237a3112a156cfce109ab" id="r_adf94b572ac2237a3112a156cfce109ab"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf94b572ac2237a3112a156cfce109ab">calculateNucleusMass</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:adf94b572ac2237a3112a156cfce109ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the mass of a nucleus using Bethe-Weizsacker formula Parameters obtained from <a href="https://www.actaphys.uj.edu.pl/R/37/6/1833">https://www.actaphys.uj.edu.pl/R/37/6/1833</a>.  <br /></td></tr>
<tr class="memitem:a56a5418f50fb82641b5616441d39dea1" id="r_a56a5418f50fb82641b5616441d39dea1"><td class="memTemplParams" colspan="2">template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:a56a5418f50fb82641b5616441d39dea1 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56a5418f50fb82641b5616441d39dea1">calculatePredictedChi2</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:a56a5418f50fb82641b5616441d39dea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the predicted chi2.  <br /></td></tr>
<tr class="memitem:a912468fb270d9bd53a076eda3ff91d52" id="r_a912468fb270d9bd53a076eda3ff91d52"><td class="memTemplParams" colspan="2">template&lt;std::size_t nMeasurementDim, TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:a912468fb270d9bd53a076eda3ff91d52 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt; nMeasurementDim &gt;, <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt; nMeasurementDim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a912468fb270d9bd53a076eda3ff91d52">calculatePredictedResidual</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:a912468fb270d9bd53a076eda3ff91d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the predicted residual and its covariance.  <br /></td></tr>
<tr class="memitem:ad0961bb226a8e46e32d709866e7eed73" id="r_ad0961bb226a8e46e32d709866e7eed73"><td class="memTemplParams" colspan="2">template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:ad0961bb226a8e46e32d709866e7eed73 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0961bb226a8e46e32d709866e7eed73">calculateSmoothedChi2</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:ad0961bb226a8e46e32d709866e7eed73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the smoothed chi2.  <br /></td></tr>
<tr class="memitem:a5a6a0f03dead89351e61bdd4d0d98dc1" id="r_a5a6a0f03dead89351e61bdd4d0d98dc1"><td class="memTemplParams" colspan="2">template&lt;std::size_t nMeasurementDim, TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:a5a6a0f03dead89351e61bdd4d0d98dc1 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt; nMeasurementDim &gt;, <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt; nMeasurementDim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6a0f03dead89351e61bdd4d0d98dc1">calculateSmoothedResidual</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:a5a6a0f03dead89351e61bdd4d0d98dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the smoothed residual and its covariance.  <br /></td></tr>
<tr class="memitem:ad777051d7e6ab464315ae169472719fe" id="r_ad777051d7e6ab464315ae169472719fe"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</td></tr>
<tr class="memitem:ad777051d7e6ab464315ae169472719fe template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad777051d7e6ab464315ae169472719fe">calculateTrackQuantities</a> (track_proxy_t track)</td></tr>
<tr class="memdesc:ad777051d7e6ab464315ae169472719fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate a number of track level quantities and store them on the track itself.  <br /></td></tr>
<tr class="memitem:afded89f5410ca396ea21fee04cf8d1e2" id="r_afded89f5410ca396ea21fee04cf8d1e2"><td class="memTemplParams" colspan="2">template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </td></tr>
<tr class="memitem:afded89f5410ca396ea21fee04cf8d1e2 template"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>, <a class="el" href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">BoundMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afded89f5410ca396ea21fee04cf8d1e2">calculateUnbiasedParametersCovariance</a> (track_state_proxy_t trackState)</td></tr>
<tr class="memdesc:afded89f5410ca396ea21fee04cf8d1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to calculate the unbiased track parameters and their covariance (i.e.  <br /></td></tr>
<tr class="memitem:adca167882d01bd6ed5541f83a36031e9" id="r_adca167882d01bd6ed5541f83a36031e9"><td class="memTemplParams" colspan="2">template&lt;std::ranges::sized_range index_range_t&gt; </td></tr>
<tr class="memitem:adca167882d01bd6ed5541f83a36031e9 template"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adca167882d01bd6ed5541f83a36031e9">checkSubspaceIndices</a> (const index_range_t &amp;indexRange, std::size_t fullSize, std::size_t subspaceSize)</td></tr>
<tr class="memdesc:adca167882d01bd6ed5541f83a36031e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check subspace indices for consistency.  <br /></td></tr>
<tr class="memitem:a171b9272b990cb467e1e15f36638604e" id="r_a171b9272b990cb467e1e15f36638604e"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U&gt; </td></tr>
<tr class="memitem:a171b9272b990cb467e1e15f36638604e template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a171b9272b990cb467e1e15f36638604e">clampValue</a> (U value)</td></tr>
<tr class="memdesc:a171b9272b990cb467e1e15f36638604e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clamp a numeric value to another type, respecting range of the target type.  <br /></td></tr>
<tr class="memitem:a7969e3bd01832c6be8de5ef2c3e070ef" id="r_a7969e3bd01832c6be8de5ef2c3e070ef"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7969e3bd01832c6be8de5ef2c3e070ef">computeEnergyLossBethe</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a7969e3bd01832c6be8de5ef2c3e070ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean energy loss due to ionisation and excitation.  <br /></td></tr>
<tr class="memitem:aeb22670d2e2303ba2854c2169aa08608" id="r_aeb22670d2e2303ba2854c2169aa08608"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb22670d2e2303ba2854c2169aa08608">computeEnergyLossLandau</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:aeb22670d2e2303ba2854c2169aa08608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the most probable energy loss due to ionisation and excitation.  <br /></td></tr>
<tr class="memitem:aad4db30b6dc42d8043e312d4936ced86" id="r_aad4db30b6dc42d8043e312d4936ced86"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad4db30b6dc42d8043e312d4936ced86">computeEnergyLossLandauFwhm</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:aad4db30b6dc42d8043e312d4936ced86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the full with half maximum of landau energy loss distribution.  <br /></td></tr>
<tr class="memitem:a5e47e30202dec06addb9c315a0b7d674" id="r_a5e47e30202dec06addb9c315a0b7d674"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e47e30202dec06addb9c315a0b7d674">computeEnergyLossLandauSigma</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a5e47e30202dec06addb9c315a0b7d674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Gaussian-equivalent sigma for the ionisation loss fluctuations.  <br /></td></tr>
<tr class="memitem:ae16ecda47ec9e373b988bb80f0bd7ef3" id="r_ae16ecda47ec9e373b988bb80f0bd7ef3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae16ecda47ec9e373b988bb80f0bd7ef3">computeEnergyLossLandauSigmaQOverP</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:ae16ecda47ec9e373b988bb80f0bd7ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute q/p Gaussian-equivalent sigma due to ionisation loss fluctuations.  <br /></td></tr>
<tr class="memitem:a87160e91db5e1f254b03ea77a3e67775" id="r_a87160e91db5e1f254b03ea77a3e67775"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87160e91db5e1f254b03ea77a3e67775">computeEnergyLossMean</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a87160e91db5e1f254b03ea77a3e67775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the combined mean energy loss.  <br /></td></tr>
<tr class="memitem:acece53e8206433adba38168d0458c746" id="r_acece53e8206433adba38168d0458c746"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acece53e8206433adba38168d0458c746">computeEnergyLossMode</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:acece53e8206433adba38168d0458c746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the combined most probably energy loss.  <br /></td></tr>
<tr class="memitem:a2ecf42043a08060183625f40fdfb7d5f" id="r_a2ecf42043a08060183625f40fdfb7d5f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ecf42043a08060183625f40fdfb7d5f">computeEnergyLossRadiative</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a2ecf42043a08060183625f40fdfb7d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean energy loss due to radiative effects at high energies.  <br /></td></tr>
<tr class="memitem:a3dabf99c3b7798ef4ea7ec13c13c5795" id="r_a3dabf99c3b7798ef4ea7ec13c13c5795"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dabf99c3b7798ef4ea7ec13c13c5795">computeMultipleScatteringTheta0</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a3dabf99c3b7798ef4ea7ec13c13c5795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the core width of the projected planar scattering distribution.  <br /></td></tr>
<tr class="memitem:a52e4326c57b1b3eadc5a72d2c774bd7e" id="r_a52e4326c57b1b3eadc5a72d2c774bd7e"><td class="memTemplParams" colspan="2">template&lt;typename out_t, typename sign_t&gt; </td></tr>
<tr class="memitem:a52e4326c57b1b3eadc5a72d2c774bd7e template"><td class="memItemLeft" align="right" valign="top">constexpr out_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e4326c57b1b3eadc5a72d2c774bd7e">copySign</a> (const out_t &amp;copyTo, const sign_t &amp;sign)</td></tr>
<tr class="memdesc:a52e4326c57b1b3eadc5a72d2c774bd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the sign of a signed variable onto the copyTo input object Return type &amp; magnitude remain unaffected by this method which allows usage for Vectors &amp; other types providing the - operator.  <br /></td></tr>
<tr class="memitem:a81d1bed89a2a799ac23081b1d1d57a73" id="r_a81d1bed89a2a799ac23081b1d1d57a73"><td class="memTemplParams" colspan="2">template&lt;typename InputVector&gt; </td></tr>
<tr class="memitem:a81d1bed89a2a799ac23081b1d1d57a73 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81d1bed89a2a799ac23081b1d1d57a73">createCurvilinearUnitU</a> (const Eigen::MatrixBase&lt; InputVector &gt; &amp;direction)</td></tr>
<tr class="memdesc:a81d1bed89a2a799ac23081b1d1d57a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the first curvilinear unit vector <span class="tt">U</span> for the given direction.  <br /></td></tr>
<tr class="memitem:aa9f86795ac3702abb070cdae0d706fef" id="r_aa9f86795ac3702abb070cdae0d706fef"><td class="memTemplParams" colspan="2">template&lt;typename InputVector&gt; </td></tr>
<tr class="memitem:aa9f86795ac3702abb070cdae0d706fef template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9f86795ac3702abb070cdae0d706fef">createCurvilinearUnitVectors</a> (const Eigen::MatrixBase&lt; InputVector &gt; &amp;direction)</td></tr>
<tr class="memdesc:aa9f86795ac3702abb070cdae0d706fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the curvilinear unit vectors <span class="tt">U</span> and <span class="tt">V</span> for the given direction.  <br /></td></tr>
<tr class="memitem:acc4fdbb4f35d269522bc19c0d224ec30" id="r_acc4fdbb4f35d269522bc19c0d224ec30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc4fdbb4f35d269522bc19c0d224ec30">createGrid</a> (<a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a> gridAxis1, <a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a> gridAxis2)</td></tr>
<tr class="memdesc:acc4fdbb4f35d269522bc19c0d224ec30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that creates the cache grid for the mapping.  <br /></td></tr>
<tr class="memitem:a085dd4ac5023951306e2309b2605be92" id="r_a085dd4ac5023951306e2309b2605be92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a085dd4ac5023951306e2309b2605be92">createGrid</a> (<a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a> gridAxis1, <a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a> gridAxis2, <a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a> gridAxis3)</td></tr>
<tr class="memdesc:a085dd4ac5023951306e2309b2605be92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that creates the cache grid for the mapping.  <br /></td></tr>
<tr class="memitem:a2ab7a78eb37d8ad1adaeaf04d6d92c92" id="r_a2ab7a78eb37d8ad1adaeaf04d6d92c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ab7a78eb37d8ad1adaeaf04d6d92c92">createGrid2D</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bins, std::function&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>(<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>)&gt; &amp;transfoGlobalToLocal)</td></tr>
<tr class="memdesc:a2ab7a78eb37d8ad1adaeaf04d6d92c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 2DGrid using a BinUtility.  <br /></td></tr>
<tr class="memitem:ae92c97bfcfa43c9625c931928128a992" id="r_ae92c97bfcfa43c9625c931928128a992"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae92c97bfcfa43c9625c931928128a992">createGrid3D</a> (const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bins, std::function&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>(<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>)&gt; &amp;transfoGlobalToLocal)</td></tr>
<tr class="memdesc:ae92c97bfcfa43c9625c931928128a992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a 3DGrid using a BinUtility.  <br /></td></tr>
<tr class="memitem:gaee816f677b99eb0cbeb1d35a580cc391" id="r_gaee816f677b99eb0cbeb1d35a580cc391"><td class="memTemplParams" colspan="2">template&lt;class T, class decorator_t&gt; </td></tr>
<tr class="memitem:gaee816f677b99eb0cbeb1d35a580cc391 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gaee816f677b99eb0cbeb1d35a580cc391">decorateJson</a> (const decorator_t *decorator, const T &amp;src, nlohmann::json &amp;dest)</td></tr>
<tr class="memitem:gaf82572e503169d94a3cbe03a3a0af6cf" id="r_gaf82572e503169d94a3cbe03a3a0af6cf"><td class="memTemplParams" colspan="2">template&lt;class T, class decorator_t&gt; </td></tr>
<tr class="memitem:gaf82572e503169d94a3cbe03a3a0af6cf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gaf82572e503169d94a3cbe03a3a0af6cf">decorateJson</a> (const decorator_t *decorator, const T *src, nlohmann::json &amp;dest)</td></tr>
<tr class="memitem:ae9377cc8410b61e349e68a4f1d79772b" id="r_ae9377cc8410b61e349e68a4f1d79772b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9377cc8410b61e349e68a4f1d79772b">deriveEnergyLossBetheQOverP</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:ae9377cc8410b61e349e68a4f1d79772b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the Bethe energy loss with respect to q/p.  <br /></td></tr>
<tr class="memitem:ac473b5a1771eb1bd84ad6e44cbde555c" id="r_ac473b5a1771eb1bd84ad6e44cbde555c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac473b5a1771eb1bd84ad6e44cbde555c">deriveEnergyLossLandauQOverP</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:ac473b5a1771eb1bd84ad6e44cbde555c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the most probable ionisation energy loss with respect to q/p.  <br /></td></tr>
<tr class="memitem:a4b9c3ee258cd4e8b1cbdd3ef01f65bac" id="r_a4b9c3ee258cd4e8b1cbdd3ef01f65bac"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b9c3ee258cd4e8b1cbdd3ef01f65bac">deriveEnergyLossMeanQOverP</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a4b9c3ee258cd4e8b1cbdd3ef01f65bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the combined mean energy loss with respect to q/p.  <br /></td></tr>
<tr class="memitem:a3e4407067c869e4f7253adc947e05f4e" id="r_a3e4407067c869e4f7253adc947e05f4e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e4407067c869e4f7253adc947e05f4e">deriveEnergyLossModeQOverP</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a3e4407067c869e4f7253adc947e05f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the combined most probable energy loss with respect to q/p.  <br /></td></tr>
<tr class="memitem:a4d85a7a0670ff1043ead2e43cbc9b132" id="r_a4d85a7a0670ff1043ead2e43cbc9b132"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d85a7a0670ff1043ead2e43cbc9b132">deriveEnergyLossRadiativeQOverP</a> (const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;slab, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> absPdg, float m, float qOverP, float absQ)</td></tr>
<tr class="memdesc:a4d85a7a0670ff1043ead2e43cbc9b132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derivative of the mean radiative energy loss with respect to q/p.  <br /></td></tr>
<tr class="memitem:ae62184077e0f01971fe35cb00b8cb20c" id="r_ae62184077e0f01971fe35cb00b8cb20c"><td class="memTemplParams" colspan="2">template&lt;std::size_t FullSize&gt; <br />
requires (FullSize &lt;= 8)</td></tr>
<tr class="memitem:ae62184077e0f01971fe35cb00b8cb20c template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; FullSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae62184077e0f01971fe35cb00b8cb20c">deserializeSubspaceIndices</a> (<a class="el" href="#ac7fe124c6f6fda8fa31781f93cbd36b8">SerializedSubspaceIndices</a> serialized)</td></tr>
<tr class="memdesc:ae62184077e0f01971fe35cb00b8cb20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize subspace indices from a single 64 bit integer.  <br /></td></tr>
<tr class="memitem:a08a2ca0bdef285b222916dd7ecb30562" id="r_a08a2ca0bdef285b222916dd7ecb30562"><td class="memTemplParams" colspan="2">template&lt;typename container_type, typename index_type = typename std::decay_t&lt;container_type&gt;::size_type, typename container_type_iter = decltype(std::begin(std::declval&lt;container_type&gt;())), typename = decltype(std::end(std::declval&lt;container_type&gt;()))&gt; </td></tr>
<tr class="memitem:a08a2ca0bdef285b222916dd7ecb30562 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08a2ca0bdef285b222916dd7ecb30562">enumerate</a> (container_type &amp;&amp;iterable)</td></tr>
<tr class="memdesc:a08a2ca0bdef285b222916dd7ecb30562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to allow indexed enumeration with structured binding.  <br /></td></tr>
<tr class="memitem:a41ce01de709daded7eca97fac1268093" id="r_a41ce01de709daded7eca97fac1268093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">BoundMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41ce01de709daded7eca97fac1268093">estimateTrackParamCovariance</a> (const <a class="el" href="struct_acts_1_1_estimate_track_param_covariance_config.html">EstimateTrackParamCovarianceConfig</a> &amp;config, const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;params, bool hasTime)</td></tr>
<tr class="memdesc:a41ce01de709daded7eca97fac1268093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the covariance matrix of the given track parameters based on the provided configuration.  <br /></td></tr>
<tr class="memitem:a6993b7c73820f46cd3c74271787accb8" id="r_a6993b7c73820f46cd3c74271787accb8"><td class="memTemplParams" colspan="2">template&lt;std::ranges::range spacepoint_range_t&gt; </td></tr>
<tr class="memitem:a6993b7c73820f46cd3c74271787accb8 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6993b7c73820f46cd3c74271787accb8">estimateTrackParamsFromSeed</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, spacepoint_range_t spRange, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;bField)</td></tr>
<tr class="memdesc:a6993b7c73820f46cd3c74271787accb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the full track parameters from three space points.  <br /></td></tr>
<tr class="memitem:af38513640e42e706177f3812515d1b62" id="r_af38513640e42e706177f3812515d1b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af38513640e42e706177f3812515d1b62">estimateTrackParamsFromSeed</a> (const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;sp0, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;sp1, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;sp2, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;bField)</td></tr>
<tr class="memdesc:af38513640e42e706177f3812515d1b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the full track parameters from three space points.  <br /></td></tr>
<tr class="memitem:a57fee6bb48f063dd49269e39bfdc36fc" id="r_a57fee6bb48f063dd49269e39bfdc36fc"><td class="memTemplParams" colspan="2">template&lt;std::ranges::range spacepoint_range_t&gt; </td></tr>
<tr class="memitem:a57fee6bb48f063dd49269e39bfdc36fc template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57fee6bb48f063dd49269e39bfdc36fc">estimateTrackParamsFromSeed</a> (spacepoint_range_t spRange, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;bField)</td></tr>
<tr class="memdesc:a57fee6bb48f063dd49269e39bfdc36fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate the full track parameters from three space points.  <br /></td></tr>
<tr class="memitem:a10e8cfcddde31768275e024c61f03a70" id="r_a10e8cfcddde31768275e024c61f03a70"><td class="memTemplParams" colspan="2">template&lt;typename queries_type, typename expansion_type, std::size_t kDIM&gt; </td></tr>
<tr class="memitem:a10e8cfcddde31768275e024c61f03a70 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10e8cfcddde31768275e024c61f03a70">expand</a> (queries_type &amp;gridQueries, const expansion_type &amp;referenceExpansion)</td></tr>
<tr class="memdesc:a10e8cfcddde31768275e024c61f03a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to expand the grid queries along a given dimension.  <br /></td></tr>
<tr class="memitem:a850ecde5129afaabb5d4a8e71499f6cc" id="r_a850ecde5129afaabb5d4a8e71499f6cc"><td class="memItemLeft" align="right" valign="top">static constexpr std::pair&lt; std::int32_t, std::int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a850ecde5129afaabb5d4a8e71499f6cc">extractNucleusZandA</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a850ecde5129afaabb5d4a8e71499f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract Z and A for a given nucleus.  <br /></td></tr>
<tr class="memitem:a853dda101669b4f6ffbe29119b1a9ef6" id="r_a853dda101669b4f6ffbe29119b1a9ef6"><td class="memTemplParams" colspan="2">template&lt;TrackContainerFrontend track_container_t, typename propagator_t, typename propagator_options_t&gt; </td></tr>
<tr class="memitem:a853dda101669b4f6ffbe29119b1a9ef6 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a853dda101669b4f6ffbe29119b1a9ef6">extrapolateTracksToReferenceSurface</a> (const track_container_t &amp;trackContainer, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;referenceSurface, const propagator_t &amp;propagator, propagator_options_t options, <a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a> strategy, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger= *<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackExtrapolation&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>))</td></tr>
<tr class="memdesc:a853dda101669b4f6ffbe29119b1a9ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolate tracks to a reference surface.  <br /></td></tr>
<tr class="memitem:a1c35547ca44e69f20691e806cb8483ae" id="r_a1c35547ca44e69f20691e806cb8483ae"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t, typename propagator_t, typename propagator_options_t&gt; </td></tr>
<tr class="memitem:a1c35547ca44e69f20691e806cb8483ae template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c35547ca44e69f20691e806cb8483ae">extrapolateTrackToReferenceSurface</a> (track_proxy_t &amp;track, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;referenceSurface, const propagator_t &amp;propagator, propagator_options_t options, <a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a> strategy, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger= *<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackExtrapolation&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>))</td></tr>
<tr class="memdesc:a1c35547ca44e69f20691e806cb8483ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolate a track to a reference surface.  <br /></td></tr>
<tr class="memitem:a8b715ad8da501aa71d4507ec991513fd" id="r_a8b715ad8da501aa71d4507ec991513fd"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:a8b715ad8da501aa71d4507ec991513fd template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b715ad8da501aa71d4507ec991513fd">factorial</a> (const T upperN, const T lowerN=1)</td></tr>
<tr class="memdesc:a8b715ad8da501aa71d4507ec991513fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the factorial of a number N!= N*(N-1)....  <br /></td></tr>
<tr class="memitem:a370de2c1bb43783346d4a3cbc749dcd3" id="r_a370de2c1bb43783346d4a3cbc749dcd3"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a370de2c1bb43783346d4a3cbc749dcd3 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a370de2c1bb43783346d4a3cbc749dcd3">fastHypot</a> (T... args)</td></tr>
<tr class="memdesc:a370de2c1bb43783346d4a3cbc749dcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast hypotenuse calculation for multiple arguments.  <br /></td></tr>
<tr class="memitem:ga38f23b40e50cf64609d44c5392c00088" id="r_ga38f23b40e50cf64609d44c5392c00088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magnetic__field.html#ga38f23b40e50cf64609d44c5392c00088">fieldMapRZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;localToGlobalBin, std::vector&lt; double &gt; rPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a> &gt; &amp;bField, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>, double BFieldUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#ae1a6a8868aedfe9a2fa3c3d6d0fae230">UnitConstants::T</a>, bool firstQuadrant=false)</td></tr>
<tr class="memdesc:ga38f23b40e50cf64609d44c5392c00088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMap.  <br /></td></tr>
<tr class="memitem:ga0a2a24528115e4a19afa750157c52642" id="r_ga0a2a24528115e4a19afa750157c52642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magnetic__field.html#ga0a2a24528115e4a19afa750157c52642">fieldMapXYZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;localToGlobalBin, std::vector&lt; double &gt; xPos, std::vector&lt; double &gt; yPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &gt; &amp;bField, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>, double BFieldUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#ae1a6a8868aedfe9a2fa3c3d6d0fae230">UnitConstants::T</a>, bool firstOctant=false)</td></tr>
<tr class="memdesc:ga0a2a24528115e4a19afa750157c52642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMap.  <br /></td></tr>
<tr class="memitem:a77ed58950d2c88dfa04891d7042b426a" id="r_a77ed58950d2c88dfa04891d7042b426a"><td class="memTemplParams" colspan="2">template&lt;typename T, std::size_t N&gt; </td></tr>
<tr class="memitem:a77ed58950d2c88dfa04891d7042b426a template"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77ed58950d2c88dfa04891d7042b426a">filledArray</a> (const T &amp;defVal)</td></tr>
<tr class="memdesc:a77ed58950d2c88dfa04891d7042b426a"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates an array of type T and size N and assigns all elements to the parsed default value def_val.  <br /></td></tr>
<tr class="memitem:a26795186fae91337f5ed8b8efd8982c8" id="r_a26795186fae91337f5ed8b8efd8982c8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26795186fae91337f5ed8b8efd8982c8">findCharge</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a26795186fae91337f5ed8b8efd8982c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the charge for a given PDG particle number.  <br /></td></tr>
<tr class="memitem:a0b4b2bd9d2e161992542b8891fcb91aa" id="r_a0b4b2bd9d2e161992542b8891fcb91aa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4b2bd9d2e161992542b8891fcb91aa">findChargeOfNucleus</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a0b4b2bd9d2e161992542b8891fcb91aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the charge for a given PDG particle number of a nucleus.  <br /></td></tr>
<tr class="memitem:ab0dc64ed36049abdab55dfafdf61d90e" id="r_ab0dc64ed36049abdab55dfafdf61d90e"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; </td></tr>
<tr class="memitem:ab0dc64ed36049abdab55dfafdf61d90e template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; typename track_proxy_t::ConstTrackStateProxy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0dc64ed36049abdab55dfafdf61d90e">findFirstMeasurementState</a> (const track_proxy_t &amp;track)</td></tr>
<tr class="memdesc:ab0dc64ed36049abdab55dfafdf61d90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first measurement state in a track.  <br /></td></tr>
<tr class="memitem:ada531561958bfb2398084547ae4ba9e4" id="r_ada531561958bfb2398084547ae4ba9e4"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; </td></tr>
<tr class="memitem:ada531561958bfb2398084547ae4ba9e4 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; typename track_proxy_t::ConstTrackStateProxy &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada531561958bfb2398084547ae4ba9e4">findLastMeasurementState</a> (const track_proxy_t &amp;track)</td></tr>
<tr class="memdesc:ada531561958bfb2398084547ae4ba9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the last measurement state in a track.  <br /></td></tr>
<tr class="memitem:a1e76fb289b5f40ef6755435b0e9b1b36" id="r_a1e76fb289b5f40ef6755435b0e9b1b36"><td class="memItemLeft" align="right" valign="top">std::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e76fb289b5f40ef6755435b0e9b1b36">findMass</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a1e76fb289b5f40ef6755435b0e9b1b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the mass for a given PDG particle number.  <br /></td></tr>
<tr class="memitem:a96b3521103bdac2bf34db07669ced6e2" id="r_a96b3521103bdac2bf34db07669ced6e2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b3521103bdac2bf34db07669ced6e2">findMassOfNucleus</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a96b3521103bdac2bf34db07669ced6e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the mass for a given PDG particle number of a nucleus.  <br /></td></tr>
<tr class="memitem:aecf1b9be1abb1cb9b8232068c20429d5" id="r_aecf1b9be1abb1cb9b8232068c20429d5"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecf1b9be1abb1cb9b8232068c20429d5">findName</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:aecf1b9be1abb1cb9b8232068c20429d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a descriptive particle name for a given PDG particle number.  <br /></td></tr>
<tr class="memitem:a43da7d1f3b7a50be47d07cd91ad00ac8" id="r_a43da7d1f3b7a50be47d07cd91ad00ac8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43da7d1f3b7a50be47d07cd91ad00ac8">findNameOfNucleus</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a43da7d1f3b7a50be47d07cd91ad00ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a descriptive particle name for a given PDG particle number of a nucleus.  <br /></td></tr>
<tr class="memitem:a02e2191d2c123c5d7394238aa560e8d3" id="r_a02e2191d2c123c5d7394238aa560e8d3"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="struct_acts_1_1_particle_data.html">ParticleData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e2191d2c123c5d7394238aa560e8d3">findParticleData</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a02e2191d2c123c5d7394238aa560e8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all known particle data for a given PDG particle number.  <br /></td></tr>
<tr class="memitem:abcb3220aecf93487a5ec2e1a23a1b625" id="r_abcb3220aecf93487a5ec2e1a23a1b625"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; </td></tr>
<tr class="memitem:abcb3220aecf93487a5ec2e1a23a1b625 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; std::pair&lt; typename track_proxy_t::ConstTrackStateProxy, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcb3220aecf93487a5ec2e1a23a1b625">findTrackStateForExtrapolation</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;geoContext, const track_proxy_t &amp;track, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;referenceSurface, <a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a> strategy, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger= *<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackExtrapolation&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>))</td></tr>
<tr class="memdesc:abcb3220aecf93487a5ec2e1a23a1b625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a track state for extrapolation.  <br /></td></tr>
<tr class="memitem:a76da3358e590b2f7561bce0ed3bc3a41" id="r_a76da3358e590b2f7561bce0ed3bc3a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; 2, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76da3358e590b2f7561bce0ed3bc3a41">freeToSphericalDirectionJacobian</a> (const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction)</td></tr>
<tr class="memdesc:a76da3358e590b2f7561bce0ed3bc3a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Jacobian for free to spherical direction vector transformation.  <br /></td></tr>
<tr class="memitem:ga6aaf7d1fd1b61101aeb7f6e35e642781" id="r_ga6aaf7d1fd1b61101aeb7f6e35e642781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga6aaf7d1fd1b61101aeb7f6e35e642781">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_binning_data.html">BinningData</a> &amp;bd)</td></tr>
<tr class="memitem:ga6aa02daa239b9da9ab61a7d5a330bfc1" id="r_ga6aa02daa239b9da9ab61a7d5a330bfc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga6aa02daa239b9da9ab61a7d5a330bfc1">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu)</td></tr>
<tr class="memitem:ga7eae7997e8fa26d213da0e8fa7129515" id="r_ga7eae7997e8fa26d213da0e8fa7129515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga7eae7997e8fa26d213da0e8fa7129515">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="group__json__plugin.html#gad038e458629a5cedf1f825940ffc5f76">ConfigPair</a> &amp;p)</td></tr>
<tr class="memdesc:ga7eae7997e8fa26d213da0e8fa7129515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to ConfigPair.  <br /></td></tr>
<tr class="memitem:gaa3ffa5ada56af263eb0e8bbc53fa5459" id="r_gaa3ffa5ada56af263eb0e8bbc53fa5459"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gaa3ffa5ada56af263eb0e8bbc53fa5459">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_direction.html">Direction</a> &amp;direction)</td></tr>
<tr class="memdesc:gaa3ffa5ada56af263eb0e8bbc53fa5459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to Direction.  <br /></td></tr>
<tr class="memitem:ga592058495eb3359d62691f7d2cdd2404" id="r_ga592058495eb3359d62691f7d2cdd2404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga592058495eb3359d62691f7d2cdd2404">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_extent.html">Extent</a> &amp;e)</td></tr>
<tr class="memdesc:ga592058495eb3359d62691f7d2cdd2404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to Extent.  <br /></td></tr>
<tr class="memitem:ga9d3e1dd11c85a17a0506f49190900bbf" id="r_ga9d3e1dd11c85a17a0506f49190900bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga9d3e1dd11c85a17a0506f49190900bbf">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a> &amp;geoId)</td></tr>
<tr class="memdesc:ga9d3e1dd11c85a17a0506f49190900bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from JSON.  <br /></td></tr>
<tr class="memitem:ga5f0d646d5e653b566152c0a6b86b88b4" id="r_ga5f0d646d5e653b566152c0a6b86b88b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga5f0d646d5e653b566152c0a6b86b88b4">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_material.html">Material</a> &amp;t)</td></tr>
<tr class="memdesc:ga5f0d646d5e653b566152c0a6b86b88b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to Material.  <br /></td></tr>
<tr class="memitem:gab858857ba46f68cedf8b8896e1a73e68" id="r_gab858857ba46f68cedf8b8896e1a73e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gab858857ba46f68cedf8b8896e1a73e68">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;t)</td></tr>
<tr class="memdesc:gab858857ba46f68cedf8b8896e1a73e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to MaterialSlab.  <br /></td></tr>
<tr class="memitem:ga58a6de4073cc0d6ff6bf6e770b2dd639" id="r_ga58a6de4073cc0d6ff6bf6e770b2dd639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga58a6de4073cc0d6ff6bf6e770b2dd639">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="#acda8cc2353ab952431bd685a4450c1dc">MaterialSlabMatrix</a> &amp;t)</td></tr>
<tr class="memdesc:ga58a6de4073cc0d6ff6bf6e770b2dd639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to MaterialSlabMatrix.  <br /></td></tr>
<tr class="memitem:gae0588b72788762e55c7e287167143e2f" id="r_gae0588b72788762e55c7e287167143e2f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&gt; </td></tr>
<tr class="memitem:gae0588b72788762e55c7e287167143e2f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gae0588b72788762e55c7e287167143e2f">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="#a81478db625a7b35501d5f651f5d1d4fd">Range1D</a>&lt; <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &gt; &amp;r)</td></tr>
<tr class="memitem:gacaf98b5c349c59caa5b240a4380d467c" id="r_gacaf98b5c349c59caa5b240a4380d467c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gacaf98b5c349c59caa5b240a4380d467c">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="struct_acts_1_1_seed_confirmation_range_config.html">SeedConfirmationRangeConfig</a> &amp;config)</td></tr>
<tr class="memdesc:gacaf98b5c349c59caa5b240a4380d467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to SeedConfirmationRangeConfig.  <br /></td></tr>
<tr class="memitem:ga5468da799422d3b617d84b3b7731b1cf" id="r_ga5468da799422d3b617d84b3b7731b1cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga5468da799422d3b617d84b3b7731b1cf">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="group__json__plugin.html#ga76d1cebc6f43c76e5aaa8ef77d474064">surfaceMaterialPointer</a> &amp;material)</td></tr>
<tr class="memdesc:ga5468da799422d3b617d84b3b7731b1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to surfaceMaterialPointer.  <br /></td></tr>
<tr class="memitem:gac7844f9f2860fbc63cfe807871dd609e" id="r_gac7844f9f2860fbc63cfe807871dd609e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gac7844f9f2860fbc63cfe807871dd609e">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;t)</td></tr>
<tr class="memdesc:gac7844f9f2860fbc63cfe807871dd609e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to Transform3.  <br /></td></tr>
<tr class="memitem:gad4e3a647d9f5607dcff4abf122189cb1" id="r_gad4e3a647d9f5607dcff4abf122189cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gad4e3a647d9f5607dcff4abf122189cb1">from_json</a> (const nlohmann::json &amp;j, <a class="el" href="group__json__plugin.html#ga06973c0a57ed2cedc63a4e66a33eb4ae">volumeMaterialPointer</a> &amp;material)</td></tr>
<tr class="memdesc:gad4e3a647d9f5607dcff4abf122189cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert JSON to volumeMaterialPointer.  <br /></td></tr>
<tr class="memitem:a9b4dee934b0b193d57604b19bc8cd527" id="r_a9b4dee934b0b193d57604b19bc8cd527"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a> (const std::string &amp;name, const <a class="el" href="group__logging.html#ga9b12dd924a4bd3aed921a33779ece95b">Logging::Level</a> &amp;lvl, std::ostream *log_stream=&amp;std::cout)</td></tr>
<tr class="memdesc:a9b4dee934b0b193d57604b19bc8cd527"><td class="mdescLeft">&#160;</td><td class="mdescRight">get default debug output logger  <br /></td></tr>
<tr class="memitem:ac3958b2d3af64792cac019893486c394" id="r_ac3958b2d3af64792cac019893486c394"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3958b2d3af64792cac019893486c394">getDummyLogger</a> ()</td></tr>
<tr class="memdesc:ac3958b2d3af64792cac019893486c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a dummy logger that discards all output.  <br /></td></tr>
<tr class="memitem:a4415f5f0dacad71be15d93860d45750e" id="r_a4415f5f0dacad71be15d93860d45750e"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4415f5f0dacad71be15d93860d45750e">globalToLocalFromBin</a> (<a class="el" href="#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> &amp;<a class="el" href="struct_acts_1_1_remove_pointer.html">type</a>)</td></tr>
<tr class="memdesc:a4415f5f0dacad71be15d93860d45750e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a function that return the coordinate corresponding to type of bin  <br /></td></tr>
<tr class="memitem:a6e446526e27c813da589b5e2bc1a874c" id="r_a6e446526e27c813da589b5e2bc1a874c"><td class="memTemplParams" colspan="2">template&lt;typename T, class... Axes&gt; </td></tr>
<tr class="memitem:a6e446526e27c813da589b5e2bc1a874c template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e446526e27c813da589b5e2bc1a874c">Grid</a> (<a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a>&lt; T &gt;, Axes &amp;&amp;... axes) -&gt; Grid&lt; T, Axes... &gt;</td></tr>
<tr class="memdesc:a6e446526e27c813da589b5e2bc1a874c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for Grid with rvalue reference axes.  <br /></td></tr>
<tr class="memitem:a7cc4853c5dcc7f0be2b4dc28a7e7cf38" id="r_a7cc4853c5dcc7f0be2b4dc28a7e7cf38"><td class="memTemplParams" colspan="2">template&lt;typename T, class... Axes&gt; </td></tr>
<tr class="memitem:a7cc4853c5dcc7f0be2b4dc28a7e7cf38 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cc4853c5dcc7f0be2b4dc28a7e7cf38">Grid</a> (<a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a>&lt; T &gt;, Axes &amp;... axes) -&gt; Grid&lt; T, Axes... &gt;</td></tr>
<tr class="memdesc:a7cc4853c5dcc7f0be2b4dc28a7e7cf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for Grid with lvalue reference axes.  <br /></td></tr>
<tr class="memitem:a323367bcdfc61666350ef9c85a96033f" id="r_a323367bcdfc61666350ef9c85a96033f"><td class="memTemplParams" colspan="2">template&lt;typename T, class... Axes&gt; </td></tr>
<tr class="memitem:a323367bcdfc61666350ef9c85a96033f template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a323367bcdfc61666350ef9c85a96033f">GridGlobalIterator</a> (const <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; T, Axes... &gt; &amp;grid, std::size_t idx) -&gt; GridGlobalIterator&lt; T, Axes... &gt;</td></tr>
<tr class="memdesc:a323367bcdfc61666350ef9c85a96033f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for GridGlobalIterator.  <br /></td></tr>
<tr class="memitem:a312705c7759168e892ece2b486788dcc" id="r_a312705c7759168e892ece2b486788dcc"><td class="memItemLeft" align="right" valign="top">consteval <a class="el" href="#a316aaac27fda3651c80ea8dfba83492a">HashedString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a312705c7759168e892ece2b486788dcc">hashString</a> (std::string_view s)</td></tr>
<tr class="memdesc:a312705c7759168e892ece2b486788dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time hash of string literal.  <br /></td></tr>
<tr class="memitem:a04217815a63aceaf6ab6d5b64a057cbe" id="r_a04217815a63aceaf6ab6d5b64a057cbe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#a316aaac27fda3651c80ea8dfba83492a">HashedString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04217815a63aceaf6ab6d5b64a057cbe">hashStringDynamic</a> (std::string_view s)</td></tr>
<tr class="memdesc:a04217815a63aceaf6ab6d5b64a057cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime hash of string.  <br /></td></tr>
<tr class="memitem:ad30a4e8469eb16297c0ab87d5cf68209" id="r_ad30a4e8469eb16297c0ab87d5cf68209"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ad30a4e8469eb16297c0ab87d5cf68209 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad30a4e8469eb16297c0ab87d5cf68209">hypotSquare</a> (T... args)</td></tr>
<tr class="memdesc:ad30a4e8469eb16297c0ab87d5cf68209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sum of squares of arguments.  <br /></td></tr>
<tr class="memitem:a3caf69a4c80cf869115afbab91cd8163" id="r_a3caf69a4c80cf869115afbab91cd8163"><td class="memTemplParams" colspan="2">template&lt;typename T, std::size_t N, class Point1, class Point2 = Point1, class Point3 = Point2&gt; <br />
requires (Concepts::interpolatable&lt;T, Point1, Point2, Point3&gt;)</td></tr>
<tr class="memitem:a3caf69a4c80cf869115afbab91cd8163 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3caf69a4c80cf869115afbab91cd8163">interpolate</a> (const Point1 &amp;position, const Point2 &amp;lowerCorner, const Point3 &amp;upperCorner, const std::array&lt; T, N &gt; &amp;values)</td></tr>
<tr class="memdesc:a3caf69a4c80cf869115afbab91cd8163"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs linear interpolation inside a hyper box  <br /></td></tr>
<tr class="memitem:a94a8f9b03ea4540ab29e8d70330fa7f0" id="r_a94a8f9b03ea4540ab29e8d70330fa7f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a8f9b03ea4540ab29e8d70330fa7f0">isBoundVectorValid</a> (const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;v, bool validateAngleRange, double epsilon=1e-6, double maxAbsEta=std::numeric_limits&lt; double &gt;::infinity())</td></tr>
<tr class="memdesc:a94a8f9b03ea4540ab29e8d70330fa7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a bound vector is valid.  <br /></td></tr>
<tr class="memitem:abe77e44cea219bce9c03f8b2344bebaa" id="r_abe77e44cea219bce9c03f8b2344bebaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe77e44cea219bce9c03f8b2344bebaa">isFreeVectorValid</a> (const <a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;v, double epsilon=1e-6, double maxAbsEta=std::numeric_limits&lt; double &gt;::infinity())</td></tr>
<tr class="memdesc:abe77e44cea219bce9c03f8b2344bebaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a free vector is valid.  <br /></td></tr>
<tr class="memitem:a0dad26c0de75201a5b5d1fe7ce6c88e3" id="r_a0dad26c0de75201a5b5d1fe7ce6c88e3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dad26c0de75201a5b5d1fe7ce6c88e3">isNucleus</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a0dad26c0de75201a5b5d1fe7ce6c88e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the PDG belongs to a nucleus, i.e.  <br /></td></tr>
<tr class="memitem:aac11e8ec3784f7325583119c7b36bb06" id="r_aac11e8ec3784f7325583119c7b36bb06"><td class="memTemplParams" colspan="2">template&lt;std::ranges::range R&gt; <br />
requires std::convertible_to&lt;std::ranges::range_value_t&lt;R&gt;, std::string_view&gt;</td></tr>
<tr class="memitem:aac11e8ec3784f7325583119c7b36bb06 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac11e8ec3784f7325583119c7b36bb06">joinStrings</a> (R &amp;&amp;strings, std::string_view delimiter)</td></tr>
<tr class="memdesc:aac11e8ec3784f7325583119c7b36bb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utuility to join a range of strings with a delimiter.  <br /></td></tr>
<tr class="memitem:a1d589f70433525252ee4e7a5c412ac44" id="r_a1d589f70433525252ee4e7a5c412ac44"><td class="memTemplParams" colspan="2">template&lt;std::ranges::range R&gt; <br />
requires ( detail::formattable&lt;std::ranges::range_value_t&lt;R&gt;, char&gt; &amp;&amp; !std::convertible_to&lt;std::ranges::range_value_t&lt;R&gt;, std::string_view&gt;)</td></tr>
<tr class="memitem:a1d589f70433525252ee4e7a5c412ac44 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d589f70433525252ee4e7a5c412ac44">joinStrings</a> (R &amp;&amp;values, std::string_view delimiter)</td></tr>
<tr class="memdesc:a1d589f70433525252ee4e7a5c412ac44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to join a range of formattable elements with a delimiter.  <br /></td></tr>
<tr class="memitem:addbd41a294e15a0ec2b8c05ef65a6552" id="r_addbd41a294e15a0ec2b8c05ef65a6552"><td class="memTemplParams" colspan="2">template&lt;std::ranges::range R&gt; <br />
requires detail::formattable&lt;std::ranges::range_value_t&lt;R&gt;, char&gt;</td></tr>
<tr class="memitem:addbd41a294e15a0ec2b8c05ef65a6552 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addbd41a294e15a0ec2b8c05ef65a6552">joinStrings</a> (R &amp;&amp;values, std::string_view delimiter, std::format_string&lt; const std::ranges::range_value_t&lt; R &gt; &amp; &gt; format)</td></tr>
<tr class="memdesc:addbd41a294e15a0ec2b8c05ef65a6552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to join a range of formattable elements with a delimiter and custom format string.  <br /></td></tr>
<tr class="memitem:af0aae08c33000aa753f3f047c0258722" id="r_af0aae08c33000aa753f3f047c0258722"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:af0aae08c33000aa753f3f047c0258722 template"><td class="memItemLeft" align="right" valign="top">std::set&lt; typename grid_type::index_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0aae08c33000aa753f3f047c0258722">localIndices</a> (const grid_type &amp;grid, const std::vector&lt; typename grid_type::point_t &gt; &amp;queries, const std::vector&lt; std::size_t &gt; &amp;expansion={})</td></tr>
<tr class="memdesc:af0aae08c33000aa753f3f047c0258722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to fill local bins given a set of query points bin in between the extra points are filled, and a possible expansion of the bin window can be chosen.  <br /></td></tr>
<tr class="memitem:a76fa69095a6c107291628ba01d426ddb" id="r_a76fa69095a6c107291628ba01d426ddb"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76fa69095a6c107291628ba01d426ddb">make_error_code</a> (<a class="el" href="group__errors.html#ga5708898bc604b9dfedc12319218b8c1b">Acts::CombinatorialKalmanFilterError</a> e)</td></tr>
<tr class="memdesc:a76fa69095a6c107291628ba01d426ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from <a class="el" href="group__errors.html#ga5708898bc604b9dfedc12319218b8c1b">CombinatorialKalmanFilterError</a>.  <br /></td></tr>
<tr class="memitem:a190c3b5e3ff20dbd35833e207d4f62c1" id="r_a190c3b5e3ff20dbd35833e207d4f62c1"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a190c3b5e3ff20dbd35833e207d4f62c1">make_error_code</a> (<a class="el" href="group__errors.html#gac3f65a46059b0f9516370f5bdcb9bddd">Acts::KalmanFitterError</a> e)</td></tr>
<tr class="memdesc:a190c3b5e3ff20dbd35833e207d4f62c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from <a class="el" href="group__errors.html#gac3f65a46059b0f9516370f5bdcb9bddd">KalmanFitterError</a>.  <br /></td></tr>
<tr class="memitem:a25f5d4485b7a41d484c83c920e320f12" id="r_a25f5d4485b7a41d484c83c920e320f12"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25f5d4485b7a41d484c83c920e320f12">make_error_code</a> (<a class="el" href="group__errors.html#gaf2646ee646a0b70b9c7ebe6e7f473629">Acts::MultiStepperError</a> e)</td></tr>
<tr class="memdesc:a25f5d4485b7a41d484c83c920e320f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from MultiStepperError.  <br /></td></tr>
<tr class="memitem:ace837699dafcfe04fb90daf56bc45e0c" id="r_ace837699dafcfe04fb90daf56bc45e0c"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace837699dafcfe04fb90daf56bc45e0c">make_error_code</a> (<a class="el" href="group__errors.html#ga2cc876d4889b5c6656ed7d5e0c1fca19">Acts::NavigatorError</a> e)</td></tr>
<tr class="memdesc:ace837699dafcfe04fb90daf56bc45e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from NavigatorError.  <br /></td></tr>
<tr class="memitem:a3326d9e357aef12edb2f49a4ea8bae95" id="r_a3326d9e357aef12edb2f49a4ea8bae95"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3326d9e357aef12edb2f49a4ea8bae95">make_error_code</a> (<a class="el" href="group__errors.html#gad9ea430c0897aa29fcaccb4fa68aa459">Acts::PortalError</a> e)</td></tr>
<tr class="memdesc:a3326d9e357aef12edb2f49a4ea8bae95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from PortalError.  <br /></td></tr>
<tr class="memitem:a59c48d818496d25601d010382d0a0949" id="r_a59c48d818496d25601d010382d0a0949"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59c48d818496d25601d010382d0a0949">make_error_code</a> (<a class="el" href="group__errors.html#gae4af8513760690d2518f3e01355beb88">Acts::PropagatorError</a> e)</td></tr>
<tr class="memdesc:a59c48d818496d25601d010382d0a0949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from PropagatorError.  <br /></td></tr>
<tr class="memitem:a4b8e2b066fa956db4b2b5ff5d3bb49cb" id="r_a4b8e2b066fa956db4b2b5ff5d3bb49cb"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b8e2b066fa956db4b2b5ff5d3bb49cb">make_error_code</a> (<a class="el" href="group__errors.html#gac32894235c42ab9d5e6bf5c5cd1f6f3d">Acts::SurfaceError</a> e)</td></tr>
<tr class="memdesc:a4b8e2b066fa956db4b2b5ff5d3bb49cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from SurfaceError.  <br /></td></tr>
<tr class="memitem:aa38979d17928758be33bb3b9bbe7471c" id="r_aa38979d17928758be33bb3b9bbe7471c"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa38979d17928758be33bb3b9bbe7471c">make_error_code</a> (<a class="el" href="group__errors.html#ga1f61f3856fa7ffded6d06723801cf8e6">Acts::VertexingError</a> e)</td></tr>
<tr class="memdesc:aa38979d17928758be33bb3b9bbe7471c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from VertexingError.  <br /></td></tr>
<tr class="memitem:aa056d6844123e85684dfa0a1b8e54ddd" id="r_aa056d6844123e85684dfa0a1b8e54ddd"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa056d6844123e85684dfa0a1b8e54ddd">make_error_code</a> (<a class="el" href="group__errors.html#ga21cb0f3d4dc02db3af0291385e70d4e0">EigenStepperError</a> e)</td></tr>
<tr class="memdesc:aa056d6844123e85684dfa0a1b8e54ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from EigenStepperError.  <br /></td></tr>
<tr class="memitem:a4a880fdaf6088e3efa05b6c61fab3874" id="r_a4a880fdaf6088e3efa05b6c61fab3874"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a880fdaf6088e3efa05b6c61fab3874">make_error_code</a> (<a class="el" href="group__errors.html#ga83f8b59ffc557631bb7fdd01c18431ca">GsfError</a> e)</td></tr>
<tr class="memdesc:a4a880fdaf6088e3efa05b6c61fab3874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from <a class="el" href="group__errors.html#ga83f8b59ffc557631bb7fdd01c18431ca">GsfError</a>.  <br /></td></tr>
<tr class="memitem:a011628b4fe22e244f04ee152403c6d5f" id="r_a011628b4fe22e244f04ee152403c6d5f"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a011628b4fe22e244f04ee152403c6d5f">make_error_code</a> (<a class="el" href="group__errors.html#ga15d42dcaa6c43d68f6d711f04f9594bd">SpacePointFormationError</a> e)</td></tr>
<tr class="memdesc:a011628b4fe22e244f04ee152403c6d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from SpacePointFormationError.  <br /></td></tr>
<tr class="memitem:aa5667ec3badff6cf983c82c9c9ba533e" id="r_aa5667ec3badff6cf983c82c9c9ba533e"><td class="memItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5667ec3badff6cf983c82c9c9ba533e">make_error_code</a> (<a class="el" href="group__errors.html#ga6a0e61fbedc5e6713e2830a03af01032">TrackExtrapolationError</a> e)</td></tr>
<tr class="memdesc:aa5667ec3badff6cf983c82c9c9ba533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create error code from TrackExtrapolationError.  <br /></td></tr>
<tr class="memitem:ab709b73059672dac9c8b63ae942d10bf" id="r_ab709b73059672dac9c8b63ae942d10bf"><td class="memTemplParams" colspan="2">template&lt;typename box_t&gt; </td></tr>
<tr class="memitem:ab709b73059672dac9c8b63ae942d10bf template"><td class="memItemLeft" align="right" valign="top">box_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab709b73059672dac9c8b63ae942d10bf">make_octree</a> (std::vector&lt; std::unique_ptr&lt; box_t &gt; &gt; &amp;store, const std::vector&lt; box_t * &gt; &amp;prims, std::size_t max_depth=1, typename box_t::value_type envelope1=0)</td></tr>
<tr class="memdesc:ab709b73059672dac9c8b63ae942d10bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an octree from a list of bounding boxes.  <br /></td></tr>
<tr class="memitem:ad340f3a8c5e2c06a6912b8537aa08fb4" id="r_ad340f3a8c5e2c06a6912b8537aa08fb4"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad340f3a8c5e2c06a6912b8537aa08fb4">makeAbsolutePdgParticle</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:ad340f3a8c5e2c06a6912b8537aa08fb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an anti-particle to its particle and leave particles as-is.  <br /></td></tr>
<tr class="memitem:ga470f44f3b24dd49d4a1366a6666f67f6" id="r_ga470f44f3b24dd49d4a1366a6666f67f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#ga470f44f3b24dd49d4a1366a6666f67f6">makeDefaultBetheHeitlerApprox</a> (bool clampToRange=false)</td></tr>
<tr class="memdesc:ga470f44f3b24dd49d4a1366a6666f67f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a> object based on an ATLAS configuration, that are stored as static data in the source code.  <br /></td></tr>
<tr class="memitem:a6273d1f24a492d8ff55bed5c32f3a77f" id="r_a6273d1f24a492d8ff55bed5c32f3a77f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6273d1f24a492d8ff55bed5c32f3a77f template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6273d1f24a492d8ff55bed5c32f3a77f">makeDirectionFromAxisTangents</a> (T tanAlpha, T tanBeta)</td></tr>
<tr class="memdesc:a6273d1f24a492d8ff55bed5c32f3a77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a normalized direction vector from the tangents of the x-axis to the z-axis and of the y-axis to the z-axis.  <br /></td></tr>
<tr class="memitem:a6a9928559b584e711a83869d56fe1bdb" id="r_a6a9928559b584e711a83869d56fe1bdb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a6a9928559b584e711a83869d56fe1bdb template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a9928559b584e711a83869d56fe1bdb">makeDirectionFromPhiEta</a> (T phi, T eta)</td></tr>
<tr class="memdesc:a6a9928559b584e711a83869d56fe1bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a normalized direction vector from phi angle and pseudorapidity.  <br /></td></tr>
<tr class="memitem:a47bd4093e0a9133ee5ea107a3bf55f59" id="r_a47bd4093e0a9133ee5ea107a3bf55f59"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a47bd4093e0a9133ee5ea107a3bf55f59 template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47bd4093e0a9133ee5ea107a3bf55f59">makeDirectionFromPhiTheta</a> (T phi, T theta)</td></tr>
<tr class="memdesc:a47bd4093e0a9133ee5ea107a3bf55f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a normalized direction vector from phi and theta angle.  <br /></td></tr>
<tr class="memitem:a40b3a30a8131177dae1e7d5c6bf8b5e0" id="r_a40b3a30a8131177dae1e7d5c6bf8b5e0"><td class="memTemplParams" colspan="2">template&lt;typename payload_t&gt; </td></tr>
<tr class="memitem:a40b3a30a8131177dae1e7d5c6bf8b5e0 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_acts_1_1_i_grid.html">IGrid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40b3a30a8131177dae1e7d5c6bf8b5e0">makeGrid</a> (const <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &amp;a)</td></tr>
<tr class="memdesc:a40b3a30a8131177dae1e7d5c6bf8b5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to create a 1D grid from a single proto axis.  <br /></td></tr>
<tr class="memitem:a424d9f0cd5324b8c7aa9b7d108626772" id="r_a424d9f0cd5324b8c7aa9b7d108626772"><td class="memTemplParams" colspan="2">template&lt;typename payload_t&gt; </td></tr>
<tr class="memitem:a424d9f0cd5324b8c7aa9b7d108626772 template"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="class_acts_1_1_i_grid.html">IGrid</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a424d9f0cd5324b8c7aa9b7d108626772">makeGrid</a> (const <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &amp;a, const <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &amp;b)</td></tr>
<tr class="memdesc:a424d9f0cd5324b8c7aa9b7d108626772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to create a 2D grid from a two proto axes.  <br /></td></tr>
<tr class="memitem:ga5867649c2811a2b164af6e62f4ee6d8c" id="r_ga5867649c2811a2b164af6e62f4ee6d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magnetic__field.html#ga5867649c2811a2b164af6e62f4ee6d8c">makeMagneticFieldMapRzFromText</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;localToGlobalBin, const std::string &amp;fieldMapFile, double lengthUnit, double BFieldUnit, bool firstQuadrant=false, const std::string &amp;delimiter=&quot;&quot;)</td></tr>
<tr class="memdesc:ga5867649c2811a2b164af6e62f4ee6d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMapper.  <br /></td></tr>
<tr class="memitem:ga3baad317424227151687cad974537339" id="r_ga3baad317424227151687cad974537339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magnetic__field.html#ga3baad317424227151687cad974537339">makeMagneticFieldMapXyzFromText</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;localToGlobalBin, const std::string &amp;fieldMapFile, double lengthUnit, double BFieldUnit, bool firstOctant=false, const std::string &amp;delimiter=&quot;&quot;)</td></tr>
<tr class="memdesc:ga3baad317424227151687cad974537339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMapper.  <br /></td></tr>
<tr class="memitem:aba9e1010998ed0a39553174f81cc6c3c" id="r_aba9e1010998ed0a39553174f81cc6c3c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba9e1010998ed0a39553174f81cc6c3c">makeNucleusGroundState</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:aba9e1010998ed0a39553174f81cc6c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an excited nucleus to its ground state.  <br /></td></tr>
<tr class="memitem:aa43f78ba3fcf4f16c256f1b3ac56f90b" id="r_aa43f78ba3fcf4f16c256f1b3ac56f90b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa43f78ba3fcf4f16c256f1b3ac56f90b template"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 2, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa43f78ba3fcf4f16c256f1b3ac56f90b">makePhiThetaFromDirection</a> (const Eigen::Matrix&lt; T, 3, 1 &gt; &amp;unitDir)</td></tr>
<tr class="memdesc:aa43f78ba3fcf4f16c256f1b3ac56f90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a phi and theta angle from a direction vector.  <br /></td></tr>
<tr class="memitem:a129628bceba57d023385eb65dc145ad0" id="r_a129628bceba57d023385eb65dc145ad0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6bacc83149ffd31c3d1c02297b63a884">MaterialGrid2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a129628bceba57d023385eb65dc145ad0">mapMaterialPoints</a> (<a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a> &amp;grid)</td></tr>
<tr class="memdesc:a129628bceba57d023385eb65dc145ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average the material collected in a 2D grid and use it to create a 2D material grid.  <br /></td></tr>
<tr class="memitem:ad0936c1a6d966edd3d54a30ed376a45c" id="r_ad0936c1a6d966edd3d54a30ed376a45c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae34013557b3d2c0ee081ec4b1c408b38">MaterialGrid3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0936c1a6d966edd3d54a30ed376a45c">mapMaterialPoints</a> (<a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a> &amp;grid)</td></tr>
<tr class="memdesc:ad0936c1a6d966edd3d54a30ed376a45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average the material collected in a 3D grid and use it to create a 3D material grid.  <br /></td></tr>
<tr class="memitem:ga36398a73a93820ca563cdaebf35c8c99" id="r_ga36398a73a93820ca563cdaebf35c8c99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="class_acts_1_1_material.html#ac9b70e6986aef6c7b9569576fcf8a781">Material::ParametersVector</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#ga36398a73a93820ca563cdaebf35c8c99">materialMapperRZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;materialVectorToGridMapper, std::vector&lt; double &gt; rPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="class_acts_1_1_material.html">Acts::Material</a> &gt; &amp;material, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>)</td></tr>
<tr class="memdesc:ga36398a73a93820ca563cdaebf35c8c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the MaterialMapper.  <br /></td></tr>
<tr class="memitem:ga58e02a2bfb006720b513203973586084" id="r_ga58e02a2bfb006720b513203973586084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="class_acts_1_1_material.html#ac9b70e6986aef6c7b9569576fcf8a781">Material::ParametersVector</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material.html#ga58e02a2bfb006720b513203973586084">materialMapperXYZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;materialVectorToGridMapper, std::vector&lt; double &gt; xPos, std::vector&lt; double &gt; yPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="class_acts_1_1_material.html">Material</a> &gt; &amp;material, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>)</td></tr>
<tr class="memdesc:ga58e02a2bfb006720b513203973586084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the MaterialLookup.  <br /></td></tr>
<tr class="memitem:a3dcc6435e936f830c8ce3e2c67122fd5" id="r_a3dcc6435e936f830c8ce3e2c67122fd5"><td class="memTemplParams" colspan="2">template&lt;typename Derived&gt; </td></tr>
<tr class="memitem:a3dcc6435e936f830c8ce3e2c67122fd5 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dcc6435e936f830c8ce3e2c67122fd5">matrixToBitset</a> (const Eigen::PlainObjectBase&lt; Derived &gt; &amp;m)</td></tr>
<tr class="memdesc:a3dcc6435e936f830c8ce3e2c67122fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer matrix to a bitset.  <br /></td></tr>
<tr class="memitem:gac8895b284676062f1c0bf5f6466a507d" id="r_gac8895b284676062f1c0bf5f6466a507d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gac8895b284676062f1c0bf5f6466a507d">NLOHMANN_JSON_SERIALIZE_ENUM</a> (<a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1">Acts::MappingType</a>, { {<a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1a4b89096cd32efd26f913e96e61b96e77">Acts::MappingType::PreMapping</a>, &quot;PreMapping&quot;}, {<a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1a879c8d57398ac17a2d7ecaea65021e85">Acts::MappingType::Default</a>, &quot;Default&quot;}, {<a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1ae9a8b8024c5ca45ba5848e8f46dc38fe">Acts::MappingType::PostMapping</a>, &quot;PostMapping&quot;}, {<a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1aaeef76ca06f887c6eb3fcc9d41de53cd">Acts::MappingType::Sensor</a>, &quot;Sensor&quot;}, }) namespace MaterialJsonConverter</td></tr>
<tr class="memdesc:gac8895b284676062f1c0bf5f6466a507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON serialization mapping for MappingType enum.  <br /></td></tr>
<tr class="memitem:a52e4174147933a017fd8663abf8ae740" id="r_a52e4174147933a017fd8663abf8ae740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52e4174147933a017fd8663abf8ae740">normalizeBoundParameters</a> (const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;boundParams)</td></tr>
<tr class="memdesc:a52e4174147933a017fd8663abf8ae740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize the bound parameter angles.  <br /></td></tr>
<tr class="memitem:a297fc9345930e9e61a5771aad5dc17c5" id="r_a297fc9345930e9e61a5771aad5dc17c5"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a297fc9345930e9e61a5771aad5dc17c5">numAxisDirections</a> ()</td></tr>
<tr class="memdesc:a297fc9345930e9e61a5771aad5dc17c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of axis directions.  <br /></td></tr>
<tr class="memitem:a19fedc5d26afa78af1bca76bf2b8e62a" id="r_a19fedc5d26afa78af1bca76bf2b8e62a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fedc5d26afa78af1bca76bf2b8e62a">operator*</a> (const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:a19fedc5d26afa78af1bca76bf2b8e62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Vector3 with Direction.  <br /></td></tr>
<tr class="memitem:a42d92c82b2ff4bb3e507c65bb8ee1a7c" id="r_a42d92c82b2ff4bb3e507c65bb8ee1a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42d92c82b2ff4bb3e507c65bb8ee1a7c">operator*</a> (<a class="el" href="class_acts_1_1_direction.html">Direction</a> dir, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;value)</td></tr>
<tr class="memdesc:a42d92c82b2ff4bb3e507c65bb8ee1a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Direction with Vector3.  <br /></td></tr>
<tr class="memitem:ab363071b4a31676e883a3b3902c21199" id="r_ab363071b4a31676e883a3b3902c21199"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab363071b4a31676e883a3b3902c21199">operator*</a> (<a class="el" href="class_acts_1_1_direction.html">Direction</a> dir, double value)</td></tr>
<tr class="memdesc:ab363071b4a31676e883a3b3902c21199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Direction with double.  <br /></td></tr>
<tr class="memitem:adf66c1a2997754ef9b2446b08b0e11d7" id="r_adf66c1a2997754ef9b2446b08b0e11d7"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf66c1a2997754ef9b2446b08b0e11d7">operator*</a> (<a class="el" href="class_acts_1_1_direction.html">Direction</a> dir, float value)</td></tr>
<tr class="memdesc:adf66c1a2997754ef9b2446b08b0e11d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Direction with float.  <br /></td></tr>
<tr class="memitem:a75e0f8b70f2049a83af6fcefd0f8093e" id="r_a75e0f8b70f2049a83af6fcefd0f8093e"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75e0f8b70f2049a83af6fcefd0f8093e">operator*</a> (<a class="el" href="class_acts_1_1_direction.html">Direction</a> dir, int value)</td></tr>
<tr class="memdesc:a75e0f8b70f2049a83af6fcefd0f8093e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply Direction with integer.  <br /></td></tr>
<tr class="memitem:aa914c08281fc46ac3d7df031f44e4264" id="r_aa914c08281fc46ac3d7df031f44e4264"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa914c08281fc46ac3d7df031f44e4264">operator*</a> (double value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:aa914c08281fc46ac3d7df031f44e4264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply double with Direction.  <br /></td></tr>
<tr class="memitem:a250fdefc5104f8449c2eb60b11400520" id="r_a250fdefc5104f8449c2eb60b11400520"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a250fdefc5104f8449c2eb60b11400520">operator*</a> (float value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:a250fdefc5104f8449c2eb60b11400520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply float with Direction.  <br /></td></tr>
<tr class="memitem:ae700061586be6ebb696cd0a611741071" id="r_ae700061586be6ebb696cd0a611741071"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae700061586be6ebb696cd0a611741071">operator*</a> (int value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:ae700061586be6ebb696cd0a611741071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply integer with Direction.  <br /></td></tr>
<tr class="memitem:abbc8ef8ab345e51b0bec867deb598869" id="r_abbc8ef8ab345e51b0bec867deb598869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbc8ef8ab345e51b0bec867deb598869">operator*=</a> (<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:abbc8ef8ab345e51b0bec867deb598869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-assign Vector3 with Direction.  <br /></td></tr>
<tr class="memitem:a0e2b412bc101d9c5e703c26d9a7802c8" id="r_a0e2b412bc101d9c5e703c26d9a7802c8"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e2b412bc101d9c5e703c26d9a7802c8">operator*=</a> (double &amp;value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:a0e2b412bc101d9c5e703c26d9a7802c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-assign double with Direction.  <br /></td></tr>
<tr class="memitem:a09b6ea68a647128b85d554b381fd4c77" id="r_a09b6ea68a647128b85d554b381fd4c77"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b6ea68a647128b85d554b381fd4c77">operator*=</a> (float &amp;value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:a09b6ea68a647128b85d554b381fd4c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-assign float with Direction.  <br /></td></tr>
<tr class="memitem:a61cc9ce9d77ed191d22251f2fd7af429" id="r_a61cc9ce9d77ed191d22251f2fd7af429"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61cc9ce9d77ed191d22251f2fd7af429">operator*=</a> (int &amp;value, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:a61cc9ce9d77ed191d22251f2fd7af429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply-assign integer with Direction.  <br /></td></tr>
<tr class="memitem:a8c289cbcb6bb87a3a4e60b4e968eb225" id="r_a8c289cbcb6bb87a3a4e60b4e968eb225"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c289cbcb6bb87a3a4e60b4e968eb225">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a> bdt)</td></tr>
<tr class="memdesc:a8c289cbcb6bb87a3a4e60b4e968eb225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for AxisBoundaryType.  <br /></td></tr>
<tr class="memitem:a28ea8e56599eede759a6ae23bcc4af04" id="r_a28ea8e56599eede759a6ae23bcc4af04"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28ea8e56599eede759a6ae23bcc4af04">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> aDir)</td></tr>
<tr class="memdesc:a28ea8e56599eede759a6ae23bcc4af04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for <code>AxisDirection</code>.  <br /></td></tr>
<tr class="memitem:aeedb8d78036b12103c3764910ef88e4c" id="r_aeedb8d78036b12103c3764910ef88e4c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeedb8d78036b12103c3764910ef88e4c">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32f">AxisType</a> <a class="el" href="struct_acts_1_1_remove_pointer.html">type</a>)</td></tr>
<tr class="memdesc:aeedb8d78036b12103c3764910ef88e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for AxisType.  <br /></td></tr>
<tr class="memitem:a606b394839619dca8056f6ca7f7a9cd9" id="r_a606b394839619dca8056f6ca7f7a9cd9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a606b394839619dca8056f6ca7f7a9cd9">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3">BoundarySurfaceFace</a> &amp;face)</td></tr>
<tr class="memdesc:a606b394839619dca8056f6ca7f7a9cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for BoundarySurfaceFace.  <br /></td></tr>
<tr class="memitem:ad091d6f5ca02eacdd0ecbbb216893287" id="r_ad091d6f5ca02eacdd0ecbbb216893287"><td class="memTemplParams" colspan="2">template&lt;typename T, typename U, std::size_t V&gt; </td></tr>
<tr class="memitem:ad091d6f5ca02eacdd0ecbbb216893287 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad091d6f5ca02eacdd0ecbbb216893287">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_acts_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a>&lt; T, U, V &gt; &amp;box)</td></tr>
<tr class="memdesc:ad091d6f5ca02eacdd0ecbbb216893287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the &lt;&lt; operator for bounding boxes.  <br /></td></tr>
<tr class="memitem:aff2f246860b0974632cebefff000f4ae" id="r_aff2f246860b0974632cebefff000f4ae"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff2f246860b0974632cebefff000f4ae">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_acts_1_1_constrained_step.html">ConstrainedStep</a> &amp;step)</td></tr>
<tr class="memdesc:aff2f246860b0974632cebefff000f4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for ConstrainedStep.  <br /></td></tr>
<tr class="memitem:a9e78e7ac990dd63dd3acaa80bdb0eb57" id="r_a9e78e7ac990dd63dd3acaa80bdb0eb57"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e78e7ac990dd63dd3acaa80bdb0eb57">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_acts_1_1_i_visualization3_d.html">IVisualization3D</a> &amp;hlp)</td></tr>
<tr class="memdesc:a9e78e7ac990dd63dd3acaa80bdb0eb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for IVisualization3D.  <br /></td></tr>
<tr class="memitem:aa12edcaa0d2e0855219568de3447b8f0" id="r_aa12edcaa0d2e0855219568de3447b8f0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa12edcaa0d2e0855219568de3447b8f0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_acts_1_1_material.html">Material</a> &amp;material)</td></tr>
<tr class="memdesc:aa12edcaa0d2e0855219568de3447b8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for Material.  <br /></td></tr>
<tr class="memitem:a6892e054d938002cb1cc681d19619ad5" id="r_a6892e054d938002cb1cc681d19619ad5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6892e054d938002cb1cc681d19619ad5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;materialSlab)</td></tr>
<tr class="memdesc:a6892e054d938002cb1cc681d19619ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for MaterialSlab.  <br /></td></tr>
<tr class="memitem:ad07b2ff48a82de9bd465cbcdacc066a1" id="r_ad07b2ff48a82de9bd465cbcdacc066a1"><td class="memTemplParams" colspan="2">template&lt;typename T, std::size_t D&gt; </td></tr>
<tr class="memitem:ad07b2ff48a82de9bd465cbcdacc066a1 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07b2ff48a82de9bd465cbcdacc066a1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_acts_1_1_ray.html">Ray</a>&lt; T, D &gt; &amp;ray)</td></tr>
<tr class="memdesc:ad07b2ff48a82de9bd465cbcdacc066a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the outstream operator.  <br /></td></tr>
<tr class="memitem:a143a8d24731524bb6cd89f6cd3891442" id="r_a143a8d24731524bb6cd89f6cd3891442"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a143a8d24731524bb6cd89f6cd3891442">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; <a class="el" href="struct_acts_1_1_directed_proto_axis.html">DirectedProtoAxis</a> &gt; &amp;a)</td></tr>
<tr class="memdesc:a143a8d24731524bb6cd89f6cd3891442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for vector of DirectedProtoAxis.  <br /></td></tr>
<tr class="memitem:a27d200860531f17827d06e26264b903d" id="r_a27d200860531f17827d06e26264b903d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d200860531f17827d06e26264b903d">operator&lt;&lt;</a> (std::ostream &amp;os, const std::vector&lt; <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &gt; &amp;a)</td></tr>
<tr class="memdesc:a27d200860531f17827d06e26264b903d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for vector of ProtoAxis.  <br /></td></tr>
<tr class="memitem:a8dd997fcf86fcd3b1dad24e355dc76ad" id="r_a8dd997fcf86fcd3b1dad24e355dc76ad"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dd997fcf86fcd3b1dad24e355dc76ad">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="struct_acts_1_1_track_selector_1_1_config.html">TrackSelector::Config</a> &amp;cuts)</td></tr>
<tr class="memitem:ae3082f2d05cfd560ec1fdbea0910f489" id="r_ae3082f2d05cfd560ec1fdbea0910f489"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3082f2d05cfd560ec1fdbea0910f489">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="struct_acts_1_1_track_selector_1_1_eta_binned_config.html">TrackSelector::EtaBinnedConfig</a> &amp;cfg)</td></tr>
<tr class="memitem:a9611b708f395b658bf7b6dcc5d003726" id="r_a9611b708f395b658bf7b6dcc5d003726"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9611b708f395b658bf7b6dcc5d003726">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="class_acts_1_1_cuboid_volume_bounds.html#acbc4cbe27928efcbf0da00457ad799ac">CuboidPortalShell::Face</a> face)</td></tr>
<tr class="memdesc:a9611b708f395b658bf7b6dcc5d003726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for the CuboidPortalShell::Face enum.  <br /></td></tr>
<tr class="memitem:a065f7ca1306c553e4f48716204acdb6d" id="r_a065f7ca1306c553e4f48716204acdb6d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a065f7ca1306c553e4f48716204acdb6d">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="class_acts_1_1_cylinder_volume_bounds.html#a51216b38aa994bf843ad58377b046a02">CylinderPortalShell::Face</a> face)</td></tr>
<tr class="memdesc:a065f7ca1306c553e4f48716204acdb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for the CylinderPortalShell::Face enum.  <br /></td></tr>
<tr class="memitem:a4b1f32495595f4b13b24c9acecabadaf" id="r_a4b1f32495595f4b13b24c9acecabadaf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b1f32495595f4b13b24c9acecabadaf">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="class_acts_1_1_diamond_volume_bounds.html#a159c5f1828479b1fd03304934c214b41">DiamondPortalShell::Face</a> face)</td></tr>
<tr class="memitem:a10610de7dd2a36c1945fa5bc214cbbd1" id="r_a10610de7dd2a36c1945fa5bc214cbbd1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10610de7dd2a36c1945fa5bc214cbbd1">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="class_acts_1_1_direction.html">Direction</a> dir)</td></tr>
<tr class="memdesc:a10610de7dd2a36c1945fa5bc214cbbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for Direction.  <br /></td></tr>
<tr class="memitem:a7b065972c1a1757a5262be3fa4ed9e13" id="r_a7b065972c1a1757a5262be3fa4ed9e13"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b065972c1a1757a5262be3fa4ed9e13">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a> id)</td></tr>
<tr class="memdesc:a7b065972c1a1757a5262be3fa4ed9e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for GeometryIdentifier.  <br /></td></tr>
<tr class="memitem:a33de5ebd2b70f42d6ea0a11a1d6025a8" id="r_a33de5ebd2b70f42d6ea0a11a1d6025a8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33de5ebd2b70f42d6ea0a11a1d6025a8">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#af38a8ff832aa2393884b0dbed498973c">HadronType</a> hadron)</td></tr>
<tr class="memitem:a772325cf43d5342e1cb392648abc8dfd" id="r_a772325cf43d5342e1cb392648abc8dfd"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772325cf43d5342e1cb392648abc8dfd">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a52191edec34daa17746d1937fb06c1fb">IntersectionStatus</a> status)</td></tr>
<tr class="memdesc:a772325cf43d5342e1cb392648abc8dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ostream-operator for the IntersectionStatus enum.  <br /></td></tr>
<tr class="memitem:aaf945d5e789508b76330e694c2a986e2" id="r_aaf945d5e789508b76330e694c2a986e2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf945d5e789508b76330e694c2a986e2">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02">MaterialUpdateStage</a> matUpdate)</td></tr>
<tr class="memdesc:aaf945d5e789508b76330e694c2a986e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for MaterialUpdateStage.  <br /></td></tr>
<tr class="memitem:a08e665476c1a12306164bb3aec8904a1" id="r_a08e665476c1a12306164bb3aec8904a1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e665476c1a12306164bb3aec8904a1">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a08e665476c1a12306164bb3aec8904a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print PDG particle numbers with a descriptive name.  <br /></td></tr>
<tr class="memitem:a791f673965f85f8c894dd07a00d8bd61" id="r_a791f673965f85f8c894dd07a00d8bd61"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791f673965f85f8c894dd07a00d8bd61">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> mask)</td></tr>
<tr class="memdesc:a791f673965f85f8c894dd07a00d8bd61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for TrackStatePropMask.  <br /></td></tr>
<tr class="memitem:a37a7254cbaee8f26160339b7a71879ec" id="r_a37a7254cbaee8f26160339b7a71879ec"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a7254cbaee8f26160339b7a71879ec">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="class_acts_1_1_trapezoid_volume_bounds.html#a37a239bc146009fe37f583174d13feeb">TrapezoidPortalShell::Face</a> face)</td></tr>
<tr class="memdesc:a37a7254cbaee8f26160339b7a71879ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output stream operator for the TrapezoidPortalShell::Face enum.  <br /></td></tr>
<tr class="memitem:a9a735e14b24e2da1c37ef72e699a65c7" id="r_a9a735e14b24e2da1c37ef72e699a65c7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a735e14b24e2da1c37ef72e699a65c7">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848">VolumeAttachmentStrategy</a> strategy)</td></tr>
<tr class="memdesc:a9a735e14b24e2da1c37ef72e699a65c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for VolumeAttachmentStrategy.  <br /></td></tr>
<tr class="memitem:ac927a1726a9183b3cec107a3dde66eba" id="r_ac927a1726a9183b3cec107a3dde66eba"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac927a1726a9183b3cec107a3dde66eba">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="#a8e7b9ba567f3fce3fb39c1c9ce093e93">VolumeResizeStrategy</a> strategy)</td></tr>
<tr class="memdesc:ac927a1726a9183b3cec107a3dde66eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for VolumeResizeStrategy.  <br /></td></tr>
<tr class="memitem:a9c79baf2a53c547a0ca47f008c6230d8" id="r_a9c79baf2a53c547a0ca47f008c6230d8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c79baf2a53c547a0ca47f008c6230d8">operator&lt;&lt;</a> (std::ostream &amp;sl, const <a class="el" href="class_acts_1_1_extent.html">Extent</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9c79baf2a53c547a0ca47f008c6230d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &lt;&lt; operator for std::ostream for debug output.  <br /></td></tr>
<tr class="memitem:a782bdddc08a3a0fcdd0412cb04976b9a" id="r_a782bdddc08a3a0fcdd0412cb04976b9a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a782bdddc08a3a0fcdd0412cb04976b9a">operator&lt;&lt;</a> (std::ostream &amp;sl, const <a class="el" href="class_acts_1_1_glue_volumes_descriptor.html">GlueVolumesDescriptor</a> &amp;gvd)</td></tr>
<tr class="memdesc:a782bdddc08a3a0fcdd0412cb04976b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for GlueVolumesDescriptor.  <br /></td></tr>
<tr class="memitem:acba1f415cfc3ca78946e3da805258994" id="r_acba1f415cfc3ca78946e3da805258994"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba1f415cfc3ca78946e3da805258994">operator&lt;&lt;</a> (std::ostream &amp;sl, const <a class="el" href="class_acts_1_1_volume.html">Volume</a> &amp;vol)</td></tr>
<tr class="memdesc:acba1f415cfc3ca78946e3da805258994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &lt;&lt; operator for std::ostream for debug output.  <br /></td></tr>
<tr class="memitem:aabd1454e2e9e50489ad2e76fb3b3efc3" id="r_aabd1454e2e9e50489ad2e76fb3b3efc3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabd1454e2e9e50489ad2e76fb3b3efc3">operator&lt;&lt;</a> (std::ostream &amp;sl, const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;vb)</td></tr>
<tr class="memdesc:aabd1454e2e9e50489ad2e76fb3b3efc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of &lt;&lt; operator for std::ostream for debug output.  <br /></td></tr>
<tr class="memitem:a8f4f4d5d7389b079520fdf69e9a827a8" id="r_a8f4f4d5d7389b079520fdf69e9a827a8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f4f4d5d7389b079520fdf69e9a827a8">operator&lt;&lt;</a> (std::ostream &amp;sl, const <a class="el" href="class_acts_1_1_volume_bounds.html#a3840f312b207bfdd5cbbcc4ac9981495">VolumeBounds::BoundsType</a> &amp;bt)</td></tr>
<tr class="memdesc:a8f4f4d5d7389b079520fdf69e9a827a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for VolumeBounds::BoundsType.  <br /></td></tr>
<tr class="memitem:a26ed6ffd83366a80eb98a79799a707e2" id="r_a26ed6ffd83366a80eb98a79799a707e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26ed6ffd83366a80eb98a79799a707e2">operator==</a> (const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;lhs, const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;rhs)</td></tr>
<tr class="memdesc:a26ed6ffd83366a80eb98a79799a707e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison for VolumeBounds.  <br /></td></tr>
<tr class="memitem:a792bc132f7117ed5a07faf80ec2ef0c3" id="r_a792bc132f7117ed5a07faf80ec2ef0c3"><td class="memTemplParams" colspan="2">template&lt;typename local_bin&gt; </td></tr>
<tr class="memitem:a792bc132f7117ed5a07faf80ec2ef0c3 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a792bc132f7117ed5a07faf80ec2ef0c3">outputIndices</a> (const std::set&lt; local_bin &gt; &amp;lbins)</td></tr>
<tr class="memdesc:a792bc132f7117ed5a07faf80ec2ef0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to screen output the local bins.  <br /></td></tr>
<tr class="memitem:accbf0a2a5f699fb8704e1cc75aee2121" id="r_accbf0a2a5f699fb8704e1cc75aee2121"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:accbf0a2a5f699fb8704e1cc75aee2121 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accbf0a2a5f699fb8704e1cc75aee2121">overloaded</a> (Ts...) -&gt; overloaded&lt; Ts... &gt;</td></tr>
<tr class="memdesc:accbf0a2a5f699fb8704e1cc75aee2121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for overloaded visitor pattern.  <br /></td></tr>
<tr class="memitem:a59e8d56f5a930d507527de2100a1adc4" id="r_a59e8d56f5a930d507527de2100a1adc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59e8d56f5a930d507527de2100a1adc4">parsePdgParticle</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a59e8d56f5a930d507527de2100a1adc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a PdgParticle from a particle name string.  <br /></td></tr>
<tr class="memitem:a1701552b7b37a88b1b91c012100d690a" id="r_a1701552b7b37a88b1b91c012100d690a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1701552b7b37a88b1b91c012100d690a">pdgToShortAbsString</a> (<a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> pdg)</td></tr>
<tr class="memdesc:a1701552b7b37a88b1b91c012100d690a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get short absolute string representation of PDG particle.  <br /></td></tr>
<tr class="memitem:a5f8134aad04c378ce314dd9e115f3c17" id="r_a5f8134aad04c378ce314dd9e115f3c17"><td class="memTemplParams" colspan="2">template&lt;typename T, std::integral P&gt; </td></tr>
<tr class="memitem:a5f8134aad04c378ce314dd9e115f3c17 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8134aad04c378ce314dd9e115f3c17">pow</a> (T x, P p)</td></tr>
<tr class="memdesc:a5f8134aad04c378ce314dd9e115f3c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the ordinary power of the number x.  <br /></td></tr>
<tr class="memitem:a0a9dad86571acffdac06f3af7087d27f" id="r_a0a9dad86571acffdac06f3af7087d27f"><td class="memTemplParams" colspan="2">template&lt;std::size_t kFullSize, typename Derived&gt; </td></tr>
<tr class="memitem:a0a9dad86571acffdac06f3af7087d27f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; kFullSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a9dad86571acffdac06f3af7087d27f">projectorToSubspaceIndices</a> (const Eigen::DenseBase&lt; Derived &gt; &amp;projector)</td></tr>
<tr class="memdesc:a0a9dad86571acffdac06f3af7087d27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a projector to subspace indices.  <br /></td></tr>
<tr class="memitem:a65c77310254a757a6edcb57a670d058c" id="r_a65c77310254a757a6edcb57a670d058c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a65c77310254a757a6edcb57a670d058c template"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; typename T::value_type, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65c77310254a757a6edcb57a670d058c">range_medium</a> (const T &amp;tseries)</td></tr>
<tr class="memdesc:a65c77310254a757a6edcb57a670d058c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return range and medium of an unsorted numeric series.  <br /></td></tr>
<tr class="memitem:ac6d9beca13049b91d5c9e5991f60532d" id="r_ac6d9beca13049b91d5c9e5991f60532d"><td class="memTemplParams" colspan="2">template&lt;typename R, typename T&gt; </td></tr>
<tr class="memitem:ac6d9beca13049b91d5c9e5991f60532d template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6d9beca13049b91d5c9e5991f60532d">rangeContainsValue</a> (const R &amp;range, const T &amp;value)</td></tr>
<tr class="memdesc:ac6d9beca13049b91d5c9e5991f60532d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be replaced with C++23 to use the std::ranges::contains method.  <br /></td></tr>
<tr class="memitem:ga78aa81ac4054e37064a177c3d0593f75" id="r_ga78aa81ac4054e37064a177c3d0593f75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__track__fitting.html#ga78aa81ac4054e37064a177c3d0593f75">reduceMixtureLargestWeights</a> (std::vector&lt; <a class="el" href="struct_acts_1_1_gsf_component.html">Acts::GsfComponent</a> &gt; &amp;cmpCache, std::size_t maxCmpsAfterMerge, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface)</td></tr>
<tr class="memdesc:ga78aa81ac4054e37064a177c3d0593f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simple mixture reduction method: Just removes the components with the smallest weight until the required number of components is reached.  <br /></td></tr>
<tr class="memitem:ga2d42e87cd0bd4eb9a52fa04db44f033d" id="r_ga2d42e87cd0bd4eb9a52fa04db44f033d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__track__fitting.html#ga2d42e87cd0bd4eb9a52fa04db44f033d">reduceMixtureWithKLDistance</a> (std::vector&lt; <a class="el" href="struct_acts_1_1_gsf_component.html">GsfComponent</a> &gt; &amp;cmpCache, std::size_t maxCmpsAfterMerge, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface)</td></tr>
<tr class="memdesc:ga2d42e87cd0bd4eb9a52fa04db44f033d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greedy component reduction algorithm.  <br /></td></tr>
<tr class="memitem:a448dd6193a51777a8b7c05bb1a5630eb" id="r_a448dd6193a51777a8b7c05bb1a5630eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a448dd6193a51777a8b7c05bb1a5630eb">reflectBoundParameters</a> (const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;boundParams)</td></tr>
<tr class="memdesc:a448dd6193a51777a8b7c05bb1a5630eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflect bound track parameters.  <br /></td></tr>
<tr class="memitem:a13a84cd96d8549b4be2395a91041f6cf" id="r_a13a84cd96d8549b4be2395a91041f6cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13a84cd96d8549b4be2395a91041f6cf">reflectFreeParameters</a> (const <a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;freeParams)</td></tr>
<tr class="memdesc:a13a84cd96d8549b4be2395a91041f6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflect free track parameters.  <br /></td></tr>
<tr class="memitem:ac74ee49f1e16ede102272f390974153b" id="r_ac74ee49f1e16ede102272f390974153b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ac74ee49f1e16ede102272f390974153b template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac74ee49f1e16ede102272f390974153b">safeExp</a> (T val) noexcept</td></tr>
<tr class="memdesc:ac74ee49f1e16ede102272f390974153b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the exponential function while avoiding FPEs.  <br /></td></tr>
<tr class="memitem:a578b23613377e931e706252251c5f9ad" id="r_a578b23613377e931e706252251c5f9ad"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType, typename ResultType = MatrixType&gt; </td></tr>
<tr class="memitem:a578b23613377e931e706252251c5f9ad template"><td class="memItemLeft" align="right" valign="top">std::optional&lt; ResultType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a578b23613377e931e706252251c5f9ad">safeInverse</a> (const MatrixType &amp;m) noexcept</td></tr>
<tr class="memdesc:a578b23613377e931e706252251c5f9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">FPE "safe" functions.  <br /></td></tr>
<tr class="memitem:a3cd785914bda5c3810e21a5f54386fd5" id="r_a3cd785914bda5c3810e21a5f54386fd5"><td class="memTemplParams" colspan="2">template&lt;std::size_t FullSize&gt; <br />
requires (FullSize &lt;= 8)</td></tr>
<tr class="memitem:a3cd785914bda5c3810e21a5f54386fd5 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ac7fe124c6f6fda8fa31781f93cbd36b8">SerializedSubspaceIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cd785914bda5c3810e21a5f54386fd5">serializeSubspaceIndices</a> (const <a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; FullSize &gt; &amp;indices)</td></tr>
<tr class="memdesc:a3cd785914bda5c3810e21a5f54386fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize subspace indices to a single 64 bit integer.  <br /></td></tr>
<tr class="memitem:af71f1524930917d44ddc5444d2b5193f" id="r_af71f1524930917d44ddc5444d2b5193f"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t, typename smoother_t = GainMatrixSmoother&gt; </td></tr>
<tr class="memitem:af71f1524930917d44ddc5444d2b5193f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af71f1524930917d44ddc5444d2b5193f">smoothTrack</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;geoContext, track_proxy_t &amp;track, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger= *<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackSmoother&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>), smoother_t smoother=<a class="el" href="class_acts_1_1_gain_matrix_smoother.html">GainMatrixSmoother</a>())</td></tr>
<tr class="memdesc:af71f1524930917d44ddc5444d2b5193f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a track using the gain matrix smoother.  <br /></td></tr>
<tr class="memitem:aa55a3919271931efb60a076dc3a7bf8c" id="r_aa55a3919271931efb60a076dc3a7bf8c"><td class="memTemplParams" colspan="2">template&lt;TrackContainerFrontend track_container_t&gt; </td></tr>
<tr class="memitem:aa55a3919271931efb60a076dc3a7bf8c template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa55a3919271931efb60a076dc3a7bf8c">smoothTracks</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;geoContext, const track_container_t &amp;trackContainer, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger= *<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackSmoother&quot;, <a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>))</td></tr>
<tr class="memdesc:aa55a3919271931efb60a076dc3a7bf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth tracks using the gain matrix smoother.  <br /></td></tr>
<tr class="memitem:ga5036eb1d51177fbb2503f1dc623d197b" id="r_ga5036eb1d51177fbb2503f1dc623d197b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__magnetic__field.html#ga5036eb1d51177fbb2503f1dc623d197b">solenoidFieldMap</a> (const std::pair&lt; double, double &gt; &amp;rLim, const std::pair&lt; double, double &gt; &amp;zLim, const std::pair&lt; std::size_t, std::size_t &gt; &amp;nBins, const <a class="el" href="class_acts_1_1_solenoid_b_field.html">SolenoidBField</a> &amp;field)</td></tr>
<tr class="memdesc:ga5036eb1d51177fbb2503f1dc623d197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which takes an existing SolenoidBField instance and creates a field mapper by sampling grid points from the analytical solenoid field.  <br /></td></tr>
<tr class="memitem:a7f3025a1035f83082b5d5bc164041ae7" id="r_a7f3025a1035f83082b5d5bc164041ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; 3, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f3025a1035f83082b5d5bc164041ae7">sphericalToFreeDirectionJacobian</a> (const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction)</td></tr>
<tr class="memdesc:a7f3025a1035f83082b5d5bc164041ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Jacobian for spherical to free direction vector transformation.  <br /></td></tr>
<tr class="memitem:a838abb77213dd8944857456b1e506b02" id="r_a838abb77213dd8944857456b1e506b02"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a838abb77213dd8944857456b1e506b02 template"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838abb77213dd8944857456b1e506b02">square</a> (T x)</td></tr>
<tr class="memdesc:a838abb77213dd8944857456b1e506b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of the passed number.  <br /></td></tr>
<tr class="memitem:a263c06f4eb074079421fd6fefe19a873" id="r_a263c06f4eb074079421fd6fefe19a873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a263c06f4eb074079421fd6fefe19a873">subtractBoundParameters</a> (const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;lhs, const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;rhs)</td></tr>
<tr class="memdesc:a263c06f4eb074079421fd6fefe19a873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract bound parameters and take care of angle periodicity for phi and theta.  <br /></td></tr>
<tr class="memitem:ad66d0dd0baa4fbbc5e1bdbe45a311bd6" id="r_ad66d0dd0baa4fbbc5e1bdbe45a311bd6"><td class="memTemplParams" colspan="2">template&lt;std::integral T&gt; </td></tr>
<tr class="memitem:ad66d0dd0baa4fbbc5e1bdbe45a311bd6 template"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad66d0dd0baa4fbbc5e1bdbe45a311bd6">sumUpToN</a> (const T N)</td></tr>
<tr class="memdesc:ad66d0dd0baa4fbbc5e1bdbe45a311bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the sum of 1 + 2 + 3+ ... + N using the Gaussian sum formula.  <br /></td></tr>
<tr class="memitem:ga4ca3159a74a3264197f5b171cd3b7947" id="r_ga4ca3159a74a3264197f5b171cd3b7947"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga4ca3159a74a3264197f5b171cd3b7947">surfaceFromJson</a> (const nlohmann::json &amp;j)</td></tr>
<tr class="memdesc:ga4ca3159a74a3264197f5b171cd3b7947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to Surface from jsonn.  <br /></td></tr>
<tr class="memitem:ga9de363bbc466a833fcb345436142d784" id="r_ga9de363bbc466a833fcb345436142d784"><td class="memTemplParams" colspan="2">template&lt;typename surface_t, typename bounds_t&gt; </td></tr>
<tr class="memitem:ga9de363bbc466a833fcb345436142d784 template"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; surface_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga9de363bbc466a833fcb345436142d784">surfaceFromJsonT</a> (const nlohmann::json &amp;j)</td></tr>
<tr class="memdesc:ga9de363bbc466a833fcb345436142d784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion to Surface from json in correct type.  <br /></td></tr>
<tr class="memitem:a53977e204b4bd2fafd0c06c26ab2332a" id="r_a53977e204b4bd2fafd0c06c26ab2332a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; <br />
requires (N &gt; 1)</td></tr>
<tr class="memitem:a53977e204b4bd2fafd0c06c26ab2332a template"><td class="memItemLeft" align="right" valign="top">constexpr std::array&lt; std::size_t, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53977e204b4bd2fafd0c06c26ab2332a">symMatIndices</a> (const std::size_t k)</td></tr>
<tr class="memdesc:a53977e204b4bd2fafd0c06c26ab2332a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an unrolled vector index to the indices of the lower triangular part of a symmetric N x N matrix.  <br /></td></tr>
<tr class="memitem:a41bb20848824690a2a72250980a81e4e" id="r_a41bb20848824690a2a72250980a81e4e"><td class="memTemplParams" colspan="2">template&lt;template&lt; std::size_t &gt; class Callable, std::size_t N, std::size_t NMAX, typename... Args&gt; </td></tr>
<tr class="memitem:a41bb20848824690a2a72250980a81e4e template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41bb20848824690a2a72250980a81e4e">template_switch</a> (std::size_t v, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a41bb20848824690a2a72250980a81e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a call based on a runtime value on a function taking the value at compile time.  <br /></td></tr>
<tr class="memitem:a508ee0f24c070e5785bb517a4b449e69" id="r_a508ee0f24c070e5785bb517a4b449e69"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, std::size_t NMAX, typename Lambda, typename... Args&gt; </td></tr>
<tr class="memitem:a508ee0f24c070e5785bb517a4b449e69 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a508ee0f24c070e5785bb517a4b449e69">template_switch_lambda</a> (std::size_t v, Lambda &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a508ee0f24c070e5785bb517a4b449e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative version of <code>template_switch</code> which accepts a generic lambda and communicates the dimension via an integral constant type.  <br /></td></tr>
<tr class="memitem:ga21008d4899b84f5e09b90b3414557299" id="r_ga21008d4899b84f5e09b90b3414557299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga21008d4899b84f5e09b90b3414557299">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_tracking_volume.html">Acts::TrackingVolume</a> &amp;volume)</td></tr>
<tr class="memdesc:ga21008d4899b84f5e09b90b3414557299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert TrackingVolume to JSON.  <br /></td></tr>
<tr class="memitem:ga0180294a7f0ba9cf68cfe12f157c86e5" id="r_ga0180294a7f0ba9cf68cfe12f157c86e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga0180294a7f0ba9cf68cfe12f157c86e5">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_binning_data.html">BinningData</a> &amp;bd)</td></tr>
<tr class="memitem:ga59cce586dc4783924d42ab22a11ecce9" id="r_ga59cce586dc4783924d42ab22a11ecce9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga59cce586dc4783924d42ab22a11ecce9">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;bu)</td></tr>
<tr class="memitem:ga26b713fc99a501d9b357b63b96e19dfa" id="r_ga26b713fc99a501d9b357b63b96e19dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga26b713fc99a501d9b357b63b96e19dfa">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_direction.html">Direction</a> &amp;direction)</td></tr>
<tr class="memdesc:ga26b713fc99a501d9b357b63b96e19dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Direction to JSON.  <br /></td></tr>
<tr class="memitem:ga8a0f735e5875adc3ba5c0106bccefbae" id="r_ga8a0f735e5875adc3ba5c0106bccefbae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga8a0f735e5875adc3ba5c0106bccefbae">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_extent.html">Extent</a> &amp;e)</td></tr>
<tr class="memdesc:ga8a0f735e5875adc3ba5c0106bccefbae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Extent to JSON.  <br /></td></tr>
<tr class="memitem:ga0fab3553d846cec4d455eb7f44ca1d7a" id="r_ga0fab3553d846cec4d455eb7f44ca1d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga0fab3553d846cec4d455eb7f44ca1d7a">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a> &amp;geoId)</td></tr>
<tr class="memdesc:ga0fab3553d846cec4d455eb7f44ca1d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to JSON.  <br /></td></tr>
<tr class="memitem:ga1a3142c2ce27ed106170462aeeafbb53" id="r_ga1a3142c2ce27ed106170462aeeafbb53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga1a3142c2ce27ed106170462aeeafbb53">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_material.html">Material</a> &amp;t)</td></tr>
<tr class="memdesc:ga1a3142c2ce27ed106170462aeeafbb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Material to JSON.  <br /></td></tr>
<tr class="memitem:ga98f720573bfa68ab9ec67df6d8db62e6" id="r_ga98f720573bfa68ab9ec67df6d8db62e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga98f720573bfa68ab9ec67df6d8db62e6">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;t)</td></tr>
<tr class="memdesc:ga98f720573bfa68ab9ec67df6d8db62e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert MaterialSlab to JSON.  <br /></td></tr>
<tr class="memitem:gabad51c31738ea580fcb4e9614ddd8cf1" id="r_gabad51c31738ea580fcb4e9614ddd8cf1"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&gt; </td></tr>
<tr class="memitem:gabad51c31738ea580fcb4e9614ddd8cf1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gabad51c31738ea580fcb4e9614ddd8cf1">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="#a81478db625a7b35501d5f651f5d1d4fd">Range1D</a>&lt; <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &gt; &amp;r)</td></tr>
<tr class="memitem:ga5af5a5026fb849391b1b09925ede21e0" id="r_ga5af5a5026fb849391b1b09925ede21e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga5af5a5026fb849391b1b09925ede21e0">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="struct_acts_1_1_seed_confirmation_range_config.html">SeedConfirmationRangeConfig</a> &amp;config)</td></tr>
<tr class="memdesc:ga5af5a5026fb849391b1b09925ede21e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SeedConfirmationRangeConfig to JSON.  <br /></td></tr>
<tr class="memitem:ga647ad5af1e3dffc5af39b6801389b63d" id="r_ga647ad5af1e3dffc5af39b6801389b63d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga647ad5af1e3dffc5af39b6801389b63d">to_json</a> (nlohmann::json &amp;j, const std::pair&lt; const <a class="el" href="class_acts_1_1_tracking_volume.html">Acts::TrackingVolume</a> *, std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_volume_material.html">Acts::IVolumeMaterial</a> &gt; &gt; &amp;volume)</td></tr>
<tr class="memdesc:ga647ad5af1e3dffc5af39b6801389b63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert tracking volume and material pair to JSON.  <br /></td></tr>
<tr class="memitem:ga240eac27cbc771b52c37d5d81c4f2f0d" id="r_ga240eac27cbc771b52c37d5d81c4f2f0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga240eac27cbc771b52c37d5d81c4f2f0d">to_json</a> (nlohmann::json &amp;j, const std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt; &amp;surface)</td></tr>
<tr class="memdesc:ga240eac27cbc771b52c37d5d81c4f2f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert shared_ptr&lt;Surface&gt; to JSON.  <br /></td></tr>
<tr class="memitem:ga0b5db5f2bb37675ffd77e0519bb0248c" id="r_ga0b5db5f2bb37675ffd77e0519bb0248c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga0b5db5f2bb37675ffd77e0519bb0248c">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface)</td></tr>
<tr class="memdesc:ga0b5db5f2bb37675ffd77e0519bb0248c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Surface to JSON.  <br /></td></tr>
<tr class="memitem:ga597f24ebfad3f6ec84f18609ed46d977" id="r_ga597f24ebfad3f6ec84f18609ed46d977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga597f24ebfad3f6ec84f18609ed46d977">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="group__json__plugin.html#gab39fab40696fab1b03cca78f951db023">SurfaceAndMaterialWithContext</a> &amp;surface)</td></tr>
<tr class="memdesc:ga597f24ebfad3f6ec84f18609ed46d977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SurfaceAndMaterialWithContext to JSON.  <br /></td></tr>
<tr class="memitem:gaddc4fb68110ec50ce4e8077164cdc3fe" id="r_gaddc4fb68110ec50ce4e8077164cdc3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gaddc4fb68110ec50ce4e8077164cdc3fe">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_surface_bounds.html">SurfaceBounds</a> &amp;bounds)</td></tr>
<tr class="memdesc:gaddc4fb68110ec50ce4e8077164cdc3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert SurfaceBounds to JSON.  <br /></td></tr>
<tr class="memitem:gacf3669471f11a629a8de8cd7fd8b0579" id="r_gacf3669471f11a629a8de8cd7fd8b0579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#gacf3669471f11a629a8de8cd7fd8b0579">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="group__json__plugin.html#ga76d1cebc6f43c76e5aaa8ef77d474064">surfaceMaterialPointer</a> &amp;material)</td></tr>
<tr class="memdesc:gacf3669471f11a629a8de8cd7fd8b0579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert surfaceMaterialPointer to JSON.  <br /></td></tr>
<tr class="memitem:ga1337ac3c5d40bcc0364404edc0093acc" id="r_ga1337ac3c5d40bcc0364404edc0093acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga1337ac3c5d40bcc0364404edc0093acc">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;t)</td></tr>
<tr class="memdesc:ga1337ac3c5d40bcc0364404edc0093acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Transform3 to JSON.  <br /></td></tr>
<tr class="memitem:ga7bd8c6518220699d3b8523a29bbed679" id="r_ga7bd8c6518220699d3b8523a29bbed679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga7bd8c6518220699d3b8523a29bbed679">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;bounds)</td></tr>
<tr class="memdesc:ga7bd8c6518220699d3b8523a29bbed679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert VolumeBounds to JSON.  <br /></td></tr>
<tr class="memitem:ga8883ce55bef32607470a0518e62d4818" id="r_ga8883ce55bef32607470a0518e62d4818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga8883ce55bef32607470a0518e62d4818">to_json</a> (nlohmann::json &amp;j, const <a class="el" href="group__json__plugin.html#ga06973c0a57ed2cedc63a4e66a33eb4ae">volumeMaterialPointer</a> &amp;material)</td></tr>
<tr class="memdesc:ga8883ce55bef32607470a0518e62d4818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert volumeMaterialPointer to JSON.  <br /></td></tr>
<tr class="memitem:af63cae486ae37da877b7ec92f7a74f1e" id="r_af63cae486ae37da877b7ec92f7a74f1e"><td class="memTemplParams" colspan="2">template&lt;std::size_t kDIM, typename value_t&gt; </td></tr>
<tr class="memitem:af63cae486ae37da877b7ec92f7a74f1e template"><td class="memItemLeft" align="right" valign="top">std::array&lt; value_t, kDIM &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af63cae486ae37da877b7ec92f7a74f1e">toArray</a> (const std::vector&lt; value_t &gt; &amp;vecvals)</td></tr>
<tr class="memdesc:af63cae486ae37da877b7ec92f7a74f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector to a fixed-size array with truncating or padding.  <br /></td></tr>
<tr class="memitem:ga0d44dfc16a076ea3977b8d4632e0bd71" id="r_ga0d44dfc16a076ea3977b8d4632e0bd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__json__plugin.html#ga0d44dfc16a076ea3977b8d4632e0bd71">toJson</a> (nlohmann::json &amp;j, const std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt; &amp;surface, const <a class="el" href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a> &amp;gctx)</td></tr>
<tr class="memdesc:ga0d44dfc16a076ea3977b8d4632e0bd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contextual conversion of a surface.  <br /></td></tr>
<tr class="memitem:a9a4d2dc77ae0f047a17aa6a9af7f97b6" id="r_a9a4d2dc77ae0f047a17aa6a9af7f97b6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a4d2dc77ae0f047a17aa6a9af7f97b6">toString</a> (const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Acts::Transform3</a> &amp;transform, int precision=4, const std::string &amp;offset=&quot;&quot;)</td></tr>
<tr class="memdesc:a9a4d2dc77ae0f047a17aa6a9af7f97b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a transform in a structured way.  <br /></td></tr>
<tr class="memitem:a4f4ce7355440a386097b704d74051925" id="r_a4f4ce7355440a386097b704d74051925"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f4ce7355440a386097b704d74051925">toString</a> (const <a class="el" href="group__algebra__types.html#ga1a7960bfb4807cba616fd8bdf81d3d00">Acts::Translation3</a> &amp;translation, int precision=4)</td></tr>
<tr class="memdesc:a4f4ce7355440a386097b704d74051925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a translation in a structured way.  <br /></td></tr>
<tr class="memitem:a9b366bb0c46e39601d88e99f770a0b37" id="r_a9b366bb0c46e39601d88e99f770a0b37"><td class="memTemplParams" colspan="2">template&lt;typename derived_t&gt; </td></tr>
<tr class="memitem:a9b366bb0c46e39601d88e99f770a0b37 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b366bb0c46e39601d88e99f770a0b37">toString</a> (const Eigen::MatrixBase&lt; derived_t &gt; &amp;matrix, int precision=4, const std::string &amp;offset=&quot;&quot;)</td></tr>
<tr class="memdesc:a9b366bb0c46e39601d88e99f770a0b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a matrix in a structured way.  <br /></td></tr>
<tr class="memitem:afd7b6468aa0247124a2f6e19ed60bfd0" id="r_afd7b6468aa0247124a2f6e19ed60bfd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd7b6468aa0247124a2f6e19ed60bfd0">toString</a> (const std::vector&lt; double &gt; &amp;pVector, int precision=4)</td></tr>
<tr class="memdesc:afd7b6468aa0247124a2f6e19ed60bfd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a vector of double.  <br /></td></tr>
<tr class="memitem:a4e21d6cf5d7c1244c2f008471cc5ba7e" id="r_a4e21d6cf5d7c1244c2f008471cc5ba7e"><td class="memTemplParams" colspan="2">template&lt;typename enum_t&gt; </td></tr>
<tr class="memitem:a4e21d6cf5d7c1244c2f008471cc5ba7e template"><td class="memItemLeft" align="right" valign="top">constexpr std::underlying_type_t&lt; enum_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e21d6cf5d7c1244c2f008471cc5ba7e">toUnderlying</a> (enum_t value)</td></tr>
<tr class="memdesc:a4e21d6cf5d7c1244c2f008471cc5ba7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert enum to its underlying type value.  <br /></td></tr>
<tr class="memitem:a0797332fbe40a114904edb3cba7fe644" id="r_a0797332fbe40a114904edb3cba7fe644"><td class="memTemplParams" colspan="2">template&lt;TrackContainerBackend track_container_t, typename traj_t&gt; </td></tr>
<tr class="memitem:a0797332fbe40a114904edb3cba7fe644 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0797332fbe40a114904edb3cba7fe644">TrackContainer</a> (const track_container_t &amp;container, const traj_t &amp;traj) -&gt; TrackContainer&lt; track_container_t, traj_t, detail::ConstRefHolder &gt;</td></tr>
<tr class="memdesc:a0797332fbe40a114904edb3cba7fe644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for TrackContainer with const references.  <br /></td></tr>
<tr class="memitem:a063c0b62e180a9fa73dff3dff298388a" id="r_a063c0b62e180a9fa73dff3dff298388a"><td class="memTemplParams" colspan="2">template&lt;TrackContainerBackend track_container_t, typename traj_t&gt; </td></tr>
<tr class="memitem:a063c0b62e180a9fa73dff3dff298388a template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a063c0b62e180a9fa73dff3dff298388a">TrackContainer</a> (track_container_t &amp;&amp;container, traj_t &amp;&amp;traj) -&gt; TrackContainer&lt; track_container_t, traj_t, detail::ValueHolder &gt;</td></tr>
<tr class="memdesc:a063c0b62e180a9fa73dff3dff298388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for TrackContainer with rvalue references.  <br /></td></tr>
<tr class="memitem:a8cc9b6fab49588cfd71d4bef57098a06" id="r_a8cc9b6fab49588cfd71d4bef57098a06"><td class="memTemplParams" colspan="2">template&lt;TrackContainerBackend track_container_t, typename traj_t&gt; </td></tr>
<tr class="memitem:a8cc9b6fab49588cfd71d4bef57098a06 template"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cc9b6fab49588cfd71d4bef57098a06">TrackContainer</a> (track_container_t &amp;container, traj_t &amp;traj) -&gt; TrackContainer&lt; track_container_t, traj_t, detail::RefHolder &gt;</td></tr>
<tr class="memdesc:a8cc9b6fab49588cfd71d4bef57098a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for TrackContainer with lvalue references.  <br /></td></tr>
<tr class="memitem:ad9f59a5d52f546c1b662706a19fa5f42" id="r_ad9f59a5d52f546c1b662706a19fa5f42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f59a5d52f546c1b662706a19fa5f42">transformBoundToFreeParameters</a> (const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;geoCtx, const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;boundParams)</td></tr>
<tr class="memdesc:ad9f59a5d52f546c1b662706a19fa5f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform bound track parameters into equivalent free track parameters.  <br /></td></tr>
<tr class="memitem:a03e61ea4aa32eba6186f7b1151eab506" id="r_a03e61ea4aa32eba6186f7b1151eab506"><td class="memTemplParams" colspan="2">template&lt;typename external_spacepoint_t, typename callable_t&gt; </td></tr>
<tr class="memitem:a03e61ea4aa32eba6186f7b1151eab506 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_lin_circle.html">LinCircle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03e61ea4aa32eba6186f7b1151eab506">transformCoordinates</a> (<a class="el" href="class_acts_1_1_space_point_mutable_data.html">Acts::SpacePointMutableData</a> &amp;mutableData, const external_spacepoint_t &amp;sp, const external_spacepoint_t &amp;spM, bool bottom, callable_t &amp;&amp;extractFunction)</td></tr>
<tr class="memdesc:a03e61ea4aa32eba6186f7b1151eab506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a single spacepoint to u-v space coordinates.  <br /></td></tr>
<tr class="memitem:ac6f70f8d70a4d580df9fb45724d40b82" id="r_ac6f70f8d70a4d580df9fb45724d40b82"><td class="memTemplParams" colspan="2">template&lt;typename external_spacepoint_t&gt; </td></tr>
<tr class="memitem:ac6f70f8d70a4d580df9fb45724d40b82 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6f70f8d70a4d580df9fb45724d40b82">transformCoordinates</a> (<a class="el" href="class_acts_1_1_space_point_mutable_data.html">Acts::SpacePointMutableData</a> &amp;mutableData, const std::vector&lt; const external_spacepoint_t * &gt; &amp;vec, const external_spacepoint_t &amp;spM, bool bottom, std::vector&lt; <a class="el" href="struct_acts_1_1_lin_circle.html">LinCircle</a> &gt; &amp;linCircleVec)</td></tr>
<tr class="memdesc:ac6f70f8d70a4d580df9fb45724d40b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a vector of spacepoints to u-v space circles with respect to a given middle spacepoint.  <br /></td></tr>
<tr class="memitem:a68a45911e56331406f861490dc249b1c" id="r_a68a45911e56331406f861490dc249b1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68a45911e56331406f861490dc249b1c">transformFreeToBoundParameters</a> (const <a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;freeParams, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;geoCtx, double tolerance=<a class="el" href="#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a>)</td></tr>
<tr class="memdesc:a68a45911e56331406f861490dc249b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert free track parameters to bound track parameters.  <br /></td></tr>
<tr class="memitem:ae82c7a6d9af871513fdea936d657a12d" id="r_ae82c7a6d9af871513fdea936d657a12d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae82c7a6d9af871513fdea936d657a12d">transformFreeToBoundParameters</a> (const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, double time, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction, double qOverP, const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;surface, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;geoCtx, double tolerance=<a class="el" href="#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a>)</td></tr>
<tr class="memdesc:ae82c7a6d9af871513fdea936d657a12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert position and direction to bound track parameters.  <br /></td></tr>
<tr class="memitem:a75b7d632126d8eca83e972e0a282ffa1" id="r_a75b7d632126d8eca83e972e0a282ffa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b7d632126d8eca83e972e0a282ffa1">transformFreeToCurvilinearParameters</a> (double time, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction, double qOverP)</td></tr>
<tr class="memdesc:a75b7d632126d8eca83e972e0a282ffa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert direction to curvilinear track parameters.  <br /></td></tr>
<tr class="memitem:a0df692764710bba740096a20fd161cf0" id="r_a0df692764710bba740096a20fd161cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0df692764710bba740096a20fd161cf0">transformFreeToCurvilinearParameters</a> (double time, double phi, double theta, double qOverP)</td></tr>
<tr class="memdesc:a0df692764710bba740096a20fd161cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert direction angles to curvilinear track parameters.  <br /></td></tr>
<tr class="memitem:a6e6d2189fe95760f3a86d6ebe3b9c4c5" id="r_a6e6d2189fe95760f3a86d6ebe3b9c4c5"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</td></tr>
<tr class="memitem:a6e6d2189fe95760f3a86d6ebe3b9c4c5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e6d2189fe95760f3a86d6ebe3b9c4c5">trimTrack</a> (track_proxy_t track, bool trimHoles, bool trimOutliers, bool trimMaterial, bool trimOtherNoneMeasurement)</td></tr>
<tr class="memdesc:a6e6d2189fe95760f3a86d6ebe3b9c4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to trim track states from the front and back of a track.  <br /></td></tr>
<tr class="memitem:a324f2413eb01813d83b0e41bddf41e0a" id="r_a324f2413eb01813d83b0e41bddf41e0a"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</td></tr>
<tr class="memitem:a324f2413eb01813d83b0e41bddf41e0a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a324f2413eb01813d83b0e41bddf41e0a">trimTrackBack</a> (track_proxy_t track, bool trimHoles, bool trimOutliers, bool trimMaterial, bool trimOtherNoneMeasurement)</td></tr>
<tr class="memdesc:a324f2413eb01813d83b0e41bddf41e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to trim track states from the back of a track.  <br /></td></tr>
<tr class="memitem:ad010dd74247d5542680768a03ce1fd08" id="r_ad010dd74247d5542680768a03ce1fd08"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</td></tr>
<tr class="memitem:ad010dd74247d5542680768a03ce1fd08 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad010dd74247d5542680768a03ce1fd08">trimTrackFront</a> (track_proxy_t track, bool trimHoles, bool trimOutliers, bool trimMaterial, bool trimOtherNoneMeasurement)</td></tr>
<tr class="memdesc:ad010dd74247d5542680768a03ce1fd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to trim track states from the front of a track.  <br /></td></tr>
<tr class="memitem:af643ac54ae22c8fa907f52f4af9ca248" id="r_af643ac54ae22c8fa907f52f4af9ca248"><td class="memTemplParams" colspan="2">template&lt;SmartPointerConcept T&gt; </td></tr>
<tr class="memitem:af643ac54ae22c8fa907f52f4af9ca248 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::add_pointer_t&lt; std::add_const_t&lt; typename T::element_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af643ac54ae22c8fa907f52f4af9ca248">unpackConstSmartPointers</a> (const std::vector&lt; T &gt; &amp;items)</td></tr>
<tr class="memdesc:af643ac54ae22c8fa907f52f4af9ca248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to unpack a vector of smart pointers (e.g.  <br /></td></tr>
<tr class="memitem:afe4ec039852e4c66c51e003dad4059d4" id="r_afe4ec039852e4c66c51e003dad4059d4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:afe4ec039852e4c66c51e003dad4059d4 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe4ec039852e4c66c51e003dad4059d4">unpackSmartPointers</a> (const std::vector&lt; std::shared_ptr&lt; const T &gt; &gt; &amp;items)</td></tr>
<tr class="memdesc:afe4ec039852e4c66c51e003dad4059d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to unpack a vector of <code>shared_ptr</code> into a vector of raw pointers (const version).  <br /></td></tr>
<tr class="memitem:a9d506a7514329cb489387ca5db28c266" id="r_a9d506a7514329cb489387ca5db28c266"><td class="memTemplParams" colspan="2">template&lt;SmartPointerConcept T&gt; </td></tr>
<tr class="memitem:a9d506a7514329cb489387ca5db28c266 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::add_pointer_t&lt; typename T::element_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d506a7514329cb489387ca5db28c266">unpackSmartPointers</a> (const std::vector&lt; T &gt; &amp;items)</td></tr>
<tr class="memdesc:a9d506a7514329cb489387ca5db28c266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to unpack a vector of <code>shared_ptr</code> into a vector of raw pointers.  <br /></td></tr>
<tr class="memitem:af0f11c97998b7bf2a9fc8fabb700798b" id="r_af0f11c97998b7bf2a9fc8fabb700798b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; <br />
requires (N &gt; 0)</td></tr>
<tr class="memitem:af0f11c97998b7bf2a9fc8fabb700798b template"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0f11c97998b7bf2a9fc8fabb700798b">vecIdxFromSymMat</a> (const std::size_t i, const std::size_t k)</td></tr>
<tr class="memdesc:af0f11c97998b7bf2a9fc8fabb700798b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the indices of the lower triangular part of a symmetric N x N matrix to an unrolled vector index.  <br /></td></tr>
<tr class="memitem:a480df02015f977ce0a30d288861639ba" id="r_a480df02015f977ce0a30d288861639ba"><td class="memTemplParams" colspan="2">template&lt;typename L, typename A, typename B&gt; </td></tr>
<tr class="memitem:a480df02015f977ce0a30d288861639ba template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a480df02015f977ce0a30d288861639ba">visit_measurement</a> (A &amp;&amp;param, B &amp;&amp;cov, std::size_t dim, L &amp;&amp;lambda)</td></tr>
<tr class="memdesc:a480df02015f977ce0a30d288861639ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a lambda call on an overallocated parameter vector and covariance matrix, based on a runtime dimension value.  <br /></td></tr>
<tr class="memitem:acec7ac380cac45f6887d3e73e0f36178" id="r_acec7ac380cac45f6887d3e73e0f36178"><td class="memTemplParams" colspan="2">template&lt;typename L, typename... Args&gt; </td></tr>
<tr class="memitem:acec7ac380cac45f6887d3e73e0f36178 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acec7ac380cac45f6887d3e73e0f36178">visit_measurement</a> (std::size_t dim, L &amp;&amp;lambda, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:acec7ac380cac45f6887d3e73e0f36178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a generic lambda on a measurement dimension.  <br /></td></tr>
<tr class="memitem:ad202ce3349c6cd35350fa8d6d0a2ecbb" id="r_ad202ce3349c6cd35350fa8d6d0a2ecbb"><td class="memTemplParams" colspan="2">template&lt;typename external_spacepoint_t&gt; </td></tr>
<tr class="memitem:ad202ce3349c6cd35350fa8d6d0a2ecbb template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad202ce3349c6cd35350fa8d6d0a2ecbb">xyzCoordinateCheck</a> (const <a class="el" href="struct_acts_1_1_seed_finder_config.html">Acts::SeedFinderConfig</a>&lt; external_spacepoint_t &gt; &amp;config, const external_spacepoint_t &amp;sp, const double *spacepointPosition, double *outputCoordinates)</td></tr>
<tr class="memdesc:ad202ce3349c6cd35350fa8d6d0a2ecbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the compatibility of spacepoint coordinates in xyz assuming the Bottom-Middle direction with the strip meassument details.  <br /></td></tr>
<tr class="memitem:a2baea39f1436221b34dfec4ffac66ee6" id="r_a2baea39f1436221b34dfec4ffac66ee6"><td class="memTemplParams" colspan="2">template&lt;typename... R&gt; </td></tr>
<tr class="memitem:a2baea39f1436221b34dfec4ffac66ee6 template"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2baea39f1436221b34dfec4ffac66ee6">zip</a> (R &amp;&amp;...r)</td></tr>
<tr class="memdesc:a2baea39f1436221b34dfec4ffac66ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that allows to zip some ranges to be used in a range-based for loop.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a507e1521b4ba13a3413804400712f00a" id="r_a507e1521b4ba13a3413804400712f00a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a507e1521b4ba13a3413804400712f00a">AxisBound</a> = <a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7a685d1f2146dd079015e81918414e8971">AxisBoundaryType::Bound</a>&gt;{}</td></tr>
<tr class="memdesc:a507e1521b4ba13a3413804400712f00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for bound boundary type axis.  <br /></td></tr>
<tr class="memitem:a175a5c9afec75e82bcac5d420a12a51a" id="r_a175a5c9afec75e82bcac5d420a12a51a"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a175a5c9afec75e82bcac5d420a12a51a">AxisClosed</a> = <a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7a03f4a47830f97377a35321051685071e">AxisBoundaryType::Closed</a>&gt;{}</td></tr>
<tr class="memdesc:a175a5c9afec75e82bcac5d420a12a51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for closed boundary type axis.  <br /></td></tr>
<tr class="memitem:ad651c70eef2af54126bd856e558b80ed" id="r_ad651c70eef2af54126bd856e558b80ed"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad651c70eef2af54126bd856e558b80ed">AxisOpen</a> = <a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">AxisBoundaryType::Open</a>&gt;{}</td></tr>
<tr class="memdesc:ad651c70eef2af54126bd856e558b80ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience typedefs for AxisBoundaryTypeTag Constant for open boundary type axis.  <br /></td></tr>
<tr class="memitem:a5126c57045207c4b5f7e5a88b02e8ed1" id="r_a5126c57045207c4b5f7e5a88b02e8ed1"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5126c57045207c4b5f7e5a88b02e8ed1">kBoundSubspaceIndicesInvalid</a></td></tr>
<tr class="memdesc:a5126c57045207c4b5f7e5a88b02e8ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">type alias for indices of bound track parameters subspace  <br /></td></tr>
<tr class="memitem:a1c422bbaca4aaec733b49b97645ea1b4" id="r_a1c422bbaca4aaec733b49b97645ea1b4"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c422bbaca4aaec733b49b97645ea1b4">kMeasurementSizeMax</a> = <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a></td></tr>
<tr class="memdesc:a1c422bbaca4aaec733b49b97645ea1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of measurement dimension supported.  <br /></td></tr>
<tr class="memitem:a589e3f01b082df3de46c2a6f5e6ce749" id="r_a589e3f01b082df3de46c2a6f5e6ce749"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a589e3f01b082df3de46c2a6f5e6ce749">kTrackIndexInvalid</a></td></tr>
<tr class="memdesc:a589e3f01b082df3de46c2a6f5e6ce749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value for an invalid / unset track EDM related index.  <br /></td></tr>
<tr class="memitem:aff077588e6b9207d49c53b1556be3a23" id="r_aff077588e6b9207d49c53b1556be3a23"><td class="memItemLeft" align="right" valign="top">static constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff077588e6b9207d49c53b1556be3a23">NoTime</a> = std::numeric_limits&lt;float&gt;::quiet_NaN()</td></tr>
<tr class="memitem:a526e32fbccfb7d636cadc94909fa448d" id="r_a526e32fbccfb7d636cadc94909fa448d"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a526e32fbccfb7d636cadc94909fa448d">PolygonDynamic</a> = -1</td></tr>
<tr class="memdesc:a526e32fbccfb7d636cadc94909fa448d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to trigger specialization of a dynamic polygon.  <br /></td></tr>
<tr class="memitem:a1f4c781401229c29df002208ff1dc1ba" id="r_a1f4c781401229c29df002208ff1dc1ba"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f4c781401229c29df002208ff1dc1ba">s_curvilinearProjTolerance</a> = 0.999995</td></tr>
<tr class="memdesc:a1f4c781401229c29df002208ff1dc1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for not being within curvilinear projection this allows using the same curvilinear frame to eta = 6, validity tested with IntegrationTests/PropagationTest.  <br /></td></tr>
<tr class="memitem:ad0707e56cf6d115c562bd792d8f6654f" id="r_ad0707e56cf6d115c562bd792d8f6654f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_acts_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0707e56cf6d115c562bd792d8f6654f">s_defaultPortalColor</a> {&quot;#308c48&quot;}</td></tr>
<tr class="memdesc:ad0707e56cf6d115c562bd792d8f6654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default color for portals.  <br /></td></tr>
<tr class="memitem:aba3b6dc8a453241ed35c45d00c833b65" id="r_aba3b6dc8a453241ed35c45d00c833b65"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_acts_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba3b6dc8a453241ed35c45d00c833b65">s_defaultSurfaceColor</a> {&quot;#0000aa&quot;}</td></tr>
<tr class="memdesc:aba3b6dc8a453241ed35c45d00c833b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default color for surfaces.  <br /></td></tr>
<tr class="memitem:a19ae35bb28a080cd8bb870efe6ddd14d" id="r_a19ae35bb28a080cd8bb870efe6ddd14d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_acts_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19ae35bb28a080cd8bb870efe6ddd14d">s_defaultVolumColor</a> {&quot;#ffaa00&quot;}</td></tr>
<tr class="memdesc:a19ae35bb28a080cd8bb870efe6ddd14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default color for volumes.  <br /></td></tr>
<tr class="memitem:aec5e2fa11844ec94a3fbe5b522de31f0" id="r_aec5e2fa11844ec94a3fbe5b522de31f0"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec5e2fa11844ec94a3fbe5b522de31f0">s_epsilon</a> = 3 * std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:aec5e2fa11844ec94a3fbe5b522de31f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for being numerical equal for geometry building.  <br /></td></tr>
<tr class="memitem:a3139a86b74eaa775555ed463c528edf5" id="r_a3139a86b74eaa775555ed463c528edf5"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#af9169827ccc34e24679e5d48aa3cd8a1">IntersectionIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3139a86b74eaa775555ed463c528edf5">s_maximumNumberOfIntersections</a> = 2</td></tr>
<tr class="memitem:a3ff17152369521bfeda43fe4318dedaa" id="r_a3ff17152369521bfeda43fe4318dedaa"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_acts_1_1_infinite_bounds.html">InfiniteBounds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ff17152369521bfeda43fe4318dedaa">s_noBounds</a> {}</td></tr>
<tr class="memitem:a062150b6d58b9acb88af2feaf8d3aa2b" id="r_a062150b6d58b9acb88af2feaf8d3aa2b"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a> = 1e-4</td></tr>
<tr class="memdesc:a062150b6d58b9acb88af2feaf8d3aa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for being on Surface.  <br /></td></tr>
<tr class="memitem:a20e9389f108112123af72da0b35415b7" id="r_a20e9389f108112123af72da0b35415b7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e9389f108112123af72da0b35415b7">s_planeXY</a> = Transform3::Identity()</td></tr>
<tr class="memitem:a742fe36753d6446db9ea8c0f8701a352" id="r_a742fe36753d6446db9ea8c0f8701a352"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a742fe36753d6446db9ea8c0f8701a352">s_planeYZ</a></td></tr>
<tr class="memitem:af36def3e2f9465f929dd4d273b1e1149" id="r_af36def3e2f9465f929dd4d273b1e1149"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af36def3e2f9465f929dd4d273b1e1149">s_planeZX</a></td></tr>
<tr class="memitem:ga28f85f1e5822e51867264d9315a78581" id="r_ga28f85f1e5822e51867264d9315a78581"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra__types.html#ga28f85f1e5822e51867264d9315a78581">s_transformEquivalentTolerance</a> = 1e-9</td></tr>
<tr class="memdesc:ga28f85f1e5822e51867264d9315a78581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for transform equivalence checks.  <br /></td></tr>
<tr class="memitem:a8eecb9e1cadbd7e2d179dc57de6c37b7" id="r_a8eecb9e1cadbd7e2d179dc57de6c37b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8eecb9e1cadbd7e2d179dc57de6c37b7">s_viewFiltered</a> = {.color = {255, 255, 0}}</td></tr>
<tr class="memitem:afea1b5aedf4f718a6a97e9363622ded3" id="r_afea1b5aedf4f718a6a97e9363622ded3"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afea1b5aedf4f718a6a97e9363622ded3">s_viewGrid</a> = {.color = {220, 0, 0}}</td></tr>
<tr class="memitem:aff982fda48acad30c85288b19b33fb86" id="r_aff982fda48acad30c85288b19b33fb86"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff982fda48acad30c85288b19b33fb86">s_viewLine</a> = {.color = {0, 0, 220}}</td></tr>
<tr class="memitem:a2a554d4531937faeff795eae33ae831c" id="r_a2a554d4531937faeff795eae33ae831c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a554d4531937faeff795eae33ae831c">s_viewMeasurement</a> = {.color = {255, 102, 0}}</td></tr>
<tr class="memitem:a4c6d8b5fc1957cd0190dc2d3ecd70818" id="r_a4c6d8b5fc1957cd0190dc2d3ecd70818"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c6d8b5fc1957cd0190dc2d3ecd70818">s_viewParameter</a> = {.color = {0, 0, 255}}</td></tr>
<tr class="memitem:a1f54455611bad47046df232ba50ad6a5" id="r_a1f54455611bad47046df232ba50ad6a5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f54455611bad47046df232ba50ad6a5">s_viewPassive</a> = {.color = {240, 280, 0}}</td></tr>
<tr class="memitem:a6f126ed2df82acedde2e6dfdd7c716e5" id="r_a6f126ed2df82acedde2e6dfdd7c716e5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f126ed2df82acedde2e6dfdd7c716e5">s_viewPortal</a> = {.color = <a class="el" href="struct_acts_1_1_color.html">Color</a>{&quot;#308c48&quot;}}</td></tr>
<tr class="memitem:a254ae108fc03e77b6696a99306f5cf97" id="r_a254ae108fc03e77b6696a99306f5cf97"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254ae108fc03e77b6696a99306f5cf97">s_viewPredicted</a> = {.color = {51, 204, 51}}</td></tr>
<tr class="memitem:a2e6deff8fee97c4b0739e26f4ad59496" id="r_a2e6deff8fee97c4b0739e26f4ad59496"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e6deff8fee97c4b0739e26f4ad59496">s_viewSensitive</a> = {.color = {0, 180, 240}}</td></tr>
<tr class="memitem:a11cf9f040a91360f791598e0fec7b03a" id="r_a11cf9f040a91360f791598e0fec7b03a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11cf9f040a91360f791598e0fec7b03a">s_viewSmoothed</a> = {.color = {0, 102, 25}}</td></tr>
<tr class="memitem:a0e88165f9dc20c209a6761493b8eb986" id="r_a0e88165f9dc20c209a6761493b8eb986"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e88165f9dc20c209a6761493b8eb986">s_viewSurface</a> = {.color = {170, 170, 170}}</td></tr>
<tr class="memitem:a5b24d457aac2fdb38a4b9b4e0450f093" id="r_a5b24d457aac2fdb38a4b9b4e0450f093"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b24d457aac2fdb38a4b9b4e0450f093">s_viewVolume</a> = {.color = {220, 220, 0}}</td></tr>
<tr class="memitem:ae88a24bc8e6cfe39de34f12bda049edd" id="r_ae88a24bc8e6cfe39de34f12bda049edd"><td class="memTemplParams" colspan="2">template&lt;typename stepper_t&gt; </td></tr>
<tr class="memitem:ae88a24bc8e6cfe39de34f12bda049edd template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae88a24bc8e6cfe39de34f12bda049edd">SupportsBoundParameters_v</a></td></tr>
<tr class="memdesc:ae88a24bc8e6cfe39de34f12bda049edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable template for checking bound parameters support.  <br /></td></tr>
<tr class="memitem:a7fc11ee35d17cdf6bb12607b24ef9e7d" id="r_a7fc11ee35d17cdf6bb12607b24ef9e7d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7fc11ee35d17cdf6bb12607b24ef9e7d template"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a></td></tr>
<tr class="memdesc:a7fc11ee35d17cdf6bb12607b24ef9e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience variable for creating TypeTag instances.  <br /></td></tr>
<tr class="memitem:ab012b1460d76cf4a86e93f2236859d5a" id="r_ab012b1460d76cf4a86e93f2236859d5a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="#aa009e51d59c1a881d343ba0f9fcacbbc">Envelope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab012b1460d76cf4a86e93f2236859d5a">zeroEnvelope</a> = {0, 0}</td></tr>
<tr class="memdesc:ab012b1460d76cf4a86e93f2236859d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero envelope constant for no extension.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The main namespace encompassing all ACTS code. </p>
<dl class="section note"><dt>Note</dt><dd>This file is foreseen for the <span class="tt">Geometry</span> module to replace <span class="tt">Extent</span> </dd></dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ad74665d2c9210b7b7c61b07a4b1d7882" name="ad74665d2c9210b7b7c61b07a4b1d7882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74665d2c9210b7b7c61b07a4b1d7882">&#9670;&#160;</a></span>AlignmentMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad74665d2c9210b7b7c61b07a4b1d7882">Acts::AlignmentMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Square matrix type for alignment parameters. </p>

</div>
</div>
<a id="aa018f2e119b454c3cb4a886ee1738287" name="aa018f2e119b454c3cb4a886ee1738287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa018f2e119b454c3cb4a886ee1738287">&#9670;&#160;</a></span>AlignmentRowVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa018f2e119b454c3cb4a886ee1738287">Acts::AlignmentRowVector</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;1, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Row vector type for alignment parameters. </p>

</div>
</div>
<a id="afb10c5cb981e8a26821fd8afafc6d10f" name="afb10c5cb981e8a26821fd8afafc6d10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb10c5cb981e8a26821fd8afafc6d10f">&#9670;&#160;</a></span>AlignmentToBoundMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afb10c5cb981e8a26821fd8afafc6d10f">Acts::AlignmentToBoundMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for transforming alignment parameters to bound parameters. </p>

</div>
</div>
<a id="ab42a56895184458a0c2b4de6f112469b" name="ab42a56895184458a0c2b4de6f112469b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42a56895184458a0c2b4de6f112469b">&#9670;&#160;</a></span>AlignmentToPathMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab42a56895184458a0c2b4de6f112469b">Acts::AlignmentToPathMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;1, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for transforming alignment parameters to path length. </p>

</div>
</div>
<a id="a53ac0eeb93f715e2cd742e45bbc6a706" name="a53ac0eeb93f715e2cd742e45bbc6a706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ac0eeb93f715e2cd742e45bbc6a706">&#9670;&#160;</a></span>AlignmentToPositionMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a53ac0eeb93f715e2cd742e45bbc6a706">Acts::AlignmentToPositionMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;3, <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for transforming alignment parameters to position. </p>

</div>
</div>
<a id="afbb99f20f52947bab5a7b54c80510bad" name="afbb99f20f52947bab5a7b54c80510bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb99f20f52947bab5a7b54c80510bad">&#9670;&#160;</a></span>AlignmentVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#afbb99f20f52947bab5a7b54c80510bad">Acts::AlignmentVector</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;<a class="el" href="#a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989">eAlignmentSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector type for alignment parameters. </p>

</div>
</div>
<a id="a2db5437c93715c880d91e795ea966d15" name="a2db5437c93715c880d91e795ea966d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db5437c93715c880d91e795ea966d15">&#9670;&#160;</a></span>AnyConstTrackProxy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2db5437c93715c880d91e795ea966d15">Acts::AnyConstTrackProxy</a> = <a class="el" href="class_acts_1_1_any_track_proxy.html">AnyTrackProxy</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for read-only type-erased track. </p>

</div>
</div>
<a id="a58d7c5f9e29f5f51ece398952f4a2a6a" name="a58d7c5f9e29f5f51ece398952f4a2a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d7c5f9e29f5f51ece398952f4a2a6a">&#9670;&#160;</a></span>AnyConstTrackStateProxy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a58d7c5f9e29f5f51ece398952f4a2a6a">Acts::AnyConstTrackStateProxy</a> = <a class="el" href="class_acts_1_1_any_track_state_proxy.html">AnyTrackStateProxy</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d88b3de1937df196eae6628781ac437" name="a8d88b3de1937df196eae6628781ac437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d88b3de1937df196eae6628781ac437">&#9670;&#160;</a></span>AnyMutableTrackProxy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8d88b3de1937df196eae6628781ac437">Acts::AnyMutableTrackProxy</a> = <a class="el" href="class_acts_1_1_any_track_proxy.html">AnyTrackProxy</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for mutable type-erased track (though currently all operations are const). </p>

</div>
</div>
<a id="af82438c3ab8cfa7c43a00e2a821fa1bb" name="af82438c3ab8cfa7c43a00e2a821fa1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82438c3ab8cfa7c43a00e2a821fa1bb">&#9670;&#160;</a></span>AnyMutableTrackStateProxy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af82438c3ab8cfa7c43a00e2a821fa1bb">Acts::AnyMutableTrackStateProxy</a> = <a class="el" href="class_acts_1_1_any_track_state_proxy.html">AnyTrackStateProxy</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1f471897e11492ff0b12b6ff089225d" name="af1f471897e11492ff0b12b6ff089225d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f471897e11492ff0b12b6ff089225d">&#9670;&#160;</a></span>AxisScalar</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af1f471897e11492ff0b12b6ff089225d">Acts::AxisScalar</a> = Vector3::Scalar</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scalar type used for axis values in surface array binning. </p>

</div>
</div>
<a id="a109a2348a2960bbf7f66f07d2da7dd8b" name="a109a2348a2960bbf7f66f07d2da7dd8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109a2348a2960bbf7f66f07d2da7dd8b">&#9670;&#160;</a></span>BoundarySurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a109a2348a2960bbf7f66f07d2da7dd8b">Acts::BoundarySurface</a> = <a class="el" href="class_acts_1_1_boundary_surface_t.html">BoundarySurfaceT</a>&lt;<a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40a2ff0a11454e7af0dc0a4bcab7b1b0" name="a40a2ff0a11454e7af0dc0a4bcab7b1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">&#9670;&#160;</a></span>BoundMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">Acts::BoundMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for bound track parameter transformations. </p>

</div>
</div>
<a id="a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0" name="a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0">&#9670;&#160;</a></span>BoundSquareMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9eaf1a3cdef9ce06df2d3f7b4a8ac3b0">Acts::BoundSquareMatrix</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Square matrix type for bound track parameter covariance. </p>

</div>
</div>
<a id="a1b6c456f1650d94a2549251f1306dde4" name="a1b6c456f1650d94a2549251f1306dde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6c456f1650d94a2549251f1306dde4">&#9670;&#160;</a></span>BoundSubspaceIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1b6c456f1650d94a2549251f1306dde4">Acts::BoundSubspaceIndices</a> = <a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for bound parameter subspace indices. </p>

</div>
</div>
<a id="a528016d34d6df141f5cb73973d6edca0" name="a528016d34d6df141f5cb73973d6edca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528016d34d6df141f5cb73973d6edca0">&#9670;&#160;</a></span>BoundToFreeMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a528016d34d6df141f5cb73973d6edca0">Acts::BoundToFreeMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>, <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for mapping from bound to free track parameters. </p>

</div>
</div>
<a id="ad836aba005ba272c0a77227311e4a0ce" name="ad836aba005ba272c0a77227311e4a0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad836aba005ba272c0a77227311e4a0ce">&#9670;&#160;</a></span>BoundTrackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ad836aba005ba272c0a77227311e4a0ce">Acts::BoundTrackParameters</a> = <a class="el" href="class_acts_1_1_generic_bound_track_parameters.html">GenericBoundTrackParameters</a>&lt;<a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>BoundTrackParameters can hold any kind of charge. </p>

</div>
</div>
<a id="af2571f8c8ebccb37165c668fab4a1c4f" name="af2571f8c8ebccb37165c668fab4a1c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2571f8c8ebccb37165c668fab4a1c4f">&#9670;&#160;</a></span>BoundVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">Acts::BoundVector</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector type for bound track parameters. </p>

</div>
</div>
<a id="abe4f9e4a5e3fd2a023039cbfec3ef858" name="abe4f9e4a5e3fd2a023039cbfec3ef858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4f9e4a5e3fd2a023039cbfec3ef858">&#9670;&#160;</a></span>const_if_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool C, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abe4f9e4a5e3fd2a023039cbfec3ef858">Acts::const_if_t</a> = std::conditional_t&lt;C, const T, T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait that adds const qualifier to a type based on a boolean condition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>Boolean condition determining whether to add const </td></tr>
    <tr><td class="paramname">T</td><td>Type to potentially make const </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0471a5f2ee8a52d07049c3c014a76613" name="a0471a5f2ee8a52d07049c3c014a76613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0471a5f2ee8a52d07049c3c014a76613">&#9670;&#160;</a></span>ConstDeRef_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;PointerConcept T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0471a5f2ee8a52d07049c3c014a76613">Acts::ConstDeRef_t</a> = std::add_const_t&lt;<a class="el" href="#af5dcde8c0f77a3ed6c7887d0c7e1a26d">RemovePointer_t</a>&lt;T&gt;&gt;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a const pointer dereference. </p>

</div>
</div>
<a id="ae0e74469e9117c4b3731cf556cbf832a" name="ae0e74469e9117c4b3731cf556cbf832a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e74469e9117c4b3731cf556cbf832a">&#9670;&#160;</a></span>ConstProxyAccessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae0e74469e9117c4b3731cf556cbf832a">Acts::ConstProxyAccessor</a> = <a class="el" href="struct_acts_1_1_proxy_accessor_base.html">ProxyAccessorBase</a>&lt;T, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a const proxy accessor. </p>
<p>Provides read-only access to proxy data with const-qualified member functions </p>

</div>
</div>
<a id="a7527bffb3304dc54973337127dcb0c1a" name="a7527bffb3304dc54973337127dcb0c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7527bffb3304dc54973337127dcb0c1a">&#9670;&#160;</a></span>ConstSeedProxy2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7527bffb3304dc54973337127dcb0c1a">Acts::ConstSeedProxy2</a> = <a class="el" href="class_acts_1_1_seed_proxy2.html">SeedProxy2</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5252cf9e661478d7ff7731b37a60cc4c" name="a5252cf9e661478d7ff7731b37a60cc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5252cf9e661478d7ff7731b37a60cc4c">&#9670;&#160;</a></span>ConstSpacePointColumnProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5252cf9e661478d7ff7731b37a60cc4c">Acts::ConstSpacePointColumnProxy</a> = <a class="el" href="class_acts_1_1_space_point_column_proxy.html">SpacePointColumnProxy</a>&lt;T, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd104d9fd9886e714af3bf67c53e508f" name="acd104d9fd9886e714af3bf67c53e508f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd104d9fd9886e714af3bf67c53e508f">&#9670;&#160;</a></span>ConstSpacePointProxy2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acd104d9fd9886e714af3bf67c53e508f">Acts::ConstSpacePointProxy2</a> = <a class="el" href="class_acts_1_1_space_point_proxy2.html">SpacePointProxy2</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d7e85d7c82a496bd6ae9f7560355973" name="a5d7e85d7c82a496bd6ae9f7560355973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7e85d7c82a496bd6ae9f7560355973">&#9670;&#160;</a></span>EAxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">Acts::EAxis</a> = <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt;<a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for equidistant axis with open boundary type. </p>
<p>Used for defining grid axes with equally spaced bins and open boundaries </p>

</div>
</div>
<a id="aa009e51d59c1a881d343ba0f9fcacbbc" name="aa009e51d59c1a881d343ba0f9fcacbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa009e51d59c1a881d343ba0f9fcacbbc">&#9670;&#160;</a></span>Envelope</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa009e51d59c1a881d343ba0f9fcacbbc">Acts::Envelope</a> = std::array&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for envelope values in different directions. </p>
<p>Stores the envelope values for both positive and negative directions </p>

</div>
</div>
<a id="a9bc2353f4da72bb7afd4d868e278150c" name="a9bc2353f4da72bb7afd4d868e278150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc2353f4da72bb7afd4d868e278150c">&#9670;&#160;</a></span>FixedBoundSubspaceHelper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t SubspaceSize&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9bc2353f4da72bb7afd4d868e278150c">Acts::FixedBoundSubspaceHelper</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_fixed_subspace_helper.html">FixedSubspaceHelper&lt;Acts::eBoundSize, SubspaceSize, std::uint8_t&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_fixed_subspace_helper_html"><div class="ttname"><a href="class_acts_1_1_fixed_subspace_helper.html">Acts::FixedSubspaceHelper</a></div><div class="ttdoc">Helper class for fixed subspace operations.</div><div class="ttdef"><b>Definition</b> SubspaceHelpers.hpp:244</div></div>
</div><!-- fragment -->
<p>Helper type for fixed-size bound parameter subspaces. </p>
<p>Provides utilities for working with fixed-size subspaces of bound track parameters </p>

</div>
</div>
<a id="acdde648ddc34cb68123733bebd224cb7" name="acdde648ddc34cb68123733bebd224cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdde648ddc34cb68123733bebd224cb7">&#9670;&#160;</a></span>FreeMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acdde648ddc34cb68123733bebd224cb7">Acts::FreeMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for free track parameter transformations. </p>

</div>
</div>
<a id="a26b50b2b1278f282f32aa57b8ba98642" name="a26b50b2b1278f282f32aa57b8ba98642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b50b2b1278f282f32aa57b8ba98642">&#9670;&#160;</a></span>FreeSquareMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a26b50b2b1278f282f32aa57b8ba98642">Acts::FreeSquareMatrix</a> = <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Square matrix type for free track parameter covariance. </p>

</div>
</div>
<a id="a8d9bd328a23a650ba4dbe1b1bedcb276" name="a8d9bd328a23a650ba4dbe1b1bedcb276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9bd328a23a650ba4dbe1b1bedcb276">&#9670;&#160;</a></span>FreeToBoundMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8d9bd328a23a650ba4dbe1b1bedcb276">Acts::FreeToBoundMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;<a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for mapping from free to bound track parameters. </p>

</div>
</div>
<a id="a9fba2b6f3c302ad14749697283c510bd" name="a9fba2b6f3c302ad14749697283c510bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fba2b6f3c302ad14749697283c510bd">&#9670;&#160;</a></span>FreeToPathMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9fba2b6f3c302ad14749697283c510bd">Acts::FreeToPathMatrix</a> = <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt;1, <a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix type for mapping from free parameters to path length. </p>

</div>
</div>
<a id="a571167e3129b91100b194e36a1277f8d" name="a571167e3129b91100b194e36a1277f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571167e3129b91100b194e36a1277f8d">&#9670;&#160;</a></span>FreeTrackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a571167e3129b91100b194e36a1277f8d">Acts::FreeTrackParameters</a> = <a class="el" href="class_acts_1_1_generic_free_track_parameters.html">GenericFreeTrackParameters</a>&lt;<a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FreeTrackParameters can hold any kind of charge. </p>

</div>
</div>
<a id="a34a846c2589150628ba6e05624221307" name="a34a846c2589150628ba6e05624221307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a846c2589150628ba6e05624221307">&#9670;&#160;</a></span>FreeVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a34a846c2589150628ba6e05624221307">Acts::FreeVector</a> = <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt;<a class="el" href="#a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd">eFreeSize</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector type for free track parameters. </p>

</div>
</div>
<a id="ab0989576baab7a8793e3f7cbeec08cae" name="ab0989576baab7a8793e3f7cbeec08cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0989576baab7a8793e3f7cbeec08cae">&#9670;&#160;</a></span>Grid2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Acts::Grid2D</a> = <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt;<a class="el" href="class_acts_1_1_accumulated_volume_material.html">Acts::AccumulatedVolumeMaterial</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 2-dimensional grid. </p>
<p>Grid structure for storing values with two dimensions </p>

</div>
</div>
<a id="a9449d6ac28ec406ddfcf71fd50003e59" name="a9449d6ac28ec406ddfcf71fd50003e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9449d6ac28ec406ddfcf71fd50003e59">&#9670;&#160;</a></span>Grid3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Acts::Grid3D</a> = <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt;<a class="el" href="class_acts_1_1_accumulated_volume_material.html">Acts::AccumulatedVolumeMaterial</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>, <a class="el" href="#a5d7e85d7c82a496bd6ae9f7560355973">EAxis</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 3-dimensional grid. </p>
<p>Grid structure for storing values with three dimensions </p>

</div>
</div>
<a id="a316aaac27fda3651c80ea8dfba83492a" name="a316aaac27fda3651c80ea8dfba83492a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316aaac27fda3651c80ea8dfba83492a">&#9670;&#160;</a></span>HashedString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a316aaac27fda3651c80ea8dfba83492a">Acts::HashedString</a> = std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for hashed string representation. </p>
<p>Represents a string as a compile-time hash value for efficient comparison </p>

</div>
</div>
<a id="a2feee6c44d3778b3751ed293d4364986" name="a2feee6c44d3778b3751ed293d4364986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feee6c44d3778b3751ed293d4364986">&#9670;&#160;</a></span>Intersection2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a2feee6c44d3778b3751ed293d4364986">Acts::Intersection2D</a> = <a class="el" href="class_acts_1_1_intersection.html">Intersection</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for 2D intersection. </p>

</div>
</div>
<a id="ac5af012605f2c07d2ccec54168574925" name="ac5af012605f2c07d2ccec54168574925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5af012605f2c07d2ccec54168574925">&#9670;&#160;</a></span>Intersection3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac5af012605f2c07d2ccec54168574925">Acts::Intersection3D</a> = <a class="el" href="class_acts_1_1_intersection.html">Intersection</a>&lt;3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for 3D intersection. </p>

</div>
</div>
<a id="af9169827ccc34e24679e5d48aa3cd8a1" name="af9169827ccc34e24679e5d48aa3cd8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9169827ccc34e24679e5d48aa3cd8a1">&#9670;&#160;</a></span>IntersectionIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af9169827ccc34e24679e5d48aa3cd8a1">Acts::IntersectionIndex</a> = std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab749c2bd4901201fd7cc09b7f370a34e" name="ab749c2bd4901201fd7cc09b7f370a34e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab749c2bd4901201fd7cc09b7f370a34e">&#9670;&#160;</a></span>LayerArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a>&lt; <a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a> &gt; <a class="el" href="#ab749c2bd4901201fd7cc09b7f370a34e">Acts::LayerArray</a> = <a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a>&lt;<a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A BinnedArray to a std::shared_ptr of a layer. </p>
<p>Layers are constructed with shared_ptr factories, hence the layer array is describes as: </p>

</div>
</div>
<a id="abb5a9cf5e2b49936d60e698d81fe6e0d" name="abb5a9cf5e2b49936d60e698d81fe6e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5a9cf5e2b49936d60e698d81fe6e0d">&#9670;&#160;</a></span>LayerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_layer.html">Layer</a> &gt; <a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">Acts::LayerPtr</a> = std::shared_ptr&lt;const <a class="el" href="class_acts_1_1_layer.html">Layer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::shared_ptr to a Layer. </p>
<p>Type alias for a shared pointer to a layer. </p>

</div>
</div>
<a id="a98ab2a52542f2ff29cb738cfefc2a7d2" name="a98ab2a52542f2ff29cb738cfefc2a7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ab2a52542f2ff29cb738cfefc2a7d2">&#9670;&#160;</a></span>LayerVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a> &gt; <a class="el" href="#a98ab2a52542f2ff29cb738cfefc2a7d2">Acts::LayerVector</a> = std::vector&lt;<a class="el" href="#abb5a9cf5e2b49936d60e698d81fe6e0d">LayerPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector of std::shared_ptr to layers. </p>

</div>
</div>
<a id="a6bacc83149ffd31c3d1c02297b63a884" name="a6bacc83149ffd31c3d1c02297b63a884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bacc83149ffd31c3d1c02297b63a884">&#9670;&#160;</a></span>MaterialGrid2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6bacc83149ffd31c3d1c02297b63a884">Acts::MaterialGrid2D</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid.html">Acts::Grid&lt;Acts::Material::ParametersVector, EAxis, EAxis&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_grid_html"><div class="ttname"><a href="class_acts_1_1_grid.html">Acts::Grid</a></div><div class="ttdoc">class for describing a regular multi-dimensional grid</div><div class="ttdef"><b>Definition</b> Grid.hpp:141</div></div>
</div><!-- fragment -->
<p>Type alias for a 2-dimensional material grid. </p>
<p>Grid structure for storing material parameters with two dimensions </p>

</div>
</div>
<a id="ae34013557b3d2c0ee081ec4b1c408b38" name="ae34013557b3d2c0ee081ec4b1c408b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34013557b3d2c0ee081ec4b1c408b38">&#9670;&#160;</a></span>MaterialGrid3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae34013557b3d2c0ee081ec4b1c408b38">Acts::MaterialGrid3D</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid.html">Acts::Grid&lt;Acts::Material::ParametersVector, EAxis, EAxis, EAxis&gt;</a></div>
</div><!-- fragment -->
<p>Type alias for a 3-dimensional material grid. </p>
<p>Grid structure for storing material parameters with three dimensions </p>

</div>
</div>
<a id="ae3b4d4995155fcbfd29d48adc9f73a0d" name="ae3b4d4995155fcbfd29d48adc9f73a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b4d4995155fcbfd29d48adc9f73a0d">&#9670;&#160;</a></span>MaterialGridAxisData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">Acts::MaterialGridAxisData</a> = std::tuple&lt;double, double, std::size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for the axis data in material grids. </p>
<p>Tuple containing the minimum value, maximum value, and number of bins for an axis </p>

</div>
</div>
<a id="acda8cc2353ab952431bd685a4450c1dc" name="acda8cc2353ab952431bd685a4450c1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda8cc2353ab952431bd685a4450c1dc">&#9670;&#160;</a></span>MaterialSlabMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#acda8cc2353ab952431bd685a4450c1dc">Acts::MaterialSlabMatrix</a> = std::vector&lt;<a class="el" href="#ae02784ae49dd0d917418a3878453a4c1">MaterialSlabVector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a matrix of material slabs. </p>
<p>Used to store a 2D collection of material slabs </p>

</div>
</div>
<a id="ae02784ae49dd0d917418a3878453a4c1" name="ae02784ae49dd0d917418a3878453a4c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02784ae49dd0d917418a3878453a4c1">&#9670;&#160;</a></span>MaterialSlabVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae02784ae49dd0d917418a3878453a4c1">Acts::MaterialSlabVector</a> = std::vector&lt;<a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a vector of material slabs. </p>
<p>Used to store a collection of material slabs in sequence </p>

</div>
</div>
<a id="a4db7019218e46140392e9e7c6061081c" name="a4db7019218e46140392e9e7c6061081c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db7019218e46140392e9e7c6061081c">&#9670;&#160;</a></span>MaxMomentumReducerLoop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef detail::SingleComponentReducer&lt; detail::MaxMomentumComponent &gt; <a class="el" href="#a4db7019218e46140392e9e7c6061081c">Acts::MaxMomentumReducerLoop</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    detail::SingleComponentReducer&lt;detail::MaxMomentumComponent&gt;</div>
</div><!-- fragment -->
<p>Type alias for loop reducer based on maximum momentum. </p>
<p>Reduces multiple loop iterations based on momentum criteria </p>

</div>
</div>
<a id="a8c6ffaa75197866a88bcc862b93306e3" name="a8c6ffaa75197866a88bcc862b93306e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6ffaa75197866a88bcc862b93306e3">&#9670;&#160;</a></span>MaxWeightReducerLoop</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef detail::SingleComponentReducer&lt; detail::MaxWeightComponent &gt; <a class="el" href="#a8c6ffaa75197866a88bcc862b93306e3">Acts::MaxWeightReducerLoop</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    detail::SingleComponentReducer&lt;detail::MaxWeightComponent&gt;</div>
</div><!-- fragment -->
<p>Type alias for loop reducer based on maximum weight. </p>
<p>Reduces multiple loop iterations based on weight criteria </p>

</div>
</div>
<a id="ae9408494e498cfa4e752006ca788b3f6" name="ae9408494e498cfa4e752006ca788b3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9408494e498cfa4e752006ca788b3f6">&#9670;&#160;</a></span>MultiEigenStepperLoop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename extension_t = EigenStepperDefaultExtension, typename reducer_t = MaxWeightReducerLoop&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae9408494e498cfa4e752006ca788b3f6">Acts::MultiEigenStepperLoop</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_multi_stepper_loop.html">MultiStepperLoop&lt;EigenStepper&lt;extension_t&gt;</a>, reducer_t&gt;</div>
<div class="ttc" id="aclass_acts_1_1_multi_stepper_loop_html"><div class="ttname"><a href="class_acts_1_1_multi_stepper_loop.html">Acts::MultiStepperLoop</a></div><div class="ttdoc">Stepper based on a single-component stepper, but can handle Multi-Component Tracks (e....</div><div class="ttdef"><b>Definition</b> MultiStepperLoop.hpp:137</div></div>
</div><!-- fragment -->
<p>Stepper based on the EigenStepper, but handles Multi-Component Tracks (e.g., for the GSF). </p>
<p>Internally, this only manages a vector of EigenStepper::States. This simplifies implementation, but has several drawbacks:</p><ul>
<li>There are certain redundancies between the global State and the component states</li>
<li>The components do not share a single magnetic-field-cache <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">extension_t</td><td>See EigenStepper for details </td></tr>
    <tr><td class="paramname">component_reducer_t</td><td>How to map the multi-component state to a single component </td></tr>
    <tr><td class="paramname">small_vector_size</td><td>A size-hint how much memory should be allocated by the small vector </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ae9759fe2150d6d2442c1270dbabc1976" name="ae9759fe2150d6d2442c1270dbabc1976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9759fe2150d6d2442c1270dbabc1976">&#9670;&#160;</a></span>MultiIntersection2D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae9759fe2150d6d2442c1270dbabc1976">Acts::MultiIntersection2D</a> = <a class="el" href="class_acts_1_1_multi_intersection.html">MultiIntersection</a>&lt;2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4e962ae4108b1150b697ebcc6132bff" name="ae4e962ae4108b1150b697ebcc6132bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e962ae4108b1150b697ebcc6132bff">&#9670;&#160;</a></span>MultiIntersection3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae4e962ae4108b1150b697ebcc6132bff">Acts::MultiIntersection3D</a> = <a class="el" href="class_acts_1_1_multi_intersection.html">MultiIntersection</a>&lt;3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09af7e6b42a9e8ebf8b9ac931e7d866b" name="a09af7e6b42a9e8ebf8b9ac931e7d866b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09af7e6b42a9e8ebf8b9ac931e7d866b">&#9670;&#160;</a></span>MutableLayerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt; <a class="el" href="class_acts_1_1_layer.html">Layer</a> &gt; <a class="el" href="#a09af7e6b42a9e8ebf8b9ac931e7d866b">Acts::MutableLayerPtr</a> = std::shared_ptr&lt;<a class="el" href="class_acts_1_1_layer.html">Layer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a mutable pointer to a layer. </p>
<p>Used for non-const access to layer objects in the geometry </p>

</div>
</div>
<a id="abcfecfc26529b706b3ba31042e4c2948" name="abcfecfc26529b706b3ba31042e4c2948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfecfc26529b706b3ba31042e4c2948">&#9670;&#160;</a></span>MutableSeedProxy2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#abcfecfc26529b706b3ba31042e4c2948">Acts::MutableSeedProxy2</a> = <a class="el" href="class_acts_1_1_seed_proxy2.html">SeedProxy2</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae99c57a7ceaaba03e0f89b978851f98c" name="ae99c57a7ceaaba03e0f89b978851f98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99c57a7ceaaba03e0f89b978851f98c">&#9670;&#160;</a></span>MutableSpacePointColumnProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae99c57a7ceaaba03e0f89b978851f98c">Acts::MutableSpacePointColumnProxy</a> = <a class="el" href="class_acts_1_1_space_point_column_proxy.html">SpacePointColumnProxy</a>&lt;T, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab89f1e4f2b712860bba81478a4861cd" name="aab89f1e4f2b712860bba81478a4861cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab89f1e4f2b712860bba81478a4861cd">&#9670;&#160;</a></span>MutableSpacePointProxy2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aab89f1e4f2b712860bba81478a4861cd">Acts::MutableSpacePointProxy2</a> = <a class="el" href="class_acts_1_1_space_point_proxy2.html">SpacePointProxy2</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a813d99d294c94b676e4e7763b4af7901" name="a813d99d294c94b676e4e7763b4af7901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813d99d294c94b676e4e7763b4af7901">&#9670;&#160;</a></span>MutableTrackingVolumePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt; <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> &gt; <a class="el" href="#a813d99d294c94b676e4e7763b4af7901">Acts::MutableTrackingVolumePtr</a> = std::shared_ptr&lt;<a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to a mutable TrackingVolume. </p>

</div>
</div>
<a id="a75b87c7a3396f68139b33fe375e4d3b8" name="a75b87c7a3396f68139b33fe375e4d3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b87c7a3396f68139b33fe375e4d3b8">&#9670;&#160;</a></span>MutableTrackingVolumeVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="#a813d99d294c94b676e4e7763b4af7901">MutableTrackingVolumePtr</a> &gt; <a class="el" href="#a75b87c7a3396f68139b33fe375e4d3b8">Acts::MutableTrackingVolumeVector</a> = std::vector&lt;<a class="el" href="#a813d99d294c94b676e4e7763b4af7901">MutableTrackingVolumePtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of shared pointers to mutable TrackingVolumes. </p>

</div>
</div>
<a id="a3c7053506015dae00ae1b4273764fb86" name="a3c7053506015dae00ae1b4273764fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7053506015dae00ae1b4273764fb86">&#9670;&#160;</a></span>NavigationDelegate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3c7053506015dae00ae1b4273764fb86">Acts::NavigationDelegate</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_delegate.html">Delegate</a>&lt;void(<span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_geometry_context.html">GeometryContext</a>&amp;, <span class="keyword">const</span> <a class="code hl_struct" href="struct_acts_1_1_navigation_arguments.html">NavigationArguments</a>&amp;,</div>
<div class="line">                  <a class="code hl_class" href="class_acts_1_1_append_only_navigation_stream.html">AppendOnlyNavigationStream</a>&amp;, <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_logger.html">Logger</a>&amp;)&gt;</div>
<div class="ttc" id="aclass_acts_1_1_append_only_navigation_stream_html"><div class="ttname"><a href="class_acts_1_1_append_only_navigation_stream.html">Acts::AppendOnlyNavigationStream</a></div><div class="ttdef"><b>Definition</b> NavigationStream.hpp:155</div></div>
<div class="ttc" id="aclass_acts_1_1_delegate_html"><div class="ttname"><a href="class_acts_1_1_delegate.html">Acts::Delegate</a></div><div class="ttdef"><b>Definition</b> Delegate.hpp:29</div></div>
<div class="ttc" id="aclass_acts_1_1_geometry_context_html"><div class="ttname"><a href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a></div><div class="ttdoc">This is the central definition of the Acts payload object regarding detector geometry status (e....</div><div class="ttdef"><b>Definition</b> GeometryContext.hpp:29</div></div>
<div class="ttc" id="aclass_acts_1_1_logger_html"><div class="ttname"><a href="class_acts_1_1_logger.html">Acts::Logger</a></div><div class="ttdoc">class for printing debug output</div><div class="ttdef"><b>Definition</b> Logger.hpp:691</div></div>
<div class="ttc" id="astruct_acts_1_1_navigation_arguments_html"><div class="ttname"><a href="struct_acts_1_1_navigation_arguments.html">Acts::NavigationArguments</a></div><div class="ttdoc">Struct that serves as the argument to the navigation delegate.</div><div class="ttdef"><b>Definition</b> NavigationDelegate.hpp:24</div></div>
</div><!-- fragment -->
<p>Central alias for the navigation delegate. </p>
<p>This type is owning to support (type-erased) navigation delegate chains (i.e. multiple policies). </p>

</div>
</div>
<a id="a5a251193de228b8045bfae4dea56eeaa" name="a5a251193de228b8045bfae4dea56eeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a251193de228b8045bfae4dea56eeaa">&#9670;&#160;</a></span>NeutralBoundTrackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5a251193de228b8045bfae4dea56eeaa">Acts::NeutralBoundTrackParameters</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_generic_bound_track_parameters.html">GenericBoundTrackParameters&lt;NeutralParticleHypothesis&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_generic_bound_track_parameters_html"><div class="ttname"><a href="class_acts_1_1_generic_bound_track_parameters.html">Acts::GenericBoundTrackParameters</a></div><div class="ttdoc">Track parameters bound to a reference surface for a single track.</div><div class="ttdef"><b>Definition</b> GenericBoundTrackParameters.hpp:39</div></div>
</div><!-- fragment -->
<p>Type alias for bound track parameters of neutral particles. </p>
<p>Track parameters for neutral particles in a bound coordinate system </p>

</div>
</div>
<a id="a250e93cd47012384de7861dfa23d7706" name="a250e93cd47012384de7861dfa23d7706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250e93cd47012384de7861dfa23d7706">&#9670;&#160;</a></span>NeutralFreeTrackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a250e93cd47012384de7861dfa23d7706">Acts::NeutralFreeTrackParameters</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_generic_free_track_parameters.html">GenericFreeTrackParameters&lt;NeutralParticleHypothesis&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_generic_free_track_parameters_html"><div class="ttname"><a href="class_acts_1_1_generic_free_track_parameters.html">Acts::GenericFreeTrackParameters</a></div><div class="ttdoc">Track parameters not bound to a surface for a single track.</div><div class="ttdef"><b>Definition</b> GenericFreeTrackParameters.hpp:34</div></div>
</div><!-- fragment -->
<p>Type alias for free track parameters of neutral particles. </p>

</div>
</div>
<a id="a474fe95e07bff5d2bd907ffb6ff3bea9" name="a474fe95e07bff5d2bd907ffb6ff3bea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474fe95e07bff5d2bd907ffb6ff3bea9">&#9670;&#160;</a></span>NextLayers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a474fe95e07bff5d2bd907ffb6ff3bea9">Acts::NextLayers</a> = std::pair&lt;const <a class="el" href="class_acts_1_1_layer.html">Layer</a>*, const <a class="el" href="class_acts_1_1_layer.html">Layer</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for adjacent layer pointers. </p>
<p>Stores pointers to the next inner and outer layers in the detector </p>

</div>
</div>
<a id="a02a4498acaa3e08fdd9553867bb6fd8e" name="a02a4498acaa3e08fdd9553867bb6fd8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a4498acaa3e08fdd9553867bb6fd8e">&#9670;&#160;</a></span>ParamCovAccessor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a02a4498acaa3e08fdd9553867bb6fd8e">Acts::ParamCovAccessor</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;std::pair&lt;const BoundVector, const BoundSquareMatrix&gt;(</div>
<div class="line">        <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_source_link.html">SourceLink</a>&amp;)&gt;</div>
<div class="ttc" id="aclass_acts_1_1_source_link_html"><div class="ttname"><a href="class_acts_1_1_source_link.html">Acts::SourceLink</a></div><div class="ttdef"><b>Definition</b> SourceLink.hpp:28</div></div>
</div><!-- fragment -->
<p>Type alias for accessing parameter covariance matrices. </p>
<p>Function type for retrieving covariance matrices from measurement parameters </p>

</div>
</div>
<a id="a1e6b3622ce6e2c9fea228f7b3678e5f4" name="a1e6b3622ce6e2c9fea228f7b3678e5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6b3622ce6e2c9fea228f7b3678e5f4">&#9670;&#160;</a></span>ProjectorBitset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1e6b3622ce6e2c9fea228f7b3678e5f4">Acts::ProjectorBitset</a> = std::uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for bitset representing parameter projections. </p>
<p>Used to store parameter projection information in a compact bit format </p>

</div>
</div>
<a id="a79f3daeca2329cfd19dc3baa49e667d0" name="a79f3daeca2329cfd19dc3baa49e667d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f3daeca2329cfd19dc3baa49e667d0">&#9670;&#160;</a></span>ProxyAccessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a79f3daeca2329cfd19dc3baa49e667d0">Acts::ProxyAccessor</a> = <a class="el" href="struct_acts_1_1_proxy_accessor_base.html">ProxyAccessorBase</a>&lt;T, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a mutable proxy accessor. </p>
<p>Provides mutable access to track state components through a proxy pattern </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component being accessed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81478db625a7b35501d5f651f5d1d4fd" name="a81478db625a7b35501d5f651f5d1d4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81478db625a7b35501d5f651f5d1d4fd">&#9670;&#160;</a></span>Range1D</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a81478db625a7b35501d5f651f5d1d4fd">Acts::Range1D</a> = <a class="el" href="class_acts_1_1_range_x_d.html">RangeXD</a>&lt;1, <a class="el" href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a one-dimensional range. </p>
<p>Specialization of RangeXD for one-dimensional ranges </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Type</td><td>The value type of the range </td></tr>
    <tr><td class="paramname">Vector</td><td>The container type template used to store the range bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e3bc17e57fdc272a17b43714e85adeb" name="a0e3bc17e57fdc272a17b43714e85adeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3bc17e57fdc272a17b43714e85adeb">&#9670;&#160;</a></span>Ray3D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0e3bc17e57fdc272a17b43714e85adeb">Acts::Ray3D</a> = <a class="el" href="class_acts_1_1_ray.html">Ray</a>&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a 3D ray using double precision. </p>
<p>Specialization of Ray class for three-dimensional space using double precision floating-point values </p>

</div>
</div>
<a id="a7c52cf739300a2e3988b6fbea63e17dd" name="a7c52cf739300a2e3988b6fbea63e17dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c52cf739300a2e3988b6fbea63e17dd">&#9670;&#160;</a></span>RecordedMaterialTrack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7c52cf739300a2e3988b6fbea63e17dd">Acts::RecordedMaterialTrack</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::pair&lt;std::pair&lt;Acts::Vector3, Acts::Vector3&gt;, <a class="code hl_struct" href="struct_acts_1_1_recorded_material.html">RecordedMaterial</a>&gt;</div>
<div class="ttc" id="astruct_acts_1_1_recorded_material_html"><div class="ttname"><a href="struct_acts_1_1_recorded_material.html">Acts::RecordedMaterial</a></div><div class="ttdoc">Simple result struct to be returned It mainly acts as an internal state which is created for every pr...</div><div class="ttdef"><b>Definition</b> MaterialInteraction.hpp:89</div></div>
</div><!-- fragment -->
<p>And recorded material track. </p>
<ul>
<li>this is start: position, start momentum and the Recorded material </li>
</ul>

</div>
</div>
<a id="a9259c24825f667858a4397ffce0e6797" name="a9259c24825f667858a4397ffce0e6797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9259c24825f667858a4397ffce0e6797">&#9670;&#160;</a></span>RecordedMaterialVolumePoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9259c24825f667858a4397ffce0e6797">Acts::RecordedMaterialVolumePoint</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::vector&lt;std::pair&lt;Acts::MaterialSlab, std::vector&lt;Acts::Vector3&gt;&gt;&gt;</div>
</div><!-- fragment -->
<p>list of point used in the mapping of a volume </p>

</div>
</div>
<a id="ae062b9b7f44f677427f86667becc8413" name="ae062b9b7f44f677427f86667becc8413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae062b9b7f44f677427f86667becc8413">&#9670;&#160;</a></span>RegularCylinderIndexGrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae062b9b7f44f677427f86667becc8413">Acts::RegularCylinderIndexGrid</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid.html">Grid&lt;std::vector&lt;std::size_t&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Closed&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Bound&gt;</a>&gt;</div>
<div class="ttc" id="aclass_acts_1_1_axis_html"><div class="ttname"><a href="class_acts_1_1_axis.html">Acts::Axis</a></div><div class="ttdoc">calculate bin indices from a given binning structure</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:147</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a415481fd3fcf2ac7bcaadd2a93e6a38e" name="a415481fd3fcf2ac7bcaadd2a93e6a38e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415481fd3fcf2ac7bcaadd2a93e6a38e">&#9670;&#160;</a></span>RegularCylinderIndexGridNavigationPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a415481fd3fcf2ac7bcaadd2a93e6a38e">Acts::RegularCylinderIndexGridNavigationPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_index_grid_navigation_policy.html">IndexGridNavigationPolicy&lt;RegularCylinderIndexGrid&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_index_grid_navigation_policy_html"><div class="ttname"><a href="class_acts_1_1_index_grid_navigation_policy.html">Acts::IndexGridNavigationPolicy</a></div><div class="ttdoc">A navigation policy that uses grid based navigation for indexed surfaces Navigate through a multilaye...</div><div class="ttdef"><b>Definition</b> IndexGridNavigationPolicy.hpp:44</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f259b0a5c51bef5b087bce8b9a70916" name="a6f259b0a5c51bef5b087bce8b9a70916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f259b0a5c51bef5b087bce8b9a70916">&#9670;&#160;</a></span>RegularDiscIndexGrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6f259b0a5c51bef5b087bce8b9a70916">Acts::RegularDiscIndexGrid</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid.html">Grid&lt;std::vector&lt;std::size_t&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Bound&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Closed&gt;</a>&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a06353fb21ac789b0651913a8fcea7ace" name="a06353fb21ac789b0651913a8fcea7ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06353fb21ac789b0651913a8fcea7ace">&#9670;&#160;</a></span>RegularDiscIndexGridNavigationPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a06353fb21ac789b0651913a8fcea7ace">Acts::RegularDiscIndexGridNavigationPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_index_grid_navigation_policy.html">IndexGridNavigationPolicy&lt;RegularDiscIndexGrid&gt;</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a113ba88761207bc76f0539d17f4adc" name="a7a113ba88761207bc76f0539d17f4adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a113ba88761207bc76f0539d17f4adc">&#9670;&#160;</a></span>RegularPlaneIndexGrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7a113ba88761207bc76f0539d17f4adc">Acts::RegularPlaneIndexGrid</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid.html">Grid&lt;std::vector&lt;std::size_t&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Bound&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Bound&gt;</a>&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a98163fce2f835cc18b46a3dd61b1aca2" name="a98163fce2f835cc18b46a3dd61b1aca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98163fce2f835cc18b46a3dd61b1aca2">&#9670;&#160;</a></span>RegularPlaneIndexGridNavigationPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a98163fce2f835cc18b46a3dd61b1aca2">Acts::RegularPlaneIndexGridNavigationPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_index_grid_navigation_policy.html">IndexGridNavigationPolicy&lt;RegularPlaneIndexGrid&gt;</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="aaec782f86c8422aa8c7aed76547087c3" name="aaec782f86c8422aa8c7aed76547087c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec782f86c8422aa8c7aed76547087c3">&#9670;&#160;</a></span>RegularRingIndexGrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aaec782f86c8422aa8c7aed76547087c3">Acts::RegularRingIndexGrid</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid.html">Grid&lt;std::vector&lt;std::size_t&gt;</a>,</div>
<div class="line">         <a class="code hl_class" href="class_acts_1_1_axis.html">Axis&lt;AxisType::Equidistant, AxisBoundaryType::Closed&gt;</a>&gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a323cd9fc4d1438e08a1b2caf5ab88ebc" name="a323cd9fc4d1438e08a1b2caf5ab88ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323cd9fc4d1438e08a1b2caf5ab88ebc">&#9670;&#160;</a></span>RegularRingIndexGridNavigationPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a323cd9fc4d1438e08a1b2caf5ab88ebc">Acts::RegularRingIndexGridNavigationPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_index_grid_navigation_policy.html">IndexGridNavigationPolicy&lt;RegularRingIndexGrid&gt;</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="af5dcde8c0f77a3ed6c7887d0c7e1a26d" name="af5dcde8c0f77a3ed6c7887d0c7e1a26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dcde8c0f77a3ed6c7887d0c7e1a26d">&#9670;&#160;</a></span>RemovePointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af5dcde8c0f77a3ed6c7887d0c7e1a26d">Acts::RemovePointer_t</a> = <a class="el" href="struct_acts_1_1_remove_pointer.html">RemovePointer</a>&lt;T&gt;<a class="el" href="struct_acts_1_1_remove_pointer.html">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper type alias for removing pointer from type. </p>

</div>
</div>
<a id="ac4045b2d1b45e4878781a1aef72ce245" name="ac4045b2d1b45e4878781a1aef72ce245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4045b2d1b45e4878781a1aef72ce245">&#9670;&#160;</a></span>SeedIndex2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac4045b2d1b45e4878781a1aef72ce245">Acts::SeedIndex2</a> = std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7fe124c6f6fda8fa31781f93cbd36b8" name="ac7fe124c6f6fda8fa31781f93cbd36b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fe124c6f6fda8fa31781f93cbd36b8">&#9670;&#160;</a></span>SerializedSubspaceIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac7fe124c6f6fda8fa31781f93cbd36b8">Acts::SerializedSubspaceIndices</a> = std::uint64_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for serialized subspace indices. </p>
<p>Compact representation of subspace indices as a 64-bit unsigned integer </p>

</div>
</div>
<a id="a5b56fc104eaff23f7abdd63943418113" name="a5b56fc104eaff23f7abdd63943418113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b56fc104eaff23f7abdd63943418113">&#9670;&#160;</a></span>SinglyChargedBoundTrackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5b56fc104eaff23f7abdd63943418113">Acts::SinglyChargedBoundTrackParameters</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_generic_bound_track_parameters.html">GenericBoundTrackParameters&lt;SinglyChargedParticleHypothesis&gt;</a></div>
</div><!-- fragment -->
<p>Type alias for bound track parameters of singly charged particles. </p>
<p>Track parameters defined in a local coordinate system for particles with charge 1 </p>

</div>
</div>
<a id="aea0bf98374c4170e158eb7514d2bbf97" name="aea0bf98374c4170e158eb7514d2bbf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0bf98374c4170e158eb7514d2bbf97">&#9670;&#160;</a></span>SinglyChargedFreeTrackParameters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aea0bf98374c4170e158eb7514d2bbf97">Acts::SinglyChargedFreeTrackParameters</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_generic_free_track_parameters.html">GenericFreeTrackParameters&lt;SinglyChargedParticleHypothesis&gt;</a></div>
</div><!-- fragment -->
<p>Type alias for free track parameters of singly charged particles. </p>

</div>
</div>
<a id="a5d7404f9e2ba75e16149f97ec4cfe62e" name="a5d7404f9e2ba75e16149f97ec4cfe62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7404f9e2ba75e16149f97ec4cfe62e">&#9670;&#160;</a></span>SourceLinkSurfaceAccessor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a5d7404f9e2ba75e16149f97ec4cfe62e">Acts::SourceLinkSurfaceAccessor</a> = <a class="el" href="class_acts_1_1_delegate.html">Delegate</a>&lt;const <a class="el" href="class_acts_1_1_surface.html">Surface</a>*(const <a class="el" href="class_acts_1_1_source_link.html">SourceLink</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delegate to unpack the surface associated with a source link. </p>

</div>
</div>
<a id="a59d378bfaff7526c72743adf3da1bc1f" name="a59d378bfaff7526c72743adf3da1bc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d378bfaff7526c72743adf3da1bc1f">&#9670;&#160;</a></span>SpacePointIndex2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">Acts::SpacePointIndex2</a> = std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c354ee4f15c223b223dc14c4ff96f97" name="a0c354ee4f15c223b223dc14c4ff96f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c354ee4f15c223b223dc14c4ff96f97">&#9670;&#160;</a></span>SpacePointIndexRange2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0c354ee4f15c223b223dc14c4ff96f97">Acts::SpacePointIndexRange2</a> = std::pair&lt;<a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a>, <a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61285991285178e9661e36267761d52d" name="a61285991285178e9661e36267761d52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61285991285178e9661e36267761d52d">&#9670;&#160;</a></span>SpacePointIndexSubset2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a61285991285178e9661e36267761d52d">Acts::SpacePointIndexSubset2</a> = std::span&lt;const <a class="el" href="#a59d378bfaff7526c72743adf3da1bc1f">SpacePointIndex2</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1670ec4e030e90f0bce7b5154a9d12bb" name="a1670ec4e030e90f0bce7b5154a9d12bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1670ec4e030e90f0bce7b5154a9d12bb">&#9670;&#160;</a></span>SubspaceIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1670ec4e030e90f0bce7b5154a9d12bb">Acts::SubspaceIndex</a> = std::uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for subspace index. </p>

</div>
</div>
<a id="a6a670110d0ebb9267ec1256f8bd88b6e" name="a6a670110d0ebb9267ec1256f8bd88b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a670110d0ebb9267ec1256f8bd88b6e">&#9670;&#160;</a></span>SubspaceIndices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t measdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">Acts::SubspaceIndices</a> = std::array&lt;<a class="el" href="#a1670ec4e030e90f0bce7b5154a9d12bb">SubspaceIndex</a>, measdim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Template alias for subspace indices array. </p>

</div>
</div>
<a id="aff81cf741e697ab165fc3579cacda4aa" name="aff81cf741e697ab165fc3579cacda4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff81cf741e697ab165fc3579cacda4aa">&#9670;&#160;</a></span>SurfaceBoundFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aff81cf741e697ab165fc3579cacda4aa">Acts::SurfaceBoundFactory</a> = <a class="el" href="class_acts_1_1_bound_factory.html">BoundFactory</a>&lt;const <a class="el" href="class_acts_1_1_surface_bounds.html">SurfaceBounds</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abrivation for a factory to construct surface bounds. </p>

</div>
</div>
<a id="a884d99e12205bfc04d2cc2a8501a3a39" name="a884d99e12205bfc04d2cc2a8501a3a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a884d99e12205bfc04d2cc2a8501a3a39">&#9670;&#160;</a></span>SurfaceMatcher</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a884d99e12205bfc04d2cc2a8501a3a39">Acts::SurfaceMatcher</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::function&lt;bool(<span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_geometry_context.html">GeometryContext</a>&amp; gctx, <a class="code hl_enumeration" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a>,</div>
<div class="line">                       <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_surface.html">Surface</a>*, <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_surface.html">Surface</a>*)&gt;</div>
<div class="ttc" id="aclass_acts_1_1_surface_html"><div class="ttname"><a href="class_acts_1_1_surface.html">Acts::Surface</a></div><div class="ttdoc">Abstract Base Class for tracking surfaces.</div><div class="ttdef"><b>Definition</b> Surface.hpp:54</div></div>
<div class="ttc" id="anamespace_acts_html_a1462738699cb376ae92c59811987f4ea"><div class="ttname"><a href="#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a></div><div class="ttdeci">AxisDirection</div><div class="ttdoc">to specify a local axis direction</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:18</div></div>
</div><!-- fragment -->
<p>Function type for comparing two surfaces in a given geometry context and axis direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The geometry context for the comparison </td></tr>
    <tr><td class="paramname">dir</td><td>The axis direction to consider </td></tr>
    <tr><td class="paramname">s1</td><td>First surface to compare </td></tr>
    <tr><td class="paramname">s2</td><td>Second surface to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the surfaces are considered equivalent for binning purposes </dd></dl>

</div>
</div>
<a id="a0ff605a935815bac9c0a18618e1f4b65" name="a0ff605a935815bac9c0a18618e1f4b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff605a935815bac9c0a18618e1f4b65">&#9670;&#160;</a></span>SurfaceMaterialMaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0ff605a935815bac9c0a18618e1f4b65">Acts::SurfaceMaterialMaps</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::map&lt;GeometryIdentifier, std::shared_ptr&lt;const ISurfaceMaterial&gt;&gt;</div>
</div><!-- fragment -->
<p>Type alias for surface material maps indexed by geometry identifier. </p>

</div>
</div>
<a id="aa80f2fb6a7e543af58af13eedf6fdbd0" name="aa80f2fb6a7e543af58af13eedf6fdbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80f2fb6a7e543af58af13eedf6fdbd0">&#9670;&#160;</a></span>SurfaceMatrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa80f2fb6a7e543af58af13eedf6fdbd0">Acts::SurfaceMatrix</a> = std::vector&lt;<a class="el" href="#a24683289c06d2751edbef04f58b3fdcd">SurfaceVector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix (2D vector) of pointers to constant Surface objects. </p>

</div>
</div>
<a id="a24683289c06d2751edbef04f58b3fdcd" name="a24683289c06d2751edbef04f58b3fdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24683289c06d2751edbef04f58b3fdcd">&#9670;&#160;</a></span>SurfaceVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> * &gt; <a class="el" href="#a24683289c06d2751edbef04f58b3fdcd">Acts::SurfaceVector</a> = std::vector&lt;const <a class="el" href="class_acts_1_1_surface.html">Surface</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of pointers to constant Surface objects. </p>

</div>
</div>
<a id="ab10f01c2759ff4e801d804fdf1a91199" name="ab10f01c2759ff4e801d804fdf1a91199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10f01c2759ff4e801d804fdf1a91199">&#9670;&#160;</a></span>TrackIndexType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab10f01c2759ff4e801d804fdf1a91199">Acts::TrackIndexType</a> = std::uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for track index values. </p>

</div>
</div>
<a id="a4840b95a87ca15ddba7ceb31b16a4353" name="a4840b95a87ca15ddba7ceb31b16a4353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4840b95a87ca15ddba7ceb31b16a4353">&#9670;&#160;</a></span>TrackingGeometryMaterial</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4840b95a87ca15ddba7ceb31b16a4353">Acts::TrackingGeometryMaterial</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::pair&lt;SurfaceMaterialMaps, VolumeMaterialMaps&gt;</div>
</div><!-- fragment -->
<p>Type alias for tracking geometry material containing surface and volume maps. </p>

</div>
</div>
<a id="a28648357639285c87a2440debff326f3" name="a28648357639285c87a2440debff326f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28648357639285c87a2440debff326f3">&#9670;&#160;</a></span>TrackingVolumeArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a>&lt; <a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a> &gt; <a class="el" href="#a28648357639285c87a2440debff326f3">Acts::TrackingVolumeArray</a> = <a class="el" href="class_acts_1_1_binned_array.html">BinnedArray</a>&lt;<a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A BinnedArray of a std::shared_tr to a TrackingVolume. </p>

</div>
</div>
<a id="ab10f820874384c7566b692cc40f9d30f" name="ab10f820874384c7566b692cc40f9d30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10f820874384c7566b692cc40f9d30f">&#9670;&#160;</a></span>TrackingVolumeBoundaries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab10f820874384c7566b692cc40f9d30f">Acts::TrackingVolumeBoundaries</a> = std::vector&lt;<a class="el" href="#a46aee760d4a254ba395540f5500b7a74">TrackingVolumeBoundaryPtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for collection of tracking volume boundaries. </p>

</div>
</div>
<a id="a46aee760d4a254ba395540f5500b7a74" name="a46aee760d4a254ba395540f5500b7a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aee760d4a254ba395540f5500b7a74">&#9670;&#160;</a></span>TrackingVolumeBoundaryPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a46aee760d4a254ba395540f5500b7a74">Acts::TrackingVolumeBoundaryPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::shared_ptr&lt;const BoundarySurfaceT&lt;TrackingVolume&gt;&gt;</div>
</div><!-- fragment -->
<p>Shared pointer to a constant BoundarySurfaceT of a TrackingVolume. </p>

</div>
</div>
<a id="adf2d7adffd50e2d6dd1dbeb65fb658ed" name="adf2d7adffd50e2d6dd1dbeb65fb658ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2d7adffd50e2d6dd1dbeb65fb658ed">&#9670;&#160;</a></span>TrackingVolumeOrderPosition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adf2d7adffd50e2d6dd1dbeb65fb658ed">Acts::TrackingVolumeOrderPosition</a> = std::pair&lt;<a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a>, <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair associating a tracking volume with its position vector. </p>
<dl class="section note"><dt>Note</dt><dd>Used for ordering tracking volumes in a spatial array. </dd></dl>

</div>
</div>
<a id="a2d207ef0f7109becc8fba98cb145ed9d" name="a2d207ef0f7109becc8fba98cb145ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d207ef0f7109becc8fba98cb145ed9d">&#9670;&#160;</a></span>TrackingVolumePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> &gt; <a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">Acts::TrackingVolumePtr</a> = std::shared_ptr&lt;const <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::shared_ptr to a tracking volume. </p>
<p>Interface types of the Gen1 geometry model.</p>
<dl class="section note"><dt>Note</dt><dd>This interface is being replaced, and is subject to removal </dd></dl>

</div>
</div>
<a id="a4230ba1191701d7b7fbed04b39a8d2f2" name="a4230ba1191701d7b7fbed04b39a8d2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4230ba1191701d7b7fbed04b39a8d2f2">&#9670;&#160;</a></span>TrackingVolumeVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a> &gt; <a class="el" href="#a4230ba1191701d7b7fbed04b39a8d2f2">Acts::TrackingVolumeVector</a> = std::vector&lt;<a class="el" href="#a2d207ef0f7109becc8fba98cb145ed9d">TrackingVolumePtr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::vector of a std::shared_ptr to a TrackingVolume. </p>

</div>
</div>
<a id="a852fc4a2512213a43398b39341378a1d" name="a852fc4a2512213a43398b39341378a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852fc4a2512213a43398b39341378a1d">&#9670;&#160;</a></span>TrackLinearizer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a852fc4a2512213a43398b39341378a1d">Acts::TrackLinearizer</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> <a class="code hl_class" href="class_acts_1_1_delegate.html">Acts::Delegate&lt;Result&lt;LinearizedTrack&gt;</a>(</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_typedef" href="#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a>&amp; params, <span class="keywordtype">double</span> linPointTime,</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_surface.html">Surface</a>&amp; perigeeSurface, <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a>&amp; gctx,</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_class" href="class_acts_1_1_magnetic_field_context.html">Acts::MagneticFieldContext</a>&amp; mctx,</div>
<div class="line">    <a class="code hl_typedef" href="class_acts_1_1_magnetic_field_provider.html#a1f11a18dff2bb4106d1c1f76ff25e1d9">MagneticFieldProvider::Cache</a>&amp; fieldCache)&gt;</div>
<div class="ttc" id="aclass_acts_1_1_magnetic_field_context_html"><div class="ttname"><a href="class_acts_1_1_magnetic_field_context.html">Acts::MagneticFieldContext</a></div><div class="ttdoc">Context object for lookup of magnetic field values.</div><div class="ttdef"><b>Definition</b> MagneticFieldContext.hpp:34</div></div>
<div class="ttc" id="aclass_acts_1_1_magnetic_field_provider_html_a1f11a18dff2bb4106d1c1f76ff25e1d9"><div class="ttname"><a href="class_acts_1_1_magnetic_field_provider.html#a1f11a18dff2bb4106d1c1f76ff25e1d9">Acts::MagneticFieldProvider::Cache</a></div><div class="ttdeci">Acts::AnyBase&lt; sizeof(char) *512 &gt; Cache</div><div class="ttdoc">Opaque cache type that can store arbitrary implementation specific cache data.</div><div class="ttdef"><b>Definition</b> MagneticFieldProvider.hpp:71</div></div>
<div class="ttc" id="anamespace_acts_html_ad836aba005ba272c0a77227311e4a0ce"><div class="ttname"><a href="#ad836aba005ba272c0a77227311e4a0ce">Acts::BoundTrackParameters</a></div><div class="ttdeci">GenericBoundTrackParameters&lt; ParticleHypothesis &gt; BoundTrackParameters</div><div class="ttdoc">BoundTrackParameters can hold any kind of charge.</div><div class="ttdef"><b>Definition</b> TrackParameters.hpp:34</div></div>
</div><!-- fragment -->
<p>A delegate for linearizing a track at a given point in time and surface. </p>
<dl class="section note"><dt>Note</dt><dd>Used for track fitting and vertexing. </dd></dl>

</div>
</div>
<a id="ab89ce687d622245c5610b79701471285" name="ab89ce687d622245c5610b79701471285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab89ce687d622245c5610b79701471285">&#9670;&#160;</a></span>V3Matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab89ce687d622245c5610b79701471285">Acts::V3Matrix</a> = std::vector&lt;<a class="el" href="#a6173fd5678f75d05d96cd30cfb5bab0a">V3Vector</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matrix (2D vector) of 3D vectors, used for storing grid-like collections of 3D points. </p>

</div>
</div>
<a id="a6173fd5678f75d05d96cd30cfb5bab0a" name="a6173fd5678f75d05d96cd30cfb5bab0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6173fd5678f75d05d96cd30cfb5bab0a">&#9670;&#160;</a></span>V3Vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a6173fd5678f75d05d96cd30cfb5bab0a">Acts::V3Vector</a> = std::vector&lt;<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of 3D vectors, used for storing collections of 3D points. </p>

</div>
</div>
<a id="aaaa9c77f4dd9efc1ac464d9a941f2ef2" name="aaaa9c77f4dd9efc1ac464d9a941f2ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa9c77f4dd9efc1ac464d9a941f2ef2">&#9670;&#160;</a></span>VariableBoundSubspaceHelper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aaaa9c77f4dd9efc1ac464d9a941f2ef2">Acts::VariableBoundSubspaceHelper</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_variable_subspace_helper.html">VariableSubspaceHelper&lt;Acts::eBoundSize, std::uint8_t&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_variable_subspace_helper_html"><div class="ttname"><a href="class_acts_1_1_variable_subspace_helper.html">Acts::VariableSubspaceHelper</a></div><div class="ttdoc">Helper class for variable subspace operations.</div><div class="ttdef"><b>Definition</b> SubspaceHelpers.hpp:186</div></div>
</div><!-- fragment -->
<p>Helper type for variable-size bound parameter subspaces. </p>
<p>Provides utilities for working with variable-size subspaces of bound track parameters. </p>

</div>
</div>
<a id="aca88659ee97e667013784c4fac8475f2" name="aca88659ee97e667013784c4fac8475f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca88659ee97e667013784c4fac8475f2">&#9670;&#160;</a></span>VolumeBoundFactory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aca88659ee97e667013784c4fac8475f2">Acts::VolumeBoundFactory</a> = <a class="el" href="class_acts_1_1_bound_factory.html">BoundFactory</a>&lt;<a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abrivation for a factory to construct volume bounds. </p>

</div>
</div>
<a id="adab8ee0743a2872f4ca6888b37c65f04" name="adab8ee0743a2872f4ca6888b37c65f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab8ee0743a2872f4ca6888b37c65f04">&#9670;&#160;</a></span>VolumeMaterialMaps</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#adab8ee0743a2872f4ca6888b37c65f04">Acts::VolumeMaterialMaps</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    std::map&lt;GeometryIdentifier, std::shared_ptr&lt;const IVolumeMaterial&gt;&gt;</div>
</div><!-- fragment -->
<p>Type alias for volume material maps indexed by geometry identifier. </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a578206dbf1d765d06d19c1ec233a4159" name="a578206dbf1d765d06d19c1ec233a4159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578206dbf1d765d06d19c1ec233a4159">&#9670;&#160;</a></span>AlignmentIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a578206dbf1d765d06d19c1ec233a4159">Acts::AlignmentIndices</a> : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Components of alignment parameters vector. </p>
<p>To be used to access components by named indices instead of just numbers. This must be a regular <span class="tt">enum</span> and not a scoped <span class="tt">enum class</span> to allow implicit conversion to an integer. The enum value are thus visible directly in <span class="tt">namespace Acts</span> and are prefixed to avoid naming collisions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159aaef292026444af947478c571db012acd" name="a578206dbf1d765d06d19c1ec233a4159aaef292026444af947478c571db012acd"></a>eAlignmentCenter0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159ac75845e02a00fcf3d8a1e8579b550f06" name="a578206dbf1d765d06d19c1ec233a4159ac75845e02a00fcf3d8a1e8579b550f06"></a>eAlignmentCenter1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159a617f7adc10f363908f07af4ec7bc8633" name="a578206dbf1d765d06d19c1ec233a4159a617f7adc10f363908f07af4ec7bc8633"></a>eAlignmentCenter2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159a597a8de9dee10809695ff4bd6df486d4" name="a578206dbf1d765d06d19c1ec233a4159a597a8de9dee10809695ff4bd6df486d4"></a>eAlignmentRotation0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159a8ad05c974aec053517f0da995ba14d1d" name="a578206dbf1d765d06d19c1ec233a4159a8ad05c974aec053517f0da995ba14d1d"></a>eAlignmentRotation1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159ad497001f2d872027a1ee296173d125ef" name="a578206dbf1d765d06d19c1ec233a4159ad497001f2d872027a1ee296173d125ef"></a>eAlignmentRotation2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989" name="a578206dbf1d765d06d19c1ec233a4159a99b77fdc7d20ab5e468aae94c722a989"></a>eAlignmentSize&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8cacb654fb3407f6911cfcf424f69ba7" name="a8cacb654fb3407f6911cfcf424f69ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cacb654fb3407f6911cfcf424f69ba7">&#9670;&#160;</a></span>AxisBoundaryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">Acts::AxisBoundaryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum which determines how the axis handle its outer boundaries possible values values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274" name="a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274"></a>Open&#160;</td><td class="fielddoc"><p>Default behaviour: out of bounds positions are filled into the over or underflow bins. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8cacb654fb3407f6911cfcf424f69ba7a685d1f2146dd079015e81918414e8971" name="a8cacb654fb3407f6911cfcf424f69ba7a685d1f2146dd079015e81918414e8971"></a>Bound&#160;</td><td class="fielddoc"><p>Out-of-bounds positions resolve to first/last bin respectively. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8cacb654fb3407f6911cfcf424f69ba7a03f4a47830f97377a35321051685071e" name="a8cacb654fb3407f6911cfcf424f69ba7a03f4a47830f97377a35321051685071e"></a>Closed&#160;</td><td class="fielddoc"><p>Out-of-bounds positions resolve to the outermost bin on the opposite side. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1462738699cb376ae92c59811987f4ea" name="a1462738699cb376ae92c59811987f4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1462738699cb376ae92c59811987f4ea">&#9670;&#160;</a></span>AxisDirection</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>to specify a local axis direction </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaa38b0844100a915cd3c87159b391161b9" name="a1462738699cb376ae92c59811987f4eaa38b0844100a915cd3c87159b391161b9"></a>AxisX&#160;</td><td class="fielddoc"><p>AxisX, AxisY, AxisZ are the cartesian directions in the local frame. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaab30a50c686982b3b209cf1234f4247cd" name="a1462738699cb376ae92c59811987f4eaab30a50c686982b3b209cf1234f4247cd"></a>AxisY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaadd1071c1aa89157c2386d3303413218f" name="a1462738699cb376ae92c59811987f4eaadd1071c1aa89157c2386d3303413218f"></a>AxisZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaa66964a770b69520967ff845d6a141d7b" name="a1462738699cb376ae92c59811987f4eaa66964a770b69520967ff845d6a141d7b"></a>AxisR&#160;</td><td class="fielddoc"><p>AxisR is a radial direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaa767ac49408b49422cdfdfa90582e7c50" name="a1462738699cb376ae92c59811987f4eaa767ac49408b49422cdfdfa90582e7c50"></a>AxisPhi&#160;</td><td class="fielddoc"><p>AxisPhi is the azimuthal direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaaac2cc7059f8482e8c68cc9849e8a9883" name="a1462738699cb376ae92c59811987f4eaaac2cc7059f8482e8c68cc9849e8a9883"></a>AxisRPhi&#160;</td><td class="fielddoc"><p>AxisRPhi is the radial-azimuthal direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaaa6a30a95d4c241fdfd6baf44cb77c03a" name="a1462738699cb376ae92c59811987f4eaaa6a30a95d4c241fdfd6baf44cb77c03a"></a>AxisTheta&#160;</td><td class="fielddoc"><p>AxisTheta is the polar angle direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaaec435e5ddb1e69ebe1aeb7a9302fa4fa" name="a1462738699cb376ae92c59811987f4eaaec435e5ddb1e69ebe1aeb7a9302fa4fa"></a>AxisEta&#160;</td><td class="fielddoc"><p>AxisEta is the pseudorapidity direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1462738699cb376ae92c59811987f4eaa8f7ef15062f2d841678dc6358d2691c9" name="a1462738699cb376ae92c59811987f4eaa8f7ef15062f2d841678dc6358d2691c9"></a>AxisMag&#160;</td><td class="fielddoc"><p>AxisMag is the magnitude of the vector. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2472b7e663ee623501edad0bbcd8a32f" name="a2472b7e663ee623501edad0bbcd8a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2472b7e663ee623501edad0bbcd8a32f">&#9670;&#160;</a></span>AxisType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32f">Acts::AxisType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum which determines the binning type of the axis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52" name="a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52"></a>Equidistant&#160;</td><td class="fielddoc"><p>An axis where all bins have the same size. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9" name="a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9"></a>Variable&#160;</td><td class="fielddoc"><p>An axis where bins can have different sizes. </p>
</td></tr>
</table>

</div>
</div>
<a id="a3aaee285dd8963f35f05db5e6bf23769" name="a3aaee285dd8963f35f05db5e6bf23769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aaee285dd8963f35f05db5e6bf23769">&#9670;&#160;</a></span>BinningOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a3aaee285dd8963f35f05db5e6bf23769">Acts::BinningOption</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag for open/closed bins </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3aaee285dd8963f35f05db5e6bf23769a67f93521db5cc254387b8e1437c0691e" name="a3aaee285dd8963f35f05db5e6bf23769a67f93521db5cc254387b8e1437c0691e"></a>open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3aaee285dd8963f35f05db5e6bf23769a612c34ec7764ae1c94b0382e8bd7534c" name="a3aaee285dd8963f35f05db5e6bf23769a612c34ec7764ae1c94b0382e8bd7534c"></a>closed&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a137e6814b0021a40f572aeb4922a7b81" name="a137e6814b0021a40f572aeb4922a7b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137e6814b0021a40f572aeb4922a7b81">&#9670;&#160;</a></span>BinningType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>, BinningOption &amp; BinningAccess </p>
<ul>
<li><p class="startli">BinningType:</p>
<p class="startli">Enumeration to qualify the binning type for the use of the LayerArrayCreator and the TrackingVolumeArrayCreator</p><ul>
<li>BinningOption: open: [0,max] closed: 0 -&gt; nextbin -&gt; max -&gt; 0</li>
<li>AxisDirection necessary access to global positions </li>
</ul>
</li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe" name="a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe"></a>equidistant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a137e6814b0021a40f572aeb4922a7b81a3fb230d5b902fe93692b1f49e7175330" name="a137e6814b0021a40f572aeb4922a7b81a3fb230d5b902fe93692b1f49e7175330"></a>arbitrary&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a324b54b2d52fbc9244d94e305d9203d3" name="a324b54b2d52fbc9244d94e305d9203d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324b54b2d52fbc9244d94e305d9203d3">&#9670;&#160;</a></span>BoundarySurfaceFace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3">Acts::BoundarySurfaceFace</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to describe the position of the BoundarySurface respectively to the frame orientatin of the volume, this is mainly meant for code readability. </p>
<p>The different numeration sequences can be found in the documentation of the actual VolumeBounds implementations.</p>
<p>The order of faces is chosen to follow - as much as possible - a circular structure. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a5d700bbf3210b96dff5d012da022356e" name="a324b54b2d52fbc9244d94e305d9203d3a5d700bbf3210b96dff5d012da022356e"></a>negativeFaceXY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a3badb5ad699267cc1a28104441d94b54" name="a324b54b2d52fbc9244d94e305d9203d3a3badb5ad699267cc1a28104441d94b54"></a>positiveFaceXY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a3294c592ff615ee3c44b46e7efc22127" name="a324b54b2d52fbc9244d94e305d9203d3a3294c592ff615ee3c44b46e7efc22127"></a>negativeFaceYZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a4e27416cba7eb8a49ab97d922973dc4d" name="a324b54b2d52fbc9244d94e305d9203d3a4e27416cba7eb8a49ab97d922973dc4d"></a>positiveFaceYZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a2bb138735d0be5d1b535262344472a62" name="a324b54b2d52fbc9244d94e305d9203d3a2bb138735d0be5d1b535262344472a62"></a>negativeFaceZX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3ab2b6bf00a36b9daf9c8ecef5bbf9f5fe" name="a324b54b2d52fbc9244d94e305d9203d3ab2b6bf00a36b9daf9c8ecef5bbf9f5fe"></a>positiveFaceZX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a43c803702f6b49fe865151617ae1cf81" name="a324b54b2d52fbc9244d94e305d9203d3a43c803702f6b49fe865151617ae1cf81"></a>cylinderCover&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3ae9823396740c5ac0ec5530c5f5f692ef" name="a324b54b2d52fbc9244d94e305d9203d3ae9823396740c5ac0ec5530c5f5f692ef"></a>tubeInnerCover&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3aceff7580baab43d7f4b284d71e76dd2c" name="a324b54b2d52fbc9244d94e305d9203d3aceff7580baab43d7f4b284d71e76dd2c"></a>tubeOuterCover&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a486df768d6da0470744a1061c973ea17" name="a324b54b2d52fbc9244d94e305d9203d3a486df768d6da0470744a1061c973ea17"></a>tubeSectorNegativePhi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3afeaf47f7a139d2f5fe67a66429d62e49" name="a324b54b2d52fbc9244d94e305d9203d3afeaf47f7a139d2f5fe67a66429d62e49"></a>tubeSectorPositivePhi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3af68f13975eeb1abccb155ef5b06c09ea" name="a324b54b2d52fbc9244d94e305d9203d3af68f13975eeb1abccb155ef5b06c09ea"></a>tubeSectorInnerCover&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3ac40da2094a0ce562c252a8f883c4439c" name="a324b54b2d52fbc9244d94e305d9203d3ac40da2094a0ce562c252a8f883c4439c"></a>tubeSectorOuterCover&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a5161a0d6a21c039846664ebcb9f10ad5" name="a324b54b2d52fbc9244d94e305d9203d3a5161a0d6a21c039846664ebcb9f10ad5"></a>trapezoidFaceAlpha&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3aba35a7a655d5560cbbcbb657680e4089" name="a324b54b2d52fbc9244d94e305d9203d3aba35a7a655d5560cbbcbb657680e4089"></a>trapezoidFaceBeta&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a0f93dcc0cf89a91eed40a82af3184e72" name="a324b54b2d52fbc9244d94e305d9203d3a0f93dcc0cf89a91eed40a82af3184e72"></a>index0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a0b93936a59efef879bf69ab34f755964" name="a324b54b2d52fbc9244d94e305d9203d3a0b93936a59efef879bf69ab34f755964"></a>index1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a312584e16590945fb13813268f963d4a" name="a324b54b2d52fbc9244d94e305d9203d3a312584e16590945fb13813268f963d4a"></a>index2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3ac618d3184185f1567e2af0bf1e196189" name="a324b54b2d52fbc9244d94e305d9203d3ac618d3184185f1567e2af0bf1e196189"></a>index3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3ab5d6337bb7ba571539ca9fe73132dd70" name="a324b54b2d52fbc9244d94e305d9203d3ab5d6337bb7ba571539ca9fe73132dd70"></a>index4&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a34dc1389401d5d65bc4a1afb71e0f898" name="a324b54b2d52fbc9244d94e305d9203d3a34dc1389401d5d65bc4a1afb71e0f898"></a>index5&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a3285c51c14f80248857d027ba6306b32" name="a324b54b2d52fbc9244d94e305d9203d3a3285c51c14f80248857d027ba6306b32"></a>index6&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a658371a18be45142005f224715810b79" name="a324b54b2d52fbc9244d94e305d9203d3a658371a18be45142005f224715810b79"></a>index7&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a3f62b73ba16ca67d539b0eea46f82564" name="a324b54b2d52fbc9244d94e305d9203d3a3f62b73ba16ca67d539b0eea46f82564"></a>index8&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3a6322b794b9e4e6e6934526a2ed3651ad" name="a324b54b2d52fbc9244d94e305d9203d3a6322b794b9e4e6e6934526a2ed3651ad"></a>index9&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3ae71bbf8540421d745ac7154811ae8181" name="a324b54b2d52fbc9244d94e305d9203d3ae71bbf8540421d745ac7154811ae8181"></a>index10&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3adf5b663d9a4d3b2593032dcaebfac7a9" name="a324b54b2d52fbc9244d94e305d9203d3adf5b663d9a4d3b2593032dcaebfac7a9"></a>index11&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a324b54b2d52fbc9244d94e305d9203d3af0f501d6c9600e66c267af09f0574e8a" name="a324b54b2d52fbc9244d94e305d9203d3af0f501d6c9600e66c267af09f0574e8a"></a>undefinedFace&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7">&#9670;&#160;</a></span>BoundIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7">Acts::BoundIndices</a> : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Components of a bound track parameters vector. </p>
<p>To be used to access components by named indices instead of just numbers. This must be a regular <span class="tt">enum</span> and not a scoped <span class="tt">enum class</span> to allow implicit conversion to an integer. The enum value are thus visible directly in <span class="tt">namespace Acts</span> and are prefixed to avoid naming collisions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a319222836e2703f23f7abbec507ea82e" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a319222836e2703f23f7abbec507ea82e"></a>eBoundLoc0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a4259ac51b5652240e3102b8f32de1e58" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a4259ac51b5652240e3102b8f32de1e58"></a>eBoundLoc1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a66c6483e3948c3bf8284289300e30375" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a66c6483e3948c3bf8284289300e30375"></a>eBoundPhi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a9ca150ef5e671d4463771fb250fffdb7" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a9ca150ef5e671d4463771fb250fffdb7"></a>eBoundTheta&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a4391499f36e0f4817927d2bca12ece83" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a4391499f36e0f4817927d2bca12ece83"></a>eBoundQOverP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a31c17ef85d34327f7da749b96b1f0f5f" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a31c17ef85d34327f7da749b96b1f0f5f"></a>eBoundTime&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8" name="ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8"></a>eBoundSize&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a07a86fac65395a5f95452259e7872ecc" name="a07a86fac65395a5f95452259e7872ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a86fac65395a5f95452259e7872ecc">&#9670;&#160;</a></span>CoordinateIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a07a86fac65395a5f95452259e7872ecc">Acts::CoordinateIndices</a> : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Components of coordinate vectors. </p>
<p>To be used to access coordinate components by named indices instead of magic numbers. This must be a regular <span class="tt">enum</span> and not a scoped <span class="tt">enum class</span> to allow implicit conversion to an integer. The enum value are thus visible directly in <span class="tt">namespace Acts</span>.</p>
<p>This index enum is not user-configurable (in contrast e.g. to the track parameter index enums) since it must be compatible with varying dimensionality (2d-4d) and other access methods (<span class="tt">.{x,y,z}()</span> accessors). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872eccac46dd3bdcb88e54d86077aa499e4a84d" name="a07a86fac65395a5f95452259e7872eccac46dd3bdcb88e54d86077aa499e4a84d"></a>ePos0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca85bf6038f2eee2fb999303930ca53005" name="a07a86fac65395a5f95452259e7872ecca85bf6038f2eee2fb999303930ca53005"></a>ePos1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca1485bf9e3844cb8613b7c8a3db1a8658" name="a07a86fac65395a5f95452259e7872ecca1485bf9e3844cb8613b7c8a3db1a8658"></a>ePos2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca42f43e4f9334887d02a4f321975e5af3" name="a07a86fac65395a5f95452259e7872ecca42f43e4f9334887d02a4f321975e5af3"></a>eTime&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca2499a9f1c7c7c4479671ef8460cae0fb" name="a07a86fac65395a5f95452259e7872ecca2499a9f1c7c7c4479671ef8460cae0fb"></a>eMom0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca46e52afdf781a6081758894aa7b932f1" name="a07a86fac65395a5f95452259e7872ecca46e52afdf781a6081758894aa7b932f1"></a>eMom1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca8254871e7ee04710d4c9b89ad973bc2d" name="a07a86fac65395a5f95452259e7872ecca8254871e7ee04710d4c9b89ad973bc2d"></a>eMom2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca8d77cea2a8b00c8305dc21dc92c19620" name="a07a86fac65395a5f95452259e7872ecca8d77cea2a8b00c8305dc21dc92c19620"></a>eEnergy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca14506a1394164c5803e7f6db4e7a225b" name="a07a86fac65395a5f95452259e7872ecca14506a1394164c5803e7f6db4e7a225b"></a>eX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872ecca044d957dc4b3a5e03bbc2f48fe6c143d" name="a07a86fac65395a5f95452259e7872ecca044d957dc4b3a5e03bbc2f48fe6c143d"></a>eY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a07a86fac65395a5f95452259e7872eccac492522bc7badaffc0024a54070e5a97" name="a07a86fac65395a5f95452259e7872eccac492522bc7badaffc0024a54070e5a97"></a>eZ&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="abd2611d6c7dda89bd26dd00c64538490" name="abd2611d6c7dda89bd26dd00c64538490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2611d6c7dda89bd26dd00c64538490">&#9670;&#160;</a></span>DelegateType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#abd2611d6c7dda89bd26dd00c64538490">Acts::DelegateType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ownership enum for <code>Delegate</code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abd2611d6c7dda89bd26dd00c64538490ae0fdb994c5952ea712f1509aeb7ba380" name="abd2611d6c7dda89bd26dd00c64538490ae0fdb994c5952ea712f1509aeb7ba380"></a>Owning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abd2611d6c7dda89bd26dd00c64538490a64a6a344ccce441462a47f08e206df86" name="abd2611d6c7dda89bd26dd00c64538490a64a6a344ccce441462a47f08e206df86"></a>NonOwning&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a940f149b53e1e3b9e3c4302f082e0fe9" name="a940f149b53e1e3b9e3c4302f082e0fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940f149b53e1e3b9e3c4302f082e0fe9">&#9670;&#160;</a></span>DetectorMeasurementInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a940f149b53e1e3b9e3c4302f082e0fe9">Acts::DetectorMeasurementInfo</a> : short</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Level of detector measurement information for seeding. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a940f149b53e1e3b9e3c4302f082e0fe9aaf71f03861810014d736fcbae9d6050e" name="a940f149b53e1e3b9e3c4302f082e0fe9aaf71f03861810014d736fcbae9d6050e"></a>eDefault&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a940f149b53e1e3b9e3c4302f082e0fe9acaf83905292e2bacf405591fb8b79727" name="a940f149b53e1e3b9e3c4302f082e0fe9acaf83905292e2bacf405591fb8b79727"></a>eDetailed&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a6c086a09086424ffb3ace68710e8e92c" name="a6c086a09086424ffb3ace68710e8e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c086a09086424ffb3ace68710e8e92c">&#9670;&#160;</a></span>FreeIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a6c086a09086424ffb3ace68710e8e92c">Acts::FreeIndices</a> : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Components of a free track parameters vector. </p>
<p>To be used to access components by named indices instead of just numbers. This must be a regular <span class="tt">enum</span> and not a scoped <span class="tt">enum class</span> to allow implicit conversion to an integer. The enum value are thus visible directly in <span class="tt">namespace Acts</span> and are prefixed to avoid naming collisions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca4f1d0ebd2431f946d8f901bac6617db9" name="a6c086a09086424ffb3ace68710e8e92ca4f1d0ebd2431f946d8f901bac6617db9"></a>eFreePos0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca45d56ebce4df7ade3176b2c0b6e6c90e" name="a6c086a09086424ffb3ace68710e8e92ca45d56ebce4df7ade3176b2c0b6e6c90e"></a>eFreePos1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca5a25393ea9eb37898e45369ea02ae6fd" name="a6c086a09086424ffb3ace68710e8e92ca5a25393ea9eb37898e45369ea02ae6fd"></a>eFreePos2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca73bbfd1eb6084375bbd8cf207abcf2d2" name="a6c086a09086424ffb3ace68710e8e92ca73bbfd1eb6084375bbd8cf207abcf2d2"></a>eFreeTime&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca3994d4b5c6c143561e23cd964d61f916" name="a6c086a09086424ffb3ace68710e8e92ca3994d4b5c6c143561e23cd964d61f916"></a>eFreeDir0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca21c44b4c6040114e447c024a5bdc4c88" name="a6c086a09086424ffb3ace68710e8e92ca21c44b4c6040114e447c024a5bdc4c88"></a>eFreeDir1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92cac12a01ff06374c51606d4761c1ff0421" name="a6c086a09086424ffb3ace68710e8e92cac12a01ff06374c51606d4761c1ff0421"></a>eFreeDir2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92cab2fad9ef29e2cec612213d6174338fed" name="a6c086a09086424ffb3ace68710e8e92cab2fad9ef29e2cec612213d6174338fed"></a>eFreeQOverP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd" name="a6c086a09086424ffb3ace68710e8e92ca15f9e9d870d2680cc3dfdd89c7a609cd"></a>eFreeSize&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af38a8ff832aa2393884b0dbed498973c" name="af38a8ff832aa2393884b0dbed498973c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38a8ff832aa2393884b0dbed498973c">&#9670;&#160;</a></span>HadronType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#af38a8ff832aa2393884b0dbed498973c">Acts::HadronType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hadron type classification for B, C, strange and light hadrons. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca05fd33582850f21e2bac245a57bbcae3" name="af38a8ff832aa2393884b0dbed498973ca05fd33582850f21e2bac245a57bbcae3"></a>Hadron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca18a3f4d13a168be3fdc6e6760c9d70c8" name="af38a8ff832aa2393884b0dbed498973ca18a3f4d13a168be3fdc6e6760c9d70c8"></a>BBbarMeson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973cafe4b1b6a56ba9f1d9b3c68b9fd4fd050" name="af38a8ff832aa2393884b0dbed498973cafe4b1b6a56ba9f1d9b3c68b9fd4fd050"></a>CCbarMeson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973cabda747bb379bd7a6c7c91ae3e0c9ad6d" name="af38a8ff832aa2393884b0dbed498973cabda747bb379bd7a6c7c91ae3e0c9ad6d"></a>BottomMeson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca3d0d31ea59ea13b6d0e3ce5cfba8ba0e" name="af38a8ff832aa2393884b0dbed498973ca3d0d31ea59ea13b6d0e3ce5cfba8ba0e"></a>BottomBaryon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973caeb2955155f246ef86400cc8045f3c18a" name="af38a8ff832aa2393884b0dbed498973caeb2955155f246ef86400cc8045f3c18a"></a>CharmedMeson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca36871f11d12474317be626854e8335c8" name="af38a8ff832aa2393884b0dbed498973ca36871f11d12474317be626854e8335c8"></a>CharmedBaryon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca15b2a12bd2d6241cabca2a828dc01f63" name="af38a8ff832aa2393884b0dbed498973ca15b2a12bd2d6241cabca2a828dc01f63"></a>StrangeMeson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973caf0cd241c4882b44a45437d98659451ad" name="af38a8ff832aa2393884b0dbed498973caf0cd241c4882b44a45437d98659451ad"></a>StrangeBaryon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973caaf0ffccf43f99415f875121886d30ce3" name="af38a8ff832aa2393884b0dbed498973caaf0ffccf43f99415f875121886d30ce3"></a>LightMeson&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca1c084319d0244f24aa37338cbc757308" name="af38a8ff832aa2393884b0dbed498973ca1c084319d0244f24aa37338cbc757308"></a>LightBaryon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af38a8ff832aa2393884b0dbed498973ca88183b946cc5f0e8c96b2e66e1c74a7e" name="af38a8ff832aa2393884b0dbed498973ca88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a52191edec34daa17746d1937fb06c1fb" name="a52191edec34daa17746d1937fb06c1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52191edec34daa17746d1937fb06c1fb">&#9670;&#160;</a></span>IntersectionStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a52191edec34daa17746d1937fb06c1fb">Acts::IntersectionStatus</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Status enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52191edec34daa17746d1937fb06c1fbab748f56cf76526f8606d7463b9df9f2e" name="a52191edec34daa17746d1937fb06c1fbab748f56cf76526f8606d7463b9df9f2e"></a>unreachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52191edec34daa17746d1937fb06c1fbaa0fefe3b7423f88d38b84c1558ed4880" name="a52191edec34daa17746d1937fb06c1fbaa0fefe3b7423f88d38b84c1558ed4880"></a>reachable&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52191edec34daa17746d1937fb06c1fbab03a0aa5a9868274aece083944113f96" name="a52191edec34daa17746d1937fb06c1fbab03a0aa5a9868274aece083944113f96"></a>onSurface&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab59015c67d930641de6f1bb7e31e2873" name="ab59015c67d930641de6f1bb7e31e2873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59015c67d930641de6f1bb7e31e2873">&#9670;&#160;</a></span>LayerType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab59015c67d930641de6f1bb7e31e2873">Acts::LayerType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For code readability, it distinguishes between different type of layers, which steers the behaviour in the navigation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab59015c67d930641de6f1bb7e31e2873a7eee8a5290452963e3934c132a800094" name="ab59015c67d930641de6f1bb7e31e2873a7eee8a5290452963e3934c132a800094"></a>navigation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab59015c67d930641de6f1bb7e31e2873a75938f0b93068f7d9012f32aff225069" name="ab59015c67d930641de6f1bb7e31e2873a75938f0b93068f7d9012f32aff225069"></a>passive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab59015c67d930641de6f1bb7e31e2873aff33a3aaf8fc2bb1ae64bf505338a843" name="ab59015c67d930641de6f1bb7e31e2873aff33a3aaf8fc2bb1ae64bf505338a843"></a>active&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad7711ff8b0a2ed1a71deaa920bf8de53" name="ad7711ff8b0a2ed1a71deaa920bf8de53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7711ff8b0a2ed1a71deaa920bf8de53">&#9670;&#160;</a></span>LinIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad7711ff8b0a2ed1a71deaa920bf8de53">Acts::LinIndices</a> : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to access the components of a track parameter vector. </p>
<p>Here, we parametrize the track via a 4D point on the track, the momentum angles of the particle at that point, and q/p or 1/p.</p>
<dl class="section note"><dt>Note</dt><dd>It would make sense to rename these parameters if they are used outside of track linearization. </dd>
<dd>
This must be a regular <span class="tt">enum</span> and not a scoped <span class="tt">enum class</span> to allow implicit conversion to an integer. The enum value are thus visible directly in <span class="tt">namespace Acts</span> and are prefixed to avoid naming collisions. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53ab61ccb9775fba63767ea82991f2a4aa8" name="ad7711ff8b0a2ed1a71deaa920bf8de53ab61ccb9775fba63767ea82991f2a4aa8"></a>eLinPos0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53a69def383f20e8b9915d8ef079cf9b5fc" name="ad7711ff8b0a2ed1a71deaa920bf8de53a69def383f20e8b9915d8ef079cf9b5fc"></a>eLinPos1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53afdcdc15b4f318d666f6054195345ddf5" name="ad7711ff8b0a2ed1a71deaa920bf8de53afdcdc15b4f318d666f6054195345ddf5"></a>eLinPos2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53a964cd218b4f8977c94a74127040f4889" name="ad7711ff8b0a2ed1a71deaa920bf8de53a964cd218b4f8977c94a74127040f4889"></a>eLinTime&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53aaaebd448f83490d1a3aab1754d7c86c8" name="ad7711ff8b0a2ed1a71deaa920bf8de53aaaebd448f83490d1a3aab1754d7c86c8"></a>eLinPhi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53aa502ce288aaa601d0c5ed8b50f8842bc" name="ad7711ff8b0a2ed1a71deaa920bf8de53aa502ce288aaa601d0c5ed8b50f8842bc"></a>eLinTheta&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53a1fa05a18a7a067f7f835e59deb2343d8" name="ad7711ff8b0a2ed1a71deaa920bf8de53a1fa05a18a7a067f7f835e59deb2343d8"></a>eLinQOverP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53a032dc8fb65e403795ae6c9d212a9ec99" name="ad7711ff8b0a2ed1a71deaa920bf8de53a032dc8fb65e403795ae6c9d212a9ec99"></a>eLinSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53a286de5443484550d3526a78083ac78e9" name="ad7711ff8b0a2ed1a71deaa920bf8de53a286de5443484550d3526a78083ac78e9"></a>eLinPosSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7711ff8b0a2ed1a71deaa920bf8de53a535cc24e8940862d22a62dad726a2d22" name="ad7711ff8b0a2ed1a71deaa920bf8de53a535cc24e8940862d22a62dad726a2d22"></a>eLinMomSize&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aa512dd166058e0512c8c3fb3195bf1f1" name="aa512dd166058e0512c8c3fb3195bf1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa512dd166058e0512c8c3fb3195bf1f1">&#9670;&#160;</a></span>MappingType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aa512dd166058e0512c8c3fb3195bf1f1">Acts::MappingType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum describes the type of surface material mapping. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa512dd166058e0512c8c3fb3195bf1f1a4b89096cd32efd26f913e96e61b96e77" name="aa512dd166058e0512c8c3fb3195bf1f1a4b89096cd32efd26f913e96e61b96e77"></a>PreMapping&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa512dd166058e0512c8c3fb3195bf1f1a879c8d57398ac17a2d7ecaea65021e85" name="aa512dd166058e0512c8c3fb3195bf1f1a879c8d57398ac17a2d7ecaea65021e85"></a>Default&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa512dd166058e0512c8c3fb3195bf1f1ae9a8b8024c5ca45ba5848e8f46dc38fe" name="aa512dd166058e0512c8c3fb3195bf1f1ae9a8b8024c5ca45ba5848e8f46dc38fe"></a>PostMapping&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa512dd166058e0512c8c3fb3195bf1f1aaeef76ca06f887c6eb3fcc9d41de53cd" name="aa512dd166058e0512c8c3fb3195bf1f1aaeef76ca06f887c6eb3fcc9d41de53cd"></a>Sensor&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab0d37c993fdcfd74f77026bbee8e6d02" name="ab0d37c993fdcfd74f77026bbee8e6d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d37c993fdcfd74f77026bbee8e6d02">&#9670;&#160;</a></span>MaterialUpdateStage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02">Acts::MaterialUpdateStage</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a steering enum to tell which material update stage: </p>
<ul>
<li>PreUpdate : update on approach of a surface</li>
<li>FullUpdate : update when passing a surface</li>
<li>PostUpdate : update when leaving a surface </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab0d37c993fdcfd74f77026bbee8e6d02a4d6938dc46ac97dde005fab44a01386c" name="ab0d37c993fdcfd74f77026bbee8e6d02a4d6938dc46ac97dde005fab44a01386c"></a>PreUpdate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab0d37c993fdcfd74f77026bbee8e6d02a6d52930efc1d9c5bdf5424d98f7cd0dd" name="ab0d37c993fdcfd74f77026bbee8e6d02a6d52930efc1d9c5bdf5424d98f7cd0dd"></a>FullUpdate&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab0d37c993fdcfd74f77026bbee8e6d02ad1265336b66d91a1fc4f5904e34591f4" name="ab0d37c993fdcfd74f77026bbee8e6d02ad1265336b66d91a1fc4f5904e34591f4"></a>PostUpdate&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ae866cb8853468d56eec07abde7529017" name="ae866cb8853468d56eec07abde7529017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae866cb8853468d56eec07abde7529017">&#9670;&#160;</a></span>NoiseUpdateMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae866cb8853468d56eec07abde7529017">Acts::NoiseUpdateMode</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>to tell how to deal with noise term in covariance transport </p>
<ul>
<li>removeNoise: subtract noise term</li>
<li>addNoise: add noise term </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae866cb8853468d56eec07abde7529017a6cead0401bac5c1c67415a40ec3e6ef8" name="ae866cb8853468d56eec07abde7529017a6cead0401bac5c1c67415a40ec3e6ef8"></a>removeNoise&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae866cb8853468d56eec07abde7529017a524abb48de7322499dcaefc3f1703f41" name="ae866cb8853468d56eec07abde7529017a524abb48de7322499dcaefc3f1703f41"></a>addNoise&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9be1c6a7aba3d2c58133f9f2f10db45a" name="a9be1c6a7aba3d2c58133f9f2f10db45a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be1c6a7aba3d2c58133f9f2f10db45a">&#9670;&#160;</a></span>PdgParticle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">Acts::PdgParticle</a> : std::int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolic values for commonly used PDG particle numbers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa13a6d0b0ebf11ef63492283b62f06980" name="a9be1c6a7aba3d2c58133f9f2f10db45aa13a6d0b0ebf11ef63492283b62f06980"></a>eInvalid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa37d22ad8c1c4d8f9978fb361dc0afd97" name="a9be1c6a7aba3d2c58133f9f2f10db45aa37d22ad8c1c4d8f9978fb361dc0afd97"></a>eElectron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa7ad9d5e84f03e12c6975bd9d777b2bae" name="a9be1c6a7aba3d2c58133f9f2f10db45aa7ad9d5e84f03e12c6975bd9d777b2bae"></a>eAntiElectron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa2fb00d1e473c1551df098fbec5799821" name="a9be1c6a7aba3d2c58133f9f2f10db45aa2fb00d1e473c1551df098fbec5799821"></a>ePositron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aabd17e2bdce82e55f45068a7d2b2f9b7d" name="a9be1c6a7aba3d2c58133f9f2f10db45aabd17e2bdce82e55f45068a7d2b2f9b7d"></a>eMuon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa54358b25b4d27f147aca846e51ebcd64" name="a9be1c6a7aba3d2c58133f9f2f10db45aa54358b25b4d27f147aca846e51ebcd64"></a>eAntiMuon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa98d074094e790340c26424143eed5027" name="a9be1c6a7aba3d2c58133f9f2f10db45aa98d074094e790340c26424143eed5027"></a>eTau&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aaa4c0641c077f3dd69c074c61e32f6aa0" name="a9be1c6a7aba3d2c58133f9f2f10db45aaa4c0641c077f3dd69c074c61e32f6aa0"></a>eAntiTau&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa93b2449a6d5111598190a4c5ee9aa9f4" name="a9be1c6a7aba3d2c58133f9f2f10db45aa93b2449a6d5111598190a4c5ee9aa9f4"></a>eGamma&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aaf1358b190ecf758556ccc6487184f6d0" name="a9be1c6a7aba3d2c58133f9f2f10db45aaf1358b190ecf758556ccc6487184f6d0"></a>ePionZero&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aaf08fabfa0dde26e4cc054f5628edf9da" name="a9be1c6a7aba3d2c58133f9f2f10db45aaf08fabfa0dde26e4cc054f5628edf9da"></a>ePionPlus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa3540c2184257b4bb0fbfabf3d04a6703" name="a9be1c6a7aba3d2c58133f9f2f10db45aa3540c2184257b4bb0fbfabf3d04a6703"></a>ePionMinus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aacae7f3de2b60dfc8d6d8bff99a7d5992" name="a9be1c6a7aba3d2c58133f9f2f10db45aacae7f3de2b60dfc8d6d8bff99a7d5992"></a>eKaonPlus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa9f390790c94434763ff0a21a3543c1b2" name="a9be1c6a7aba3d2c58133f9f2f10db45aa9f390790c94434763ff0a21a3543c1b2"></a>eKaonMinus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa53098b2a6aa14ce2fa1d6d0a6850ebd2" name="a9be1c6a7aba3d2c58133f9f2f10db45aa53098b2a6aa14ce2fa1d6d0a6850ebd2"></a>eNeutron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa2887b3f033a578994325bd49bd918b16" name="a9be1c6a7aba3d2c58133f9f2f10db45aa2887b3f033a578994325bd49bd918b16"></a>eAntiNeutron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aadaa2c708e4438ed9b8c0146c5c2e7b47" name="a9be1c6a7aba3d2c58133f9f2f10db45aadaa2c708e4438ed9b8c0146c5c2e7b47"></a>eProton&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aaffdb7d1ac82a29b8a83b4356f2302a1a" name="a9be1c6a7aba3d2c58133f9f2f10db45aaffdb7d1ac82a29b8a83b4356f2302a1a"></a>eAntiProton&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa2c1d791271000b6be35a03f5174fc05c" name="a9be1c6a7aba3d2c58133f9f2f10db45aa2c1d791271000b6be35a03f5174fc05c"></a>eLead&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aae10b772b24a08619b6fac59a704cffc3" name="a9be1c6a7aba3d2c58133f9f2f10db45aae10b772b24a08619b6fac59a704cffc3"></a>eJPsi&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa8f0bbf2aca73f4ace66a179b8f4a69e7" name="a9be1c6a7aba3d2c58133f9f2f10db45aa8f0bbf2aca73f4ace66a179b8f4a69e7"></a>eB0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aadbf51e07b8eb6e3142922ef908362a87" name="a9be1c6a7aba3d2c58133f9f2f10db45aadbf51e07b8eb6e3142922ef908362a87"></a>eBPlus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aab6968f1400c64c29c7cb6a71885cf301" name="a9be1c6a7aba3d2c58133f9f2f10db45aab6968f1400c64c29c7cb6a71885cf301"></a>eD0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa65e442ad8935aa7f1282d63903279639" name="a9be1c6a7aba3d2c58133f9f2f10db45aa65e442ad8935aa7f1282d63903279639"></a>eDPlus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa21c3e8341cb36bb0b70e32c7b6182e60" name="a9be1c6a7aba3d2c58133f9f2f10db45aa21c3e8341cb36bb0b70e32c7b6182e60"></a>eAntiB0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aab990975b83ba30997cce3ec1a694aa59" name="a9be1c6a7aba3d2c58133f9f2f10db45aab990975b83ba30997cce3ec1a694aa59"></a>eAntiD0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa349ae6e855149993b77aa6dc43972357" name="a9be1c6a7aba3d2c58133f9f2f10db45aa349ae6e855149993b77aa6dc43972357"></a>eNeutrinoE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa7dae5dacbd97034404b762d7f6f6e1af" name="a9be1c6a7aba3d2c58133f9f2f10db45aa7dae5dacbd97034404b762d7f6f6e1af"></a>eNeutrinoMu&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aac1c88472c153a63ab704929618b8db94" name="a9be1c6a7aba3d2c58133f9f2f10db45aac1c88472c153a63ab704929618b8db94"></a>eNeutrinoTau&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa23ea58bf613804f599e55e53b2317512" name="a9be1c6a7aba3d2c58133f9f2f10db45aa23ea58bf613804f599e55e53b2317512"></a>eAntiNeutrinoE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aaf488ada9f417f7d9bebfbee0311e6723" name="a9be1c6a7aba3d2c58133f9f2f10db45aaf488ada9f417f7d9bebfbee0311e6723"></a>eAntiNeutrinoMu&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9be1c6a7aba3d2c58133f9f2f10db45aa08d9b0340d013b6b8a82c9b2ab1fbe5f" name="a9be1c6a7aba3d2c58133f9f2f10db45aa08d9b0340d013b6b8a82c9b2ab1fbe5f"></a>eAntiNeutrinoTau&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad71ecb37457c7761afe0fea9e203d05b" name="ad71ecb37457c7761afe0fea9e203d05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71ecb37457c7761afe0fea9e203d05b">&#9670;&#160;</a></span>PropagatorStage</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad71ecb37457c7761afe0fea9e203d05b">Acts::PropagatorStage</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Different stages during propagation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad71ecb37457c7761afe0fea9e203d05bafedb2d84cafe20862cb4399751a8a7e3" name="ad71ecb37457c7761afe0fea9e203d05bafedb2d84cafe20862cb4399751a8a7e3"></a>invalid&#160;</td><td class="fielddoc"><p>Invalid stage. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad71ecb37457c7761afe0fea9e203d05baefeca9e9053d4d39ed0a7b73b04d076a" name="ad71ecb37457c7761afe0fea9e203d05baefeca9e9053d4d39ed0a7b73b04d076a"></a>prePropagation&#160;</td><td class="fielddoc"><p>Before the propagation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad71ecb37457c7761afe0fea9e203d05ba3b5645e433f7f9bc6947d24d27d87ed7" name="ad71ecb37457c7761afe0fea9e203d05ba3b5645e433f7f9bc6947d24d27d87ed7"></a>postPropagation&#160;</td><td class="fielddoc"><p>After the propagation. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad71ecb37457c7761afe0fea9e203d05baac36043718849057413af081e5880a60" name="ad71ecb37457c7761afe0fea9e203d05baac36043718849057413af081e5880a60"></a>preStep&#160;</td><td class="fielddoc"><p>Before a step. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad71ecb37457c7761afe0fea9e203d05ba6611d3ea55ba2b9a3c8daeec0e77a35f" name="ad71ecb37457c7761afe0fea9e203d05ba6611d3ea55ba2b9a3c8daeec0e77a35f"></a>postStep&#160;</td><td class="fielddoc"><p>After a step. </p>
</td></tr>
</table>

</div>
</div>
<a id="a71eb0dc21ee83a011a86dbd801338057" name="a71eb0dc21ee83a011a86dbd801338057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eb0dc21ee83a011a86dbd801338057">&#9670;&#160;</a></span>SpacePointCandidateType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a71eb0dc21ee83a011a86dbd801338057">Acts::SpacePointCandidateType</a> : short</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of space point candidates for seeding. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a71eb0dc21ee83a011a86dbd801338057a776f50b8d2af1233e8900eb42f93adab" name="a71eb0dc21ee83a011a86dbd801338057a776f50b8d2af1233e8900eb42f93adab"></a>eBottom&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a71eb0dc21ee83a011a86dbd801338057ae64af3a3ced78854860e9eccf0322873" name="a71eb0dc21ee83a011a86dbd801338057ae64af3a3ced78854860e9eccf0322873"></a>eTop&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a7a6813a649567fb613b8214ad5e7399c" name="a7a6813a649567fb613b8214ad5e7399c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6813a649567fb613b8214ad5e7399c">&#9670;&#160;</a></span>SpacePointColumns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a7a6813a649567fb613b8214ad5e7399c">Acts::SpacePointColumns</a> : std::uint32_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca6adf97f83acf6453d4a6a4b1070f3754" name="a7a6813a649567fb613b8214ad5e7399ca6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No columns. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca3084fee3544f80ff6a40e639984e89f9" name="a7a6813a649567fb613b8214ad5e7399ca3084fee3544f80ff6a40e639984e89f9"></a>SourceLinks&#160;</td><td class="fielddoc"><p>Source link information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca02129bb861061d1a052c592e2dc6b383" name="a7a6813a649567fb613b8214ad5e7399ca02129bb861061d1a052c592e2dc6b383"></a>X&#160;</td><td class="fielddoc"><p>X coordinate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca57cec4137b614c87cb4e24a3d003a3e0" name="a7a6813a649567fb613b8214ad5e7399ca57cec4137b614c87cb4e24a3d003a3e0"></a>Y&#160;</td><td class="fielddoc"><p>Y coordinate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca21c2e59531c8710156d34a3c30ac81d5" name="a7a6813a649567fb613b8214ad5e7399ca21c2e59531c8710156d34a3c30ac81d5"></a>Z&#160;</td><td class="fielddoc"><p>Z coordinate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399cae1e1d3d40573127e9ee0480caf1283d6" name="a7a6813a649567fb613b8214ad5e7399cae1e1d3d40573127e9ee0480caf1283d6"></a>R&#160;</td><td class="fielddoc"><p>Radial coordinate. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca5a82bece4586ad7cb17ba739a2db7f67" name="a7a6813a649567fb613b8214ad5e7399ca5a82bece4586ad7cb17ba739a2db7f67"></a>Phi&#160;</td><td class="fielddoc"><p>Azimuthal angle. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399caa76d4ef5f3f6a672bbfab2865563e530" name="a7a6813a649567fb613b8214ad5e7399caa76d4ef5f3f6a672bbfab2865563e530"></a>Time&#160;</td><td class="fielddoc"><p>Time information. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca40d203bf0d98e07fc2dfbf12d880b13b" name="a7a6813a649567fb613b8214ad5e7399ca40d203bf0d98e07fc2dfbf12d880b13b"></a>VarianceZ&#160;</td><td class="fielddoc"><p>Variance in Z direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca72bb52f0a15dd8981987d49e5e306c31" name="a7a6813a649567fb613b8214ad5e7399ca72bb52f0a15dd8981987d49e5e306c31"></a>VarianceR&#160;</td><td class="fielddoc"><p>Variance in radial direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca3fa9ae8939cd9d4e3d80ba71a28ea27d" name="a7a6813a649567fb613b8214ad5e7399ca3fa9ae8939cd9d4e3d80ba71a28ea27d"></a>TopStripVector&#160;</td><td class="fielddoc"><p>Vector for the top strip. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca08e690ae1ee43bbbf2fd36c5f78e9b13" name="a7a6813a649567fb613b8214ad5e7399ca08e690ae1ee43bbbf2fd36c5f78e9b13"></a>BottomStripVector&#160;</td><td class="fielddoc"><p>Vector for the bottom strip. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca60970c94d2fa3ff8904f6ee13a88c506" name="a7a6813a649567fb613b8214ad5e7399ca60970c94d2fa3ff8904f6ee13a88c506"></a>StripCenterDistance&#160;</td><td class="fielddoc"><p>Distance to the strip center. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca3496d756018104f2c4ed750e892621d0" name="a7a6813a649567fb613b8214ad5e7399ca3496d756018104f2c4ed750e892621d0"></a>TopStripCenter&#160;</td><td class="fielddoc"><p>Center of the top strip. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399cab64faa7d3e7fdfda97f3cf4ebb2ccbe8" name="a7a6813a649567fb613b8214ad5e7399cab64faa7d3e7fdfda97f3cf4ebb2ccbe8"></a>CopyFromIndex&#160;</td><td class="fielddoc"><p>Copy from index. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca74c53bcd3dcb2bb79993b2fec37d362a" name="a7a6813a649567fb613b8214ad5e7399ca74c53bcd3dcb2bb79993b2fec37d362a"></a>XY&#160;</td><td class="fielddoc"><p>X and Y coordinates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca50390e75aac138ff69bd26a338e042a4" name="a7a6813a649567fb613b8214ad5e7399ca50390e75aac138ff69bd26a338e042a4"></a>ZR&#160;</td><td class="fielddoc"><p>Z and R coordinates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399cae65075d550f9b5bf9992fa1d71a131be" name="a7a6813a649567fb613b8214ad5e7399cae65075d550f9b5bf9992fa1d71a131be"></a>XYZ&#160;</td><td class="fielddoc"><p>X, Y, and Z coordinates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399cadcebc0530c8af8d1c3ba8511b85e17f9" name="a7a6813a649567fb613b8214ad5e7399cadcebc0530c8af8d1c3ba8511b85e17f9"></a>XYZR&#160;</td><td class="fielddoc"><p>X, Y, Z, and R coordinates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca3aaf7978eaca2bad55d906b6f6d57f37" name="a7a6813a649567fb613b8214ad5e7399ca3aaf7978eaca2bad55d906b6f6d57f37"></a>VarianceZR&#160;</td><td class="fielddoc"><p>Variance in Z and R directions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a6813a649567fb613b8214ad5e7399ca031b9e77f5c85a66723c832a06ba2735" name="a7a6813a649567fb613b8214ad5e7399ca031b9e77f5c85a66723c832a06ba2735"></a>Strip&#160;</td><td class="fielddoc"><p>All strip-related columns. </p>
</td></tr>
</table>

</div>
</div>
<a id="a086febf882ea487434374ef548a90661" name="a086febf882ea487434374ef548a90661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086febf882ea487434374ef548a90661">&#9670;&#160;</a></span>TrackExtrapolationStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a086febf882ea487434374ef548a90661">Acts::TrackExtrapolationStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strategy for track extrapolation to target surface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a086febf882ea487434374ef548a90661a8b04d5e3775d298e78455efc5ca404d5" name="a086febf882ea487434374ef548a90661a8b04d5e3775d298e78455efc5ca404d5"></a>first&#160;</td><td class="fielddoc"><p>Use the first track state to reach target surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="a086febf882ea487434374ef548a90661a98bd1c45684cf587ac2347a92dd7bb51" name="a086febf882ea487434374ef548a90661a98bd1c45684cf587ac2347a92dd7bb51"></a>last&#160;</td><td class="fielddoc"><p>Use the last track state to reach target surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="a086febf882ea487434374ef548a90661a6fc382933a0480bdfa5eb85b743e3018" name="a086febf882ea487434374ef548a90661a6fc382933a0480bdfa5eb85b743e3018"></a>firstOrLast&#160;</td><td class="fielddoc"><p>Use the first or last track state to reach target surface depending on the distance. </p>
</td></tr>
</table>

</div>
</div>
<a id="a4cc469694ff29fb3f7c7128ad09264a4" name="a4cc469694ff29fb3f7c7128ad09264a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc469694ff29fb3f7c7128ad09264a4">&#9670;&#160;</a></span>TrackStateFlag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a4cc469694ff29fb3f7c7128ad09264a4">Acts::TrackStateFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum describes the type of TrackState. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a61c2d35b2b78000035892533a0d84c1b" name="a4cc469694ff29fb3f7c7128ad09264a4a61c2d35b2b78000035892533a0d84c1b"></a>MeasurementFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a05c96f3f141ed07147a10e824053defe" name="a4cc469694ff29fb3f7c7128ad09264a4a05c96f3f141ed07147a10e824053defe"></a>ParameterFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a8ea62dde4ffd73859274aa60475ed51e" name="a4cc469694ff29fb3f7c7128ad09264a4a8ea62dde4ffd73859274aa60475ed51e"></a>OutlierFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a4b4d351fff1cc5c67b8bc0fb8b0fa68b" name="a4cc469694ff29fb3f7c7128ad09264a4a4b4d351fff1cc5c67b8bc0fb8b0fa68b"></a>HoleFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a12593f1e94d940cd98d868507e14bcaa" name="a4cc469694ff29fb3f7c7128ad09264a4a12593f1e94d940cd98d868507e14bcaa"></a>MaterialFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4af521a474f0c773060e30ea91d0d52524" name="a4cc469694ff29fb3f7c7128ad09264a4af521a474f0c773060e30ea91d0d52524"></a>SharedHitFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a7371bfebbf5ce839fbf93e44466b24ee" name="a4cc469694ff29fb3f7c7128ad09264a4a7371bfebbf5ce839fbf93e44466b24ee"></a>SplitHitFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a57fea0596d2e3beed9a65b9569fe9496" name="a4cc469694ff29fb3f7c7128ad09264a4a57fea0596d2e3beed9a65b9569fe9496"></a>NoExpectedHitFlag&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4cc469694ff29fb3f7c7128ad09264a4a22052cbf9db3a1ac37c9ed360acbc6ee" name="a4cc469694ff29fb3f7c7128ad09264a4a22052cbf9db3a1ac37c9ed360acbc6ee"></a>NumTrackStateFlags&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac57de10a165c0a56408fd3de93e013e2" name="ac57de10a165c0a56408fd3de93e013e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57de10a165c0a56408fd3de93e013e2">&#9670;&#160;</a></span>TrackStatePropMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum struct <a class="el" href="#ac57de10a165c0a56408fd3de93e013e2">Acts::TrackStatePropMask</a> : std::uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collection of bit masks to enable steering which components of a track state should be initialized, and which should be left invalid. </p>
<p>These mask values can be combined using binary operators, so (TrackStatePropMask::Predicted | TrackStatePropMask::Jacobian) will instruct allocating storage for both predicted parameters (including covariance) and a jacobian. The enum is used as a strong type wrapper around the bits to prevent autoconversion from integer </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2a6adf97f83acf6453d4a6a4b1070f3754" name="ac57de10a165c0a56408fd3de93e013e2a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2a015e111693f10da4f3fc32814a41e7ad" name="ac57de10a165c0a56408fd3de93e013e2a015e111693f10da4f3fc32814a41e7ad"></a>Predicted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2afe84ed3d6baffd193df85d308e5e908c" name="ac57de10a165c0a56408fd3de93e013e2afe84ed3d6baffd193df85d308e5e908c"></a>Filtered&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2ac5d48c613aa395e2f92d06e97b85aa97" name="ac57de10a165c0a56408fd3de93e013e2ac5d48c613aa395e2f92d06e97b85aa97"></a>Smoothed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2ae54aa0f510685bd0be4cbe3750fa7fc5" name="ac57de10a165c0a56408fd3de93e013e2ae54aa0f510685bd0be4cbe3750fa7fc5"></a>Jacobian&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2aa4002a60656b604f448b7794842c8fb4" name="ac57de10a165c0a56408fd3de93e013e2aa4002a60656b604f448b7794842c8fb4"></a>Calibrated&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680" name="ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a281bb3932c0b5a0fb38fdab58f043848" name="a281bb3932c0b5a0fb38fdab58f043848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281bb3932c0b5a0fb38fdab58f043848">&#9670;&#160;</a></span>VolumeAttachmentStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848">Acts::VolumeAttachmentStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The attachment strategy defines how the volumes are attached Attachment always happens pair-wise. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a281bb3932c0b5a0fb38fdab58f043848a7fb55ed0b7a30342ba6da306428cae04" name="a281bb3932c0b5a0fb38fdab58f043848a7fb55ed0b7a30342ba6da306428cae04"></a>First&#160;</td><td class="fielddoc"><p>Given two volumes, the <em>left</em> one, i.e. </p>
<p>the one with the lower <b>local</b> x, y, or z value is extended </p>
</td></tr>
<tr><td class="fieldname"><a id="a281bb3932c0b5a0fb38fdab58f043848ac22cf8376b1893dcfcef0649fe1a7d87" name="a281bb3932c0b5a0fb38fdab58f043848ac22cf8376b1893dcfcef0649fe1a7d87"></a>Second&#160;</td><td class="fielddoc"><p>Given two volumes, the <em>right</em> one, i.e. </p>
<p>the one with the higher <b>local</b> x, y, or z value is extended </p>
</td></tr>
<tr><td class="fieldname"><a id="a281bb3932c0b5a0fb38fdab58f043848a7f56c02b34d312867e3f63c9f21fe5c8" name="a281bb3932c0b5a0fb38fdab58f043848a7f56c02b34d312867e3f63c9f21fe5c8"></a>Midpoint&#160;</td><td class="fielddoc"><p>Given two volumes, the <em>midpoint</em> between the two volumes is found. </p>
</td></tr>
<tr><td class="fieldname"><a id="a281bb3932c0b5a0fb38fdab58f043848a466b98ca0f38bd8bf2260246c91f6882" name="a281bb3932c0b5a0fb38fdab58f043848a466b98ca0f38bd8bf2260246c91f6882"></a>Gap&#160;</td><td class="fielddoc"><p>A gap volume is created to fit between the two volumes. </p>
</td></tr>
</table>

</div>
</div>
<a id="a8e7b9ba567f3fce3fb39c1c9ce093e93" name="a8e7b9ba567f3fce3fb39c1c9ce093e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7b9ba567f3fce3fb39c1c9ce093e93">&#9670;&#160;</a></span>VolumeResizeStrategy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a8e7b9ba567f3fce3fb39c1c9ce093e93">Acts::VolumeResizeStrategy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The resize strategy defines how the volumes are resized. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8e7b9ba567f3fce3fb39c1c9ce093e93a8098b34f582537833b36b58273c3545b" name="a8e7b9ba567f3fce3fb39c1c9ce093e93a8098b34f582537833b36b58273c3545b"></a>Expand&#160;</td><td class="fielddoc"><p>Extend the volume connected to the respective edge to fit the new bounds. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8e7b9ba567f3fce3fb39c1c9ce093e93a466b98ca0f38bd8bf2260246c91f6882" name="a8e7b9ba567f3fce3fb39c1c9ce093e93a466b98ca0f38bd8bf2260246c91f6882"></a>Gap&#160;</td><td class="fielddoc"><p>Create a gap volume at the respective edge to fit the new bounds. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac067c47704bdb1b88dd0c21c0e8fd8c2" name="ac067c47704bdb1b88dd0c21c0e8fd8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac067c47704bdb1b88dd0c21c0e8fd8c2">&#9670;&#160;</a></span>WrappingCondition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ac067c47704bdb1b88dd0c21c0e8fd8c2">Acts::WrappingCondition</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Volume wrapping conditions for cylinder volume building. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2a343ba1ac75989650550b2f56e557113c" name="ac067c47704bdb1b88dd0c21c0e8fd8c2a343ba1ac75989650550b2f56e557113c"></a>Undefined&#160;</td><td class="fielddoc"><p>inconsistency detected </p>
</td></tr>
<tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2ac4b9fe4314b7cc00ea9953d6d2f1ec05" name="ac067c47704bdb1b88dd0c21c0e8fd8c2ac4b9fe4314b7cc00ea9953d6d2f1ec05"></a>Attaching&#160;</td><td class="fielddoc"><p>attach the volumes </p>
</td></tr>
<tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2a32e361fc46c1b1b2d1d4c4698c9337f0" name="ac067c47704bdb1b88dd0c21c0e8fd8c2a32e361fc46c1b1b2d1d4c4698c9337f0"></a>Inserting&#160;</td><td class="fielddoc"><p>insert the new volume </p>
</td></tr>
<tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2a650eda96ea9b43a530919bf0a5210d38" name="ac067c47704bdb1b88dd0c21c0e8fd8c2a650eda96ea9b43a530919bf0a5210d38"></a>Wrapping&#160;</td><td class="fielddoc"><p>wrap the new volume around </p>
</td></tr>
<tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2a5b7bdfc822b40c4f237c1d376172945a" name="ac067c47704bdb1b88dd0c21c0e8fd8c2a5b7bdfc822b40c4f237c1d376172945a"></a>CentralInserting&#160;</td><td class="fielddoc"><p>insert the new one into the center </p>
</td></tr>
<tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2acc7765cc3777a384b6a9a93f4cc140f8" name="ac067c47704bdb1b88dd0c21c0e8fd8c2acc7765cc3777a384b6a9a93f4cc140f8"></a>CentralWrapping&#160;</td><td class="fielddoc"><p>wrap the new central volume around </p>
</td></tr>
<tr><td class="fieldname"><a id="ac067c47704bdb1b88dd0c21c0e8fd8c2a8d9c18bc517435f25750e460525b60e7" name="ac067c47704bdb1b88dd0c21c0e8fd8c2a8d9c18bc517435f25750e460525b60e7"></a>NoWrapping&#160;</td><td class="fielddoc"><p>no inner volume present - no wrapping needed </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aee44b83052f88cd1f6fe38ad464439d0" name="aee44b83052f88cd1f6fe38ad464439d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee44b83052f88cd1f6fe38ad464439d0">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Acts::abs </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute of a number (Can be removed for c++ 23). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number to take absolute value of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute value of the input </dd></dl>

</div>
</div>
<a id="a07cc9c5a52b7ad024117cee0d1dd664f" name="a07cc9c5a52b7ad024117cee0d1dd664f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cc9c5a52b7ad024117cee0d1dd664f">&#9670;&#160;</a></span>ACTS_DEFINE_ENUM_BITWISE_OPERATORS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Acts::ACTS_DEFINE_ENUM_BITWISE_OPERATORS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7a6813a649567fb613b8214ad5e7399c">SpacePointColumns</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e485245a070df5a95f113e9ada82f40" name="a7e485245a070df5a95f113e9ada82f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e485245a070df5a95f113e9ada82f40">&#9670;&#160;</a></span>addBoundParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> Acts::addBoundParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add bound parameters and take care of angle periodicity for phi and theta. </p>
<p>This is intended for small differences only i.e. KF updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side bound parameters </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side bound parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the bound parameters </dd></dl>

</div>
</div>
<a id="ac693aa8941b4cbb04d9fda037650199a" name="ac693aa8941b4cbb04d9fda037650199a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac693aa8941b4cbb04d9fda037650199a">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_cuboid_volume_bounds.html">CuboidVolumeBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of cuboid volume bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">cBounds</td><td>the Cuboid volume bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="a29c8e88a9e25c5f72ee73239695a6e66" name="a29c8e88a9e25c5f72ee73239695a6e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c8e88a9e25c5f72ee73239695a6e66">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_cutout_cylinder_volume_bounds.html">CutoutCylinderVolumeBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of cutout cylinder volume bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">cBounds</td><td>the Cutout Cylinder volume bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="a00c1bda0e98b2e133600784dbb185048" name="a00c1bda0e98b2e133600784dbb185048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c1bda0e98b2e133600784dbb185048">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_cylinder_bounds.html">CylinderBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of cylinder bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">cBounds</td><td>the Cylinder bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="a15aee0a999a8184c1d937d20290661d4" name="a15aee0a999a8184c1d937d20290661d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aee0a999a8184c1d937d20290661d4">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_cylinder_volume_bounds.html">CylinderVolumeBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of cylinder volume bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">cBounds</td><td>the Cylinder volume bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="ac017c44f5305e61ef807eb2da620ba89" name="ac017c44f5305e61ef807eb2da620ba89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac017c44f5305e61ef807eb2da620ba89">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_radial_bounds.html">RadialBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of radial bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">rBounds</td><td>the Radial bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="a83a4f6fbbc917b45e62349df43858f83" name="a83a4f6fbbc917b45e62349df43858f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a4f6fbbc917b45e62349df43858f83">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_rectangle_bounds.html">RectangleBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of plane bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">pBounds</td><td>the Rectangle bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="af4d9c22f5aa9a180415576374f06da6e" name="af4d9c22f5aa9a180415576374f06da6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d9c22f5aa9a180415576374f06da6e">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to a surface </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">surface</td><td>Surface to which the adjustment is being done </td></tr>
    <tr><td class="paramname">gctx</td><td>Geometry context to get the surfaces transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="af203de69e977c5ee39b61a19a6118f34" name="af203de69e977c5ee39b61a19a6118f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af203de69e977c5ee39b61a19a6118f34">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_trapezoid_bounds.html">TrapezoidBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to the dimensions of plane bounds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">pBounds</td><td>the Trapezoid bounds to adjust to </td></tr>
    <tr><td class="paramname">transform</td><td>Transform for the adjusted <code>BinUtility</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="a03a1428acbabf53542cf3f5b41d3f35f" name="a03a1428acbabf53542cf3f5b41d3f35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a1428acbabf53542cf3f5b41d3f35f">&#9670;&#160;</a></span>adjustBinUtility() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> Acts::adjustBinUtility </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bu</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_volume.html">Volume</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adjust the BinUtility bu to a volume </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bu</td><td>BinUtility at source </td></tr>
    <tr><td class="paramname">volume</td><td>Volume to which the adjustment is being done</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new updated BinUtiltiy </dd></dl>

</div>
</div>
<a id="a307086a9afc40c3a9b019463924cb098" name="a307086a9afc40c3a9b019463924cb098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307086a9afc40c3a9b019463924cb098">&#9670;&#160;</a></span>allAxisDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> &gt; &amp; Acts::allAxisDirections </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all possible axis directions. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of all possible axis directions </dd></dl>

</div>
</div>
<a id="a64261b76df37073220040fe3fa8b1db9" name="a64261b76df37073220040fe3fa8b1db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64261b76df37073220040fe3fa8b1db9">&#9670;&#160;</a></span>AnyGridConstView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Axes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::AnyGridConstView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; T, Axes... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td>-&gt;AnyGridConstView&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for AnyGridConstView from const Grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of values stored in the grid </td></tr>
    <tr><td class="paramname">Axes</td><td>Parameter pack of axis types defining the grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The const grid to create a view for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaeded646732245db32f202c44527534" name="adaeded646732245db32f202c44527534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaeded646732245db32f202c44527534">&#9670;&#160;</a></span>AnyGridView()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Axes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::AnyGridView </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; T, Axes... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td>-&gt;AnyGridView&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for AnyGridView from Grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of values stored in the grid </td></tr>
    <tr><td class="paramname">Axes</td><td>Parameter pack of axis types defining the grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid to create a view for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af22a25edcd447beaf9fe79dcf98cd9e6" name="af22a25edcd447beaf9fe79dcf98cd9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22a25edcd447beaf9fe79dcf98cd9e6">&#9670;&#160;</a></span>applyReferenceExpansion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename grid_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::applyReferenceExpansion </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; typename grid_type::point_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gridQueries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>referenceExpansion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the reference expansion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">grid_type</td><td>the type of the grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gridQueries</td><td>the grid queries to be expanded </td></tr>
    <tr><td class="paramname">referenceExpansion</td><td>the reference expansion values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a692f3bf198b75679e1051ae422c41869" name="a692f3bf198b75679e1051ae422c41869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692f3bf198b75679e1051ae422c41869">&#9670;&#160;</a></span>approximateHighlandScattering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::approximateHighlandScattering </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>xOverX0</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Approximate the core width of the projected planar scattering distribution with highland's formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xOverX0</td><td>The thickness of the material in radiation lengths </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The approximate scattering angle times momentum in radians*GeV </dd></dl>

</div>
</div>
<a id="a1a37b45a601496b2b6a31387897c1e5a" name="a1a37b45a601496b2b6a31387897c1e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a37b45a601496b2b6a31387897c1e5a">&#9670;&#160;</a></span>Axis() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a> bdt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::Axis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt; bdt &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>bins</em></span>&#160;)-&gt;Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a>, bdt &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for equidistant axis with specified boundary type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum value </td></tr>
    <tr><td class="paramname">max</td><td>Maximum value </td></tr>
    <tr><td class="paramname">bins</td><td>Number of bins </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed5a20ef25d66a3e59792f2086fa2066" name="aed5a20ef25d66a3e59792f2086fa2066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a20ef25d66a3e59792f2086fa2066">&#9670;&#160;</a></span>Axis() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a> bdt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::Axis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt; bdt &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>bins</em></span>&#160;)-&gt;Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9">AxisType::Variable</a>, bdt &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for variable axis with specified boundary type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>Vector of bin edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76e099f71248cb4af56fa6535db4881a" name="a76e099f71248cb4af56fa6535db4881a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e099f71248cb4af56fa6535db4881a">&#9670;&#160;</a></span>Axis() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Axis </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>bins</em></span>&#160;)-&gt;Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a>, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">AxisBoundaryType::Open</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for equidistant axis with open boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum value </td></tr>
    <tr><td class="paramname">max</td><td>Maximum value </td></tr>
    <tr><td class="paramname">bins</td><td>Number of bins </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ddbbb068377c483f127deb5760fd10f" name="a6ddbbb068377c483f127deb5760fd10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddbbb068377c483f127deb5760fd10f">&#9670;&#160;</a></span>Axis() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Axis </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>bins</em></span></td><td>)</td>
          <td>-&gt;Axis&lt; <a class="el" href="#a2472b7e663ee623501edad0bbcd8a32fa47c14840d8e15331fa420b9b2f757cd9">AxisType::Variable</a>, <a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">AxisBoundaryType::Open</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for variable axis with open boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bins</td><td>Vector of bin edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64dfd29b7fe0b00e8ac549675044383e" name="a64dfd29b7fe0b00e8ac549675044383e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64dfd29b7fe0b00e8ac549675044383e">&#9670;&#160;</a></span>axisDirectionFromName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> Acts::axisDirectionFromName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an axis direction from its string name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>is the name of the axis direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the axis direction </dd></dl>

</div>
</div>
<a id="ade6d8e84befdfc830b445832d13cfad6" name="ade6d8e84befdfc830b445832d13cfad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6d8e84befdfc830b445832d13cfad6">&#9670;&#160;</a></span>axisDirectionName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Acts::axisDirectionName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a></td>          <td class="paramname"><span class="paramname"><em>aDir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of a binning value as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aDir</td><td>is the binning value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the binning value </dd></dl>

</div>
</div>
<a id="a2e79325890b007508379e03efeb37a97" name="a2e79325890b007508379e03efeb37a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e79325890b007508379e03efeb37a97">&#9670;&#160;</a></span>binomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Acts::binomial </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the binomial coefficient n n! </p>
<p>= -----&mdash; k k!(n-k)! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Upper value in binomial coefficient </td></tr>
    <tr><td class="paramname">k</td><td>Lower value in binomial coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Binomial coefficient n choose k </dd></dl>

</div>
</div>
<a id="a91dd49594c44c4f09d8f2bce66889672" name="a91dd49594c44c4f09d8f2bce66889672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dd49594c44c4f09d8f2bce66889672">&#9670;&#160;</a></span>binSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; Acts::binSequence </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::size_t, 2u &gt;</td>          <td class="paramname"><span class="paramname"><em>minMaxBins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>expand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>nBins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">Acts::AxisBoundaryType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to generate completely populated bin sequences that respect the boundary type of the axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minMaxBins</td><td>estimated bin range (aka binning boundary box) </td></tr>
    <tr><td class="paramname">expand</td><td>the parameter to expand the view (extra window) </td></tr>
    <tr><td class="paramname">nBins</td><td>the maximum number of bins on this axis </td></tr>
    <tr><td class="paramname">type</td><td>the boundary type of the axis (for correct bin closure)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>for closed binning a span over half the bins flips direction</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of bins to be filled </dd></dl>

</div>
</div>
<a id="a1faa0708be032bfc6c3a725525972191" name="a1faa0708be032bfc6c3a725525972191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faa0708be032bfc6c3a725525972191">&#9670;&#160;</a></span>bitsetToMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType Acts::bitsetToMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::bitset&lt; MatrixType::RowsAtCompileTime *MatrixType::ColsAtCompileTime &gt;</td>          <td class="paramname"><span class="paramname"><em>bs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a bitset to a matrix of integers, with each element set to the bit value. </p>
<dl class="section note"><dt>Note</dt><dd>How the bits are assigned to matrix elements depends on the storage type of the matrix being converted (row-major or col-major) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Matrix type that is produced </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bs</td><td>The bitset to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix with the integer values of the bits from <code class="param">bs</code> </dd></dl>

</div>
</div>
<a id="a37d4a4f8919f71e49c4136b1a5877125" name="a37d4a4f8919f71e49c4136b1a5877125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d4a4f8919f71e49c4136b1a5877125">&#9670;&#160;</a></span>blockedMult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A, typename B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; A::RowsAtCompileTime, B::ColsAtCompileTime &gt; Acts::blockedMult </td>
          <td>(</td>
          <td class="paramtype">const A &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a blocked matrix multiplication, avoiding Eigen GEMM methods. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The type of the first matrix, which should be MxN </td></tr>
    <tr><td class="paramname">B</td><td>The type of the second matrix, which should be NxP</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>An MxN matrix of type A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>An NxP matrix of type P</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product ab </dd></dl>

</div>
</div>
<a id="a73d5129d1a16a6e63564cdf881a9b647" name="a73d5129d1a16a6e63564cdf881a9b647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d5129d1a16a6e63564cdf881a9b647">&#9670;&#160;</a></span>calculateFilteredChi2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Acts::calculateFilteredChi2 </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the filtered chi2. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the chi2 from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chi2 </dd></dl>

</div>
</div>
<a id="a605d198d063b46f931c36b96948e3f7f" name="a605d198d063b46f931c36b96948e3f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605d198d063b46f931c36b96948e3f7f">&#9670;&#160;</a></span>calculateFilteredResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t nMeasurementDim, TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt; nMeasurementDim &gt;, <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt; nMeasurementDim &gt; &gt; Acts::calculateFilteredResidual </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the filtered residual and its covariance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nMeasurementDim</td><td>the dimension of the measurement </td></tr>
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the residual from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the residual and its covariance </dd></dl>

</div>
</div>
<a id="adf94b572ac2237a3112a156cfce109ab" name="adf94b572ac2237a3112a156cfce109ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf94b572ac2237a3112a156cfce109ab">&#9670;&#160;</a></span>calculateNucleusMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::calculateNucleusMass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the mass of a nucleus using Bethe-Weizsacker formula Parameters obtained from <a href="https://www.actaphys.uj.edu.pl/R/37/6/1833">https://www.actaphys.uj.edu.pl/R/37/6/1833</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number for the nucleus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mass in native units </dd></dl>

</div>
</div>
<a id="a56a5418f50fb82641b5616441d39dea1" name="a56a5418f50fb82641b5616441d39dea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56a5418f50fb82641b5616441d39dea1">&#9670;&#160;</a></span>calculatePredictedChi2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Acts::calculatePredictedChi2 </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the predicted chi2. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the chi2 from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chi2 </dd></dl>

</div>
</div>
<a id="a912468fb270d9bd53a076eda3ff91d52" name="a912468fb270d9bd53a076eda3ff91d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912468fb270d9bd53a076eda3ff91d52">&#9670;&#160;</a></span>calculatePredictedResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t nMeasurementDim, TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt; nMeasurementDim &gt;, <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt; nMeasurementDim &gt; &gt; Acts::calculatePredictedResidual </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the predicted residual and its covariance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nMeasurementDim</td><td>the dimension of the measurement </td></tr>
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the residual from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the residual and its covariance </dd></dl>

</div>
</div>
<a id="ad0961bb226a8e46e32d709866e7eed73" name="ad0961bb226a8e46e32d709866e7eed73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0961bb226a8e46e32d709866e7eed73">&#9670;&#160;</a></span>calculateSmoothedChi2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double Acts::calculateSmoothedChi2 </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the smoothed chi2. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the chi2 from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the chi2 </dd></dl>

</div>
</div>
<a id="a5a6a0f03dead89351e61bdd4d0d98dc1" name="a5a6a0f03dead89351e61bdd4d0d98dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6a0f03dead89351e61bdd4d0d98dc1">&#9670;&#160;</a></span>calculateSmoothedResidual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t nMeasurementDim, TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="group__algebra__types.html#ga3656dcbf643d97f9dbd715aa9e06bf84">ActsVector</a>&lt; nMeasurementDim &gt;, <a class="el" href="group__algebra__types.html#gacb25019f1218b9a96b29f897dfc5be7f">ActsSquareMatrix</a>&lt; nMeasurementDim &gt; &gt; Acts::calculateSmoothedResidual </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the smoothed residual and its covariance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nMeasurementDim</td><td>the dimension of the measurement </td></tr>
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the residual from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the residual and its covariance </dd></dl>

</div>
</div>
<a id="ad777051d7e6ab464315ae169472719fe" name="ad777051d7e6ab464315ae169472719fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad777051d7e6ab464315ae169472719fe">&#9670;&#160;</a></span>calculateTrackQuantities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::calculateTrackQuantities </td>
          <td>(</td>
          <td class="paramtype">track_proxy_t</td>          <td class="paramname"><span class="paramname"><em>track</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate a number of track level quantities and store them on the track itself. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>The track proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>A mutable track proxy to operate on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afded89f5410ca396ea21fee04cf8d1e2" name="afded89f5410ca396ea21fee04cf8d1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afded89f5410ca396ea21fee04cf8d1e2">&#9670;&#160;</a></span>calculateUnbiasedParametersCovariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackStateProxyConcept track_state_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a>, <a class="el" href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">BoundMatrix</a> &gt; Acts::calculateUnbiasedParametersCovariance </td>
          <td>(</td>
          <td class="paramtype">track_state_proxy_t</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to calculate the unbiased track parameters and their covariance (i.e. </p>
<p>fitted track parameters with this measurement removed) using Eq.(12a)-Eq.(12c) of NIMA 262, 444 (1987) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_state_proxy_t</td><td>the track state proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>the track state to calculate the unbiased parameters from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the unbiased parameters and their covariance </dd></dl>

</div>
</div>
<a id="adca167882d01bd6ed5541f83a36031e9" name="adca167882d01bd6ed5541f83a36031e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca167882d01bd6ed5541f83a36031e9">&#9670;&#160;</a></span>checkSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::sized_range index_range_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::checkSubspaceIndices </td>
          <td>(</td>
          <td class="paramtype">const index_range_t &amp;</td>          <td class="paramname"><span class="paramname"><em>indexRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>fullSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>subspaceSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check subspace indices for consistency. </p>
<p>Indices must be unique and within the full size of the subspace</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index_range_t</td><td>the type of the container of indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexRange</td><td>the range of indices </td></tr>
    <tr><td class="paramname">fullSize</td><td>the full size of the subspace </td></tr>
    <tr><td class="paramname">subspaceSize</td><td>the size of the subspace</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the indices are consistent </dd></dl>

</div>
</div>
<a id="a171b9272b990cb467e1e15f36638604e" name="a171b9272b990cb467e1e15f36638604e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171b9272b990cb467e1e15f36638604e">&#9670;&#160;</a></span>clampValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Acts::clampValue </td>
          <td>(</td>
          <td class="paramtype">U</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clamp a numeric value to another type, respecting range of the target type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the target type </td></tr>
    <tr><td class="paramname">U</td><td>the source type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to clamp </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the clamped value </dd></dl>

</div>
</div>
<a id="a7969e3bd01832c6be8de5ef2c3e070ef" name="a7969e3bd01832c6be8de5ef2c3e070ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7969e3bd01832c6be8de5ef2c3e070ef">&#9670;&#160;</a></span>computeEnergyLossBethe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossBethe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean energy loss due to ionisation and excitation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) through a material with the given properties, i.e. it computes </p><pre class="fragment">-dE(x) = -dE/dx * x
</pre><p>where -dE/dx is given by the Bethe formula. The computations are valid for intermediate particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Mean energy loss through the material slab </dd></dl>

</div>
</div>
<a id="aeb22670d2e2303ba2854c2169aa08608" name="aeb22670d2e2303ba2854c2169aa08608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb22670d2e2303ba2854c2169aa08608">&#9670;&#160;</a></span>computeEnergyLossLandau()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossLandau </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the most probable energy loss due to ionisation and excitation. </p>
<p>Compute the mean energy loss due to ionisation and excitation.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) through a material with the given properties, i.e. it computes </p><pre class="fragment">-dE(x) = -dE/dx * x
</pre><p>where -dE/dx is given by the Bethe formula. The computations are valid for intermediate particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Mean energy loss through the material slab   </dd></dl>
<p>This computes the most probable energy loss -dE(x) through a material of the given properties and thickness as described by the mode of the Landau-Vavilov-Bichsel distribution. The computations are valid for intermediate particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Most probable energy loss through the material slab </dd></dl>

</div>
</div>
<a id="aad4db30b6dc42d8043e312d4936ced86" name="aad4db30b6dc42d8043e312d4936ced86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4db30b6dc42d8043e312d4936ced86">&#9670;&#160;</a></span>computeEnergyLossLandauFwhm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossLandauFwhm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the full with half maximum of landau energy loss distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Full width half maximum of the Landau distribution </dd></dl>

</div>
</div>
<a id="a5e47e30202dec06addb9c315a0b7d674" name="a5e47e30202dec06addb9c315a0b7d674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e47e30202dec06addb9c315a0b7d674">&#9670;&#160;</a></span>computeEnergyLossLandauSigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossLandauSigma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Gaussian-equivalent sigma for the ionisation loss fluctuations. </p>
<dl class="section see"><dt>See also</dt><dd>computeEnergyLossBethe for parameters description</dd></dl>
<p>This is the sigma parameter of a Gaussian distribution with the same full-width-half-maximum as the Landau-Vavilov-Bichsel distribution. The computations are valid for intermediate particle energies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gaussian-equivalent sigma for energy loss fluctuations </dd></dl>

</div>
</div>
<a id="ae16ecda47ec9e373b988bb80f0bd7ef3" name="ae16ecda47ec9e373b988bb80f0bd7ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16ecda47ec9e373b988bb80f0bd7ef3">&#9670;&#160;</a></span>computeEnergyLossLandauSigmaQOverP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossLandauSigmaQOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute q/p Gaussian-equivalent sigma due to ionisation loss fluctuations. </p>
<p>Compute the mean energy loss due to ionisation and excitation.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) through a material with the given properties, i.e. it computes </p><pre class="fragment">-dE(x) = -dE/dx * x
</pre><p>where -dE/dx is given by the Bethe formula. The computations are valid for intermediate particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Mean energy loss through the material slab    </dd></dl>

</div>
</div>
<a id="a87160e91db5e1f254b03ea77a3e67775" name="a87160e91db5e1f254b03ea77a3e67775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87160e91db5e1f254b03ea77a3e67775">&#9670;&#160;</a></span>computeEnergyLossMean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossMean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the combined mean energy loss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the combined mean energy loss -dE(x) including ionisation and radiative effects. The computations are valid over a wide range of particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Combined mean energy loss through the material slab </dd></dl>

</div>
</div>
<a id="acece53e8206433adba38168d0458c746" name="acece53e8206433adba38168d0458c746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acece53e8206433adba38168d0458c746">&#9670;&#160;</a></span>computeEnergyLossMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the combined most probably energy loss. </p>
<p>Compute the combined mean energy loss.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the combined mean energy loss -dE(x) including ionisation and radiative effects. The computations are valid over a wide range of particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Combined mean energy loss through the material slab    </dd>
<dd>
Combined most probable energy loss through the material slab </dd></dl>

</div>
</div>
<a id="a2ecf42043a08060183625f40fdfb7d5f" name="a2ecf42043a08060183625f40fdfb7d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecf42043a08060183625f40fdfb7d5f">&#9670;&#160;</a></span>computeEnergyLossRadiative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeEnergyLossRadiative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean energy loss due to radiative effects at high energies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) using an approximative formula. Bremsstrahlung is always included; direct e+e- pair production and photo-nuclear interactions only for muons. </p><dl class="section return"><dt>Returns</dt><dd>Mean radiative energy loss through the material slab </dd></dl>

</div>
</div>
<a id="a3dabf99c3b7798ef4ea7ec13c13c5795" name="a3dabf99c3b7798ef4ea7ec13c13c5795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dabf99c3b7798ef4ea7ec13c13c5795">&#9670;&#160;</a></span>computeMultipleScatteringTheta0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::computeMultipleScatteringTheta0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the core width of the projected planar scattering distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Core width of the scattering distribution </dd></dl>

</div>
</div>
<a id="a52e4326c57b1b3eadc5a72d2c774bd7e" name="a52e4326c57b1b3eadc5a72d2c774bd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e4326c57b1b3eadc5a72d2c774bd7e">&#9670;&#160;</a></span>copySign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename out_t, typename sign_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">out_t Acts::copySign </td>
          <td>(</td>
          <td class="paramtype">const out_t &amp;</td>          <td class="paramname"><span class="paramname"><em>copyTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sign_t &amp;</td>          <td class="paramname"><span class="paramname"><em>sign</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the sign of a signed variable onto the copyTo input object Return type &amp; magnitude remain unaffected by this method which allows usage for Vectors &amp; other types providing the - operator. </p>
<p>By convention, the zero is assigned to a positive sign. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copyTo</td><td>Variable to which the sign is copied to. </td></tr>
    <tr><td class="paramname">sign</td><td>Variable from which the sign is taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81d1bed89a2a799ac23081b1d1d57a73" name="a81d1bed89a2a799ac23081b1d1d57a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d1bed89a2a799ac23081b1d1d57a73">&#9670;&#160;</a></span>createCurvilinearUnitU()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputVector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::createCurvilinearUnitU </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; InputVector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the first curvilinear unit vector <span class="tt">U</span> for the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>is the input direction vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a normalized vector in the x-y plane orthogonal to the direction.</dd></dl>
<p>The special case of the direction vector pointing along the z-axis is handled by forcing the unit vector to along the x-axis. </p>

</div>
</div>
<a id="aa9f86795ac3702abb070cdae0d706fef" name="aa9f86795ac3702abb070cdae0d706fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f86795ac3702abb070cdae0d706fef">&#9670;&#160;</a></span>createCurvilinearUnitVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputVector&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::createCurvilinearUnitVectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; InputVector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the curvilinear unit vectors <span class="tt">U</span> and <span class="tt">V</span> for the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>is the input direction vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normalized unit vectors <span class="tt">U</span> and <span class="tt">V</span> orthogonal to the direction.</dd></dl>
<p>With <span class="tt">T</span> the normalized input direction, the three vectors <span class="tt">U</span>, <span class="tt">V</span>, and <span class="tt">T</span> form an orthonormal basis set, i.e. they satisfy </p><pre class="fragment">U x V = T
V x T = U
T x U = V
</pre><p>with the additional condition that <span class="tt">U</span> is located in the global x-y plane. </p>

</div>
</div>
<a id="acc4fdbb4f35d269522bc19c0d224ec30" name="acc4fdbb4f35d269522bc19c0d224ec30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4fdbb4f35d269522bc19c0d224ec30">&#9670;&#160;</a></span>createGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a> Acts::createGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a></td>          <td class="paramname"><span class="paramname"><em>gridAxis1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a></td>          <td class="paramname"><span class="paramname"><em>gridAxis2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that creates the cache grid for the mapping. </p>
<p>This grid allows the collection of material at a the anchor points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gridAxis1</td><td>Axis data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gridAxis2</td><td>Axis data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data of the axes is given in the std::array as {minimum value, maximum value, number of bins}</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The grid </dd></dl>

</div>
</div>
<a id="a085dd4ac5023951306e2309b2605be92" name="a085dd4ac5023951306e2309b2605be92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085dd4ac5023951306e2309b2605be92">&#9670;&#160;</a></span>createGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a> Acts::createGrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a></td>          <td class="paramname"><span class="paramname"><em>gridAxis1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a></td>          <td class="paramname"><span class="paramname"><em>gridAxis2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae3b4d4995155fcbfd29d48adc9f73a0d">MaterialGridAxisData</a></td>          <td class="paramname"><span class="paramname"><em>gridAxis3</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method that creates the cache grid for the mapping. </p>
<p>This grid allows the collection of material at a the anchor points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gridAxis1</td><td>Axis data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gridAxis2</td><td>Axis data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gridAxis3</td><td>Axis data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The data of the axes is given in the std::array as {minimum value, maximum value, number of bins}</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The grid </dd></dl>

</div>
</div>
<a id="a2ab7a78eb37d8ad1adaeaf04d6d92c92" name="a2ab7a78eb37d8ad1adaeaf04d6d92c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab7a78eb37d8ad1adaeaf04d6d92c92">&#9670;&#160;</a></span>createGrid2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a> Acts::createGrid2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>(<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>transfoGlobalToLocal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 2DGrid using a BinUtility. </p>
<p>Also determine the corresponding global to local transform and grid mapping function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bins</td><td>BinUtility of the volume to be mapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transfoGlobalToLocal</td><td>Global to local transform to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3D grid </dd></dl>

</div>
</div>
<a id="ae92c97bfcfa43c9625c931928128a992" name="ae92c97bfcfa43c9625c931928128a992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92c97bfcfa43c9625c931928128a992">&#9670;&#160;</a></span>createGrid3D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a> Acts::createGrid3D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_bin_utility.html">BinUtility</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>(<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>transfoGlobalToLocal</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 3DGrid using a BinUtility. </p>
<p>Also determine the corresponding global to local transform and grid mapping function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bins</td><td>BinUtility of the volume to be mapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transfoGlobalToLocal</td><td>Global to local transform to be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the 3D grid </dd></dl>

</div>
</div>
<a id="ae9377cc8410b61e349e68a4f1d79772b" name="ae9377cc8410b61e349e68a4f1d79772b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9377cc8410b61e349e68a4f1d79772b">&#9670;&#160;</a></span>deriveEnergyLossBetheQOverP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::deriveEnergyLossBetheQOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of the Bethe energy loss with respect to q/p. </p>
<p>Compute the mean energy loss due to ionisation and excitation.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) through a material with the given properties, i.e. it computes </p><pre class="fragment">-dE(x) = -dE/dx * x
</pre><p>where -dE/dx is given by the Bethe formula. The computations are valid for intermediate particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Mean energy loss through the material slab    </dd></dl>

</div>
</div>
<a id="ac473b5a1771eb1bd84ad6e44cbde555c" name="ac473b5a1771eb1bd84ad6e44cbde555c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac473b5a1771eb1bd84ad6e44cbde555c">&#9670;&#160;</a></span>deriveEnergyLossLandauQOverP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::deriveEnergyLossLandauQOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of the most probable ionisation energy loss with respect to q/p. </p>
<p>Compute the mean energy loss due to ionisation and excitation.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) through a material with the given properties, i.e. it computes </p><pre class="fragment">-dE(x) = -dE/dx * x
</pre><p>where -dE/dx is given by the Bethe formula. The computations are valid for intermediate particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Mean energy loss through the material slab    </dd></dl>

</div>
</div>
<a id="a4b9c3ee258cd4e8b1cbdd3ef01f65bac" name="a4b9c3ee258cd4e8b1cbdd3ef01f65bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9c3ee258cd4e8b1cbdd3ef01f65bac">&#9670;&#160;</a></span>deriveEnergyLossMeanQOverP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::deriveEnergyLossMeanQOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of the combined mean energy loss with respect to q/p. </p>
<p>Compute the combined mean energy loss.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the combined mean energy loss -dE(x) including ionisation and radiative effects. The computations are valid over a wide range of particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Combined mean energy loss through the material slab    </dd>
<dd>
Derivative of combined mean energy loss with respect to q/p </dd></dl>

</div>
</div>
<a id="a3e4407067c869e4f7253adc947e05f4e" name="a3e4407067c869e4f7253adc947e05f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4407067c869e4f7253adc947e05f4e">&#9670;&#160;</a></span>deriveEnergyLossModeQOverP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::deriveEnergyLossModeQOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of the combined most probable energy loss with respect to q/p. </p>
<p>Compute the combined mean energy loss.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the combined mean energy loss -dE(x) including ionisation and radiative effects. The computations are valid over a wide range of particle energies. </p><dl class="section return"><dt>Returns</dt><dd>Combined mean energy loss through the material slab    </dd>
<dd>
Derivative of combined most probable energy loss with respect to q/p </dd></dl>

</div>
</div>
<a id="a4d85a7a0670ff1043ead2e43cbc9b132" name="a4d85a7a0670ff1043ead2e43cbc9b132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d85a7a0670ff1043ead2e43cbc9b132">&#9670;&#160;</a></span>deriveEnergyLossRadiativeQOverP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::deriveEnergyLossRadiativeQOverP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slab</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>absPdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>absQ</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derivative of the mean radiative energy loss with respect to q/p. </p>
<p>Compute the mean energy loss due to radiative effects at high energies.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slab</td><td>The traversed material and its properties </td></tr>
    <tr><td class="paramname">absPdg</td><td>Absolute particle type PDG identifier </td></tr>
    <tr><td class="paramname">m</td><td>Particle mass </td></tr>
    <tr><td class="paramname">qOverP</td><td>Particle charge divided by absolute momentum </td></tr>
    <tr><td class="paramname">absQ</td><td>Absolute particle charge</td></tr>
  </table>
  </dd>
</dl>
<p>This computes the mean energy loss -dE(x) using an approximative formula. Bremsstrahlung is always included; direct e+e- pair production and photo-nuclear interactions only for muons. </p><dl class="section return"><dt>Returns</dt><dd>Mean radiative energy loss through the material slab    </dd>
<dd>
Derivative of radiative energy loss with respect to q/p </dd></dl>

</div>
</div>
<a id="ae62184077e0f01971fe35cb00b8cb20c" name="ae62184077e0f01971fe35cb00b8cb20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62184077e0f01971fe35cb00b8cb20c">&#9670;&#160;</a></span>deserializeSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t FullSize&gt; <br />
requires (FullSize &lt;= 8)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; FullSize &gt; Acts::deserializeSubspaceIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ac7fe124c6f6fda8fa31781f93cbd36b8">SerializedSubspaceIndices</a></td>          <td class="paramname"><span class="paramname"><em>serialized</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize subspace indices from a single 64 bit integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FullSize</td><td>the full size of the subspace</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serialized</td><td>the serialized subspace indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the subspace indices </dd></dl>

</div>
</div>
<a id="a08a2ca0bdef285b222916dd7ecb30562" name="a08a2ca0bdef285b222916dd7ecb30562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a2ca0bdef285b222916dd7ecb30562">&#9670;&#160;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type, typename index_type = typename std::decay_t&lt;container_type&gt;::size_type, typename container_type_iter = decltype(std::begin(std::declval&lt;container_type&gt;())), typename = decltype(std::end(std::declval&lt;container_type&gt;()))&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::enumerate </td>
          <td>(</td>
          <td class="paramtype">container_type &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>iterable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper utility to allow indexed enumeration with structured binding. </p>
<p>Usage:</p>
<p>for (auto [ i, value ] = enumerate(container) ) { ... };</p>
<p>with 'container' any stl-like container </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterable</td><td>Container to enumerate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable wrapper with index and value pairs </dd></dl>

</div>
</div>
<a id="a41ce01de709daded7eca97fac1268093" name="a41ce01de709daded7eca97fac1268093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ce01de709daded7eca97fac1268093">&#9670;&#160;</a></span>estimateTrackParamCovariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a40a2ff0a11454e7af0dc0a4bcab7b1b0">BoundMatrix</a> Acts::estimateTrackParamCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_estimate_track_param_covariance_config.html">EstimateTrackParamCovarianceConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>hasTime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the covariance matrix of the given track parameters based on the provided configuration. </p>
<p>The assumption is that we can model the uncertainty of the track parameters as a diagonal matrix with the provided initial sigmas. The inflation factors are used to inflate the initial variances based on the provided configuration. The uncertainty of q/p is estimated based on the relative uncertainty of the q/pt and the theta uncertainty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>is the configuration for the estimation </td></tr>
    <tr><td class="paramname">params</td><td>is the track parameters </td></tr>
    <tr><td class="paramname">hasTime</td><td>is true if the track parameters have time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the covariance matrix of the track parameters </dd></dl>

</div>
</div>
<a id="a6993b7c73820f46cd3c74271787accb8" name="a6993b7c73820f46cd3c74271787accb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6993b7c73820f46cd3c74271787accb8">&#9670;&#160;</a></span>estimateTrackParamsFromSeed() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::range spacepoint_range_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &gt; Acts::estimateTrackParamsFromSeed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">spacepoint_range_t</td>          <td class="paramname"><span class="paramname"><em>spRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bField</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the full track parameters from three space points. </p>
<p>This method is based on the conformal map transformation. It estimates the full bound track parameters, i.e. (loc0, loc1, phi, theta, q/p, t) at the bottom space point. The bottom space is assumed to be the first element in the range defined by the iterators. It must lie on the surface provided for the representation of the bound track parameters. The magnetic field (which might be along any direction) is also necessary for the momentum estimation.</p>
<p>It resembles the method used in ATLAS for the track parameters estimated from seed, i.e. the function InDet::SiTrackMaker_xk::getAtaPlane here: <a href="https://acode-browser.usatlas.bnl.gov/lxr/source/athena/InnerGeometry/InDetRecTools/SiTrackMakerTool_xk/src/SiTrackMaker_xk.cxx">https://acode-browser.usatlas.bnl.gov/lxr/source/athena/InnerGeometry/InDetRecTools/SiTrackMakerTool_xk/src/SiTrackMaker_xk.cxx</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">spacepoint_iterator_t</td><td>The type of space point iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>is the geometry context </td></tr>
    <tr><td class="paramname">spRange</td><td>is the range of space points </td></tr>
    <tr><td class="paramname">surface</td><td>is the surface of the bottom space point. The estimated bound track parameters will be represented also at this surface </td></tr>
    <tr><td class="paramname">bField</td><td>is the magnetic field vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bound parameters </dd></dl>

</div>
</div>
<a id="af38513640e42e706177f3812515d1b62" name="af38513640e42e706177f3812515d1b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38513640e42e706177f3812515d1b62">&#9670;&#160;</a></span>estimateTrackParamsFromSeed() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> Acts::estimateTrackParamsFromSeed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sp0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sp1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>sp2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bField</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the full track parameters from three space points. </p>
<p>This method is based on the conformal map transformation. It estimates the full free track parameters, i.e. (x, y, z, t, dx, dy, dz, q/p) at the bottom space point. The bottom space is assumed to be the first element in the range defined by the iterators. The magnetic field (which might be along any direction) is also necessary for the momentum estimation.</p>
<p>This is a purely spatial estimation, i.e. the time parameter will be set to 0.</p>
<p>It resembles the method used in ATLAS for the track parameters estimated from seed, i.e. the function InDet::SiTrackMaker_xk::getAtaPlane here: <a href="https://acode-browser.usatlas.bnl.gov/lxr/source/athena/InnerGeometry/InDetRecTools/SiTrackMakerTool_xk/src/SiTrackMaker_xk.cxx">https://acode-browser.usatlas.bnl.gov/lxr/source/athena/InnerGeometry/InDetRecTools/SiTrackMakerTool_xk/src/SiTrackMaker_xk.cxx</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">spacepoint_iterator_t</td><td>The type of space point iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sp0</td><td>is the bottom space point </td></tr>
    <tr><td class="paramname">sp1</td><td>is the middle space point </td></tr>
    <tr><td class="paramname">sp2</td><td>is the top space point </td></tr>
    <tr><td class="paramname">bField</td><td>is the magnetic field vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the free parameters </dd></dl>

</div>
</div>
<a id="a57fee6bb48f063dd49269e39bfdc36fc" name="a57fee6bb48f063dd49269e39bfdc36fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fee6bb48f063dd49269e39bfdc36fc">&#9670;&#160;</a></span>estimateTrackParamsFromSeed() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::range spacepoint_range_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> Acts::estimateTrackParamsFromSeed </td>
          <td>(</td>
          <td class="paramtype">spacepoint_range_t</td>          <td class="paramname"><span class="paramname"><em>spRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bField</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate the full track parameters from three space points. </p>
<p>This method is based on the conformal map transformation. It estimates the full free track parameters, i.e. (x, y, z, t, dx, dy, dz, q/p) at the bottom space point. The bottom space is assumed to be the first element in the range defined by the iterators. The magnetic field (which might be along any direction) is also necessary for the momentum estimation.</p>
<p>It resembles the method used in ATLAS for the track parameters estimated from seed, i.e. the function InDet::SiTrackMaker_xk::getAtaPlane here: <a href="https://acode-browser.usatlas.bnl.gov/lxr/source/athena/InnerGeometry/InDetRecTools/SiTrackMakerTool_xk/src/SiTrackMaker_xk.cxx">https://acode-browser.usatlas.bnl.gov/lxr/source/athena/InnerGeometry/InDetRecTools/SiTrackMakerTool_xk/src/SiTrackMaker_xk.cxx</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">spacepoint_iterator_t</td><td>The type of space point iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spRange</td><td>is the range of space points </td></tr>
    <tr><td class="paramname">bField</td><td>is the magnetic field vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the free parameters </dd></dl>

</div>
</div>
<a id="a10e8cfcddde31768275e024c61f03a70" name="a10e8cfcddde31768275e024c61f03a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e8cfcddde31768275e024c61f03a70">&#9670;&#160;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename queries_type, typename expansion_type, std::size_t kDIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::expand </td>
          <td>(</td>
          <td class="paramtype">queries_type &amp;</td>          <td class="paramname"><span class="paramname"><em>gridQueries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const expansion_type &amp;</td>          <td class="paramname"><span class="paramname"><em>referenceExpansion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to expand the grid queries along a given dimension. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">queries_type</td><td>the type of the grid queries </td></tr>
    <tr><td class="paramname">expansion_type</td><td>the type of the reference expansion </td></tr>
    <tr><td class="paramname">kDIM</td><td>the dimension to be expanded </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gridQueries</td><td>the grid queries to be expanded </td></tr>
    <tr><td class="paramname">referenceExpansion</td><td>the reference expansion values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a850ecde5129afaabb5d4a8e71499f6cc" name="a850ecde5129afaabb5d4a8e71499f6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850ecde5129afaabb5d4a8e71499f6cc">&#9670;&#160;</a></span>extractNucleusZandA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::pair&lt; std::int32_t, std::int32_t &gt; Acts::extractNucleusZandA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract Z and A for a given nucleus. </p>
<p>PDG number of a nucleus has a form 10LZZZAAAI, where L is number of lambdas, ZZZ is proton number, AAA is atomic number, I is isomer level. See PDG section "Monte Carlo Particle
Numbering Scheme" , point 16: <a href="https://pdg.lbl.gov/2025/reviews/rpp2024-rev-monte-carlo-numbering.pdf">https://pdg.lbl.gov/2025/reviews/rpp2024-rev-monte-carlo-numbering.pdf</a> </p>

</div>
</div>
<a id="a853dda101669b4f6ffbe29119b1a9ef6" name="a853dda101669b4f6ffbe29119b1a9ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853dda101669b4f6ffbe29119b1a9ef6">&#9670;&#160;</a></span>extrapolateTracksToReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackContainerFrontend track_container_t, typename propagator_t, typename propagator_options_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt; Acts::extrapolateTracksToReferenceSurface </td>
          <td>(</td>
          <td class="paramtype">const track_container_t &amp;</td>          <td class="paramname"><span class="paramname"><em>trackContainer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>referenceSurface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const propagator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>propagator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">propagator_options_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval">*<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackExtrapolation&quot;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrapolate tracks to a reference surface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_container_t</td><td>The track container type </td></tr>
    <tr><td class="paramname">propagator_t</td><td>The propagator type </td></tr>
    <tr><td class="paramname">propagator_options_t</td><td>The propagator options type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackContainer</td><td>The track container which is modified in-place </td></tr>
    <tr><td class="paramname">referenceSurface</td><td>The reference surface </td></tr>
    <tr><td class="paramname">propagator</td><td>The propagator </td></tr>
    <tr><td class="paramname">options</td><td>The propagator options </td></tr>
    <tr><td class="paramname">strategy</td><td>The extrapolation strategy </td></tr>
    <tr><td class="paramname">logger</td><td>The logger</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the extrapolation </dd></dl>

</div>
</div>
<a id="a1c35547ca44e69f20691e806cb8483ae" name="a1c35547ca44e69f20691e806cb8483ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c35547ca44e69f20691e806cb8483ae">&#9670;&#160;</a></span>extrapolateTrackToReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t, typename propagator_t, typename propagator_options_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt; Acts::extrapolateTrackToReferenceSurface </td>
          <td>(</td>
          <td class="paramtype">track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>track</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>referenceSurface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const propagator_t &amp;</td>          <td class="paramname"><span class="paramname"><em>propagator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">propagator_options_t</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval">*<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackExtrapolation&quot;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrapolate a track to a reference surface. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>The track proxy type </td></tr>
    <tr><td class="paramname">propagator_t</td><td>The propagator type </td></tr>
    <tr><td class="paramname">propagator_options_t</td><td>The propagator options type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>The track which is modified in-place </td></tr>
    <tr><td class="paramname">referenceSurface</td><td>The reference surface </td></tr>
    <tr><td class="paramname">propagator</td><td>The propagator </td></tr>
    <tr><td class="paramname">options</td><td>The propagator options </td></tr>
    <tr><td class="paramname">strategy</td><td>The extrapolation strategy </td></tr>
    <tr><td class="paramname">logger</td><td>The logger</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the extrapolation </dd></dl>

</div>
</div>
<a id="a8b715ad8da501aa71d4507ec991513fd" name="a8b715ad8da501aa71d4507ec991513fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b715ad8da501aa71d4507ec991513fd">&#9670;&#160;</a></span>factorial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Acts::factorial </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>upperN</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>lowerN</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the factorial of a number N!= N*(N-1).... </p>
<p>*3*2*1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperN</td><td>Upper factor until which the factorial is calculated </td></tr>
    <tr><td class="paramname">lowerN</td><td>Optional argument to remove the first factors from the calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Factorial result </dd></dl>

</div>
</div>
<a id="a370de2c1bb43783346d4a3cbc749dcd3" name="a370de2c1bb43783346d4a3cbc749dcd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370de2c1bb43783346d4a3cbc749dcd3">&#9670;&#160;</a></span>fastHypot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::fastHypot </td>
          <td>(</td>
          <td class="paramtype">T...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast hypotenuse calculation for multiple arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Variable number of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Square root of sum of squares of arguments </dd></dl>

</div>
</div>
<a id="a77ed58950d2c88dfa04891d7042b426a" name="a77ed58950d2c88dfa04891d7042b426a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ed58950d2c88dfa04891d7042b426a">&#9670;&#160;</a></span>filledArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; Acts::filledArray </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>defVal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates an array of type T and size N and assigns all elements to the parsed default value def_val. </p>
<p>This basically allows for inline construction and initialization of class-member arrays </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defVal</td><td>Default value to assign </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array filled with the default value </dd></dl>

</div>
</div>
<a id="a26795186fae91337f5ed8b8efd8982c8" name="a26795186fae91337f5ed8b8efd8982c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26795186fae91337f5ed8b8efd8982c8">&#9670;&#160;</a></span>findCharge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; float &gt; Acts::findCharge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the charge for a given PDG particle number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Charge in native units. </dd></dl>

</div>
</div>
<a id="a0b4b2bd9d2e161992542b8891fcb91aa" name="a0b4b2bd9d2e161992542b8891fcb91aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4b2bd9d2e161992542b8891fcb91aa">&#9670;&#160;</a></span>findChargeOfNucleus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::findChargeOfNucleus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the charge for a given PDG particle number of a nucleus. </p>
<p>Try its ground state first, and ultimately get the proton number from PDG </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number for the nucleus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Charge in native units. </dd></dl>

</div>
</div>
<a id="ab0dc64ed36049abdab55dfafdf61d90e" name="ab0dc64ed36049abdab55dfafdf61d90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dc64ed36049abdab55dfafdf61d90e">&#9670;&#160;</a></span>findFirstMeasurementState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; typename track_proxy_t::ConstTrackStateProxy &gt; Acts::findFirstMeasurementState </td>
          <td>(</td>
          <td class="paramtype">const track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>track</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first measurement state in a track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>The track to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result containing the first measurement state proxy or error </dd></dl>

</div>
</div>
<a id="ada531561958bfb2398084547ae4ba9e4" name="ada531561958bfb2398084547ae4ba9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada531561958bfb2398084547ae4ba9e4">&#9670;&#160;</a></span>findLastMeasurementState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; typename track_proxy_t::ConstTrackStateProxy &gt; Acts::findLastMeasurementState </td>
          <td>(</td>
          <td class="paramtype">const track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>track</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the last measurement state in a track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>The track to search </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result containing the last measurement state proxy or error </dd></dl>

</div>
</div>
<a id="a1e76fb289b5f40ef6755435b0e9b1b36" name="a1e76fb289b5f40ef6755435b0e9b1b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e76fb289b5f40ef6755435b0e9b1b36">&#9670;&#160;</a></span>findMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; float &gt; Acts::findMass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the mass for a given PDG particle number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mass in native units. </dd></dl>

</div>
</div>
<a id="a96b3521103bdac2bf34db07669ced6e2" name="a96b3521103bdac2bf34db07669ced6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b3521103bdac2bf34db07669ced6e2">&#9670;&#160;</a></span>findMassOfNucleus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::findMassOfNucleus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the mass for a given PDG particle number of a nucleus. </p>
<p>Try its ground state first, and ultimately get the mass from Bethe-Weizsacker formula </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number for the nucleus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mass in native units </dd></dl>

</div>
</div>
<a id="aecf1b9be1abb1cb9b8232068c20429d5" name="aecf1b9be1abb1cb9b8232068c20429d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf1b9be1abb1cb9b8232068c20429d5">&#9670;&#160;</a></span>findName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string_view &gt; Acts::findName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a descriptive particle name for a given PDG particle number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Particle name. </dd></dl>

</div>
</div>
<a id="a43da7d1f3b7a50be47d07cd91ad00ac8" name="a43da7d1f3b7a50be47d07cd91ad00ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43da7d1f3b7a50be47d07cd91ad00ac8">&#9670;&#160;</a></span>findNameOfNucleus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string_view &gt; Acts::findNameOfNucleus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a descriptive particle name for a given PDG particle number of a nucleus. </p>
<p>Try to get the name from its ground state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number for the nucleus </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Particle name. </dd></dl>

</div>
</div>
<a id="a02e2191d2c123c5d7394238aa560e8d3" name="a02e2191d2c123c5d7394238aa560e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e2191d2c123c5d7394238aa560e8d3">&#9670;&#160;</a></span>findParticleData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="struct_acts_1_1_particle_data.html">ParticleData</a> &gt; Acts::findParticleData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all known particle data for a given PDG particle number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Particle data if found </dd></dl>

</div>
</div>
<a id="abcb3220aecf93487a5ec2e1a23a1b625" name="abcb3220aecf93487a5ec2e1a23a1b625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb3220aecf93487a5ec2e1a23a1b625">&#9670;&#160;</a></span>findTrackStateForExtrapolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; std::pair&lt; typename track_proxy_t::ConstTrackStateProxy, double &gt; &gt; Acts::findTrackStateForExtrapolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geoContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>track</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>referenceSurface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a086febf882ea487434374ef548a90661">TrackExtrapolationStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval">*<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackExtrapolation&quot;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a track state for extrapolation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>The track proxy type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geoContext</td><td>The geometry context </td></tr>
    <tr><td class="paramname">track</td><td>The track </td></tr>
    <tr><td class="paramname">referenceSurface</td><td>The reference surface </td></tr>
    <tr><td class="paramname">strategy</td><td>The extrapolation strategy </td></tr>
    <tr><td class="paramname">logger</td><td>The logger</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the search containing the track state and the distance to the reference surface </dd></dl>

</div>
</div>
<a id="a76da3358e590b2f7561bce0ed3bc3a41" name="a76da3358e590b2f7561bce0ed3bc3a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76da3358e590b2f7561bce0ed3bc3a41">&#9670;&#160;</a></span>freeToSphericalDirectionJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; 2, 3 &gt; Acts::freeToSphericalDirectionJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Jacobian for free to spherical direction vector transformation. </p>
<dl class="section note"><dt>Note</dt><dd>We use the direction vector as an input because the trigonometric simplify that way</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The normalised direction vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Jacobian d(phi, theta) / d(dir_x, dir_y, dir_z) </dd></dl>

</div>
</div>
<a id="a9b4dee934b0b193d57604b19bc8cd527" name="a9b4dee934b0b193d57604b19bc8cd527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4dee934b0b193d57604b19bc8cd527">&#9670;&#160;</a></span>getDefaultLogger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &gt; Acts::getDefaultLogger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__logging.html#ga9b12dd924a4bd3aed921a33779ece95b">Logging::Level</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lvl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *</td>          <td class="paramname"><span class="paramname"><em>log_stream</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&amp;std::cout</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get default debug output logger </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the logger instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lvl</td><td>debug threshold level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log_stream</td><td>output stream used for printing debug messages</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns a pointer to a Logger instance with the following decorations enabled:</p><ul>
<li>time stamps</li>
<li>name of logging instance</li>
<li>debug level</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>pointer to logging instance </dd></dl>

</div>
</div>
<a id="ac3958b2d3af64792cac019893486c394" name="ac3958b2d3af64792cac019893486c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3958b2d3af64792cac019893486c394">&#9670;&#160;</a></span>getDummyLogger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp; Acts::getDummyLogger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a dummy logger that discards all output. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to dummy logger instance </dd></dl>

</div>
</div>
<a id="a4415f5f0dacad71be15d93860d45750e" name="a4415f5f0dacad71be15d93860d45750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4415f5f0dacad71be15d93860d45750e">&#9670;&#160;</a></span>globalToLocalFromBin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; double(<a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>)&gt; Acts::globalToLocalFromBin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a function that return the coordinate corresponding to type of bin </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of bin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a coordinate transform function </dd></dl>

</div>
</div>
<a id="a6e446526e27c813da589b5e2bc1a874c" name="a6e446526e27c813da589b5e2bc1a874c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e446526e27c813da589b5e2bc1a874c">&#9670;&#160;</a></span>Grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class... Axes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Axes &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>axes</em></span>&#160;)-&gt;Grid&lt; T, Axes... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for Grid with rvalue reference axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>Variable number of axes (rvalue references) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cc4853c5dcc7f0be2b4dc28a7e7cf38" name="a7cc4853c5dcc7f0be2b4dc28a7e7cf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc4853c5dcc7f0be2b4dc28a7e7cf38">&#9670;&#160;</a></span>Grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class... Axes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a>&lt; T &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Axes &amp;...</td>          <td class="paramname"><span class="paramname"><em>axes</em></span>&#160;)-&gt;Grid&lt; T, Axes... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for Grid with lvalue reference axes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">axes</td><td>Variable number of axes (lvalue references) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a323367bcdfc61666350ef9c85a96033f" name="a323367bcdfc61666350ef9c85a96033f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323367bcdfc61666350ef9c85a96033f">&#9670;&#160;</a></span>GridGlobalIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class... Axes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::GridGlobalIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; T, Axes... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)-&gt;GridGlobalIterator&lt; T, Axes... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for GridGlobalIterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Grid to iterate over </td></tr>
    <tr><td class="paramname">idx</td><td>Starting index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a312705c7759168e892ece2b486788dcc" name="a312705c7759168e892ece2b486788dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312705c7759168e892ece2b486788dcc">&#9670;&#160;</a></span>hashString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> Acts::hashString </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel consteval">consteval</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile-time hash of string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String view to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hashed string representation </dd></dl>

</div>
</div>
<a id="a04217815a63aceaf6ab6d5b64a057cbe" name="a04217815a63aceaf6ab6d5b64a057cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04217815a63aceaf6ab6d5b64a057cbe">&#9670;&#160;</a></span>hashStringDynamic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> Acts::hashStringDynamic </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runtime hash of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>String view to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hashed string representation </dd></dl>

</div>
</div>
<a id="ad30a4e8469eb16297c0ab87d5cf68209" name="ad30a4e8469eb16297c0ab87d5cf68209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30a4e8469eb16297c0ab87d5cf68209">&#9670;&#160;</a></span>hypotSquare()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::hypotSquare </td>
          <td>(</td>
          <td class="paramtype">T...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sum of squares of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Variable number of arguments to square and sum </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of squares of all arguments </dd></dl>

</div>
</div>
<a id="a3caf69a4c80cf869115afbab91cd8163" name="a3caf69a4c80cf869115afbab91cd8163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caf69a4c80cf869115afbab91cd8163">&#9670;&#160;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t N, class Point1, class Point2 = Point1, class Point3 = Point2&gt; <br />
requires (Concepts::interpolatable&lt;T, Point1, Point2, Point3&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">T Acts::interpolate </td>
          <td>(</td>
          <td class="paramtype">const Point1 &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point2 &amp;</td>          <td class="paramname"><span class="paramname"><em>lowerCorner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3 &amp;</td>          <td class="paramname"><span class="paramname"><em>upperCorner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs linear interpolation inside a hyper box </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of values to be interpolated </td></tr>
    <tr><td class="paramname">N</td><td>number of hyper box corners </td></tr>
    <tr><td class="paramname">Point1</td><td>type specifying geometric positions </td></tr>
    <tr><td class="paramname">Point2</td><td>type specifying geometric positions </td></tr>
    <tr><td class="paramname">Point3</td><td>type specifying geometric positions</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>position to which to interpolate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lowerCorner</td><td>generalized lower-left corner of hyper box (containing the minima of the hyper box along each dimension) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upperCorner</td><td>generalized upper-right corner of hyper box (containing the maxima of the hyper box along each dimension) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>field values at the hyper box corners sorted in the canonical order defined below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>interpolated value at given position</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>position</code> must describe a position inside the given hyper box, that is  \(\text{lowerCorner}[i] \le \text{position}[i] \le
     \text{upperCorner}[i] \quad \forall i=0, \dots, d-1\).</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Given <code>U</code> and <code>V</code> of value type <code>T</code> as well as two <code>double</code> <code>a</code> and <code>b</code>, then the following must be a valid expression <span class="tt">a * U + b * V</span> yielding an object which is (implicitly) convertible to <code>T</code>.</li>
<li>All <code>Point</code> types must represent d-dimensional positions and support coordinate access using <code>operator</code>[] which should return a <code>double</code> (or a value which is implicitly convertible). Coordinate indices must start at 0.</li>
<li><code>N</code> is the number of hyper box corners which is \(2^d\) where \(d\) is the dimensionality of the hyper box. The dimensionality must be consistent with the provided <code>Point</code> types.</li>
<li>Definition of the canonical order for sorting the field values: The hyper box corners are numbered according to the following scheme. Each corner is defined by the set of lower/upper boundary limits in each dimension <code>i</code>. This can be represented by a binary code (from left to right) where a <code>0</code> stands for a lower bound along this axis and a <code>1</code> stand for the upper bound along this axis. The left most bit corresponds to the first dimension and the bits to the left correspond to the 2nd, 3rd... dimension. The binary code can be interpreted as integer which gives the number of the corresponding hyper box corner. The field values are ordered according to ascending hyper box corner numbers.<br  />
 As an example assume we have a 3D box with <code>lowerCorner</code> = (1,2,3) and <code>upperCorner</code> = (4,5,6). The eight corners with their bit patterns and corner numbers are:<ul>
<li>(1,2,3): 000 = 0</li>
<li>(1,2,6): 001 = 1</li>
<li>(1,5,3): 010 = 2</li>
<li>(1,5,6): 011 = 3</li>
<li>(4,2,3): 100 = 4</li>
<li>(4,2,6): 101 = 5</li>
<li>(4,5,3): 110 = 6</li>
<li>(4,5,6): 111 = 7 </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="a94a8f9b03ea4540ab29e8d70330fa7f0" name="a94a8f9b03ea4540ab29e8d70330fa7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a8f9b03ea4540ab29e8d70330fa7f0">&#9670;&#160;</a></span>isBoundVectorValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::isBoundVectorValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>validateAngleRange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxAbsEta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;double&#160;&gt;::infinity()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a bound vector is valid. </p>
<p>This checks the following:</p><ul>
<li>All values are finite</li>
<li>(optionally) The phi value is in the range [-pi, pi)</li>
<li>(optionally) The theta value is in the range [0, pi]</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The bound vector to check </td></tr>
    <tr><td class="paramname">validateAngleRange</td><td>If true, the phi and theta values are range checked </td></tr>
    <tr><td class="paramname">epsilon</td><td>The epsilon to use for the checks </td></tr>
    <tr><td class="paramname">maxAbsEta</td><td>The maximum allowed eta value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the bound vector is valid </dd></dl>

</div>
</div>
<a id="abe77e44cea219bce9c03f8b2344bebaa" name="abe77e44cea219bce9c03f8b2344bebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe77e44cea219bce9c03f8b2344bebaa">&#9670;&#160;</a></span>isFreeVectorValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::isFreeVectorValid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>epsilon</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-6</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxAbsEta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;&#160;double&#160;&gt;::infinity()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a free vector is valid. </p>
<p>This checks the following:</p><ul>
<li>All values are finite</li>
<li>Direction is normalized</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The free vector to check </td></tr>
    <tr><td class="paramname">epsilon</td><td>The epsilon to use for the checks </td></tr>
    <tr><td class="paramname">maxAbsEta</td><td>The maximum allowed eta value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the free vector is valid </dd></dl>

</div>
</div>
<a id="a0dad26c0de75201a5b5d1fe7ce6c88e3" name="a0dad26c0de75201a5b5d1fe7ce6c88e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dad26c0de75201a5b5d1fe7ce6c88e3">&#9670;&#160;</a></span>isNucleus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool Acts::isNucleus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the PDG belongs to a nucleus, i.e. </p>
<p>if it has 10 digits. See PDG section "Monte Carlo Particle Numbering Scheme", point 16: <a href="https://pdg.lbl.gov/2025/reviews/rpp2024-rev-monte-carlo-numbering.pdf">https://pdg.lbl.gov/2025/reviews/rpp2024-rev-monte-carlo-numbering.pdf</a> </p>

</div>
</div>
<a id="aac11e8ec3784f7325583119c7b36bb06" name="aac11e8ec3784f7325583119c7b36bb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac11e8ec3784f7325583119c7b36bb06">&#9670;&#160;</a></span>joinStrings() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::range R&gt; <br />
requires std::convertible_to&lt;std::ranges::range_value_t&lt;R&gt;, std::string_view&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::joinStrings </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>strings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utuility to join a range of strings with a delimiter. </p>
<p>Accepts any range of elements convertible to <span class="tt">std::string_view</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strings</td><td>Range of strings to join </td></tr>
    <tr><td class="paramname">delimiter</td><td>Delimiter to insert between elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Joined string </dd></dl>

</div>
</div>
<a id="a1d589f70433525252ee4e7a5c412ac44" name="a1d589f70433525252ee4e7a5c412ac44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d589f70433525252ee4e7a5c412ac44">&#9670;&#160;</a></span>joinStrings() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::range R&gt; <br />
requires ( detail::formattable&lt;std::ranges::range_value_t&lt;R&gt;, char&gt; &amp;&amp; !std::convertible_to&lt;std::ranges::range_value_t&lt;R&gt;, std::string_view&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::joinStrings </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to join a range of formattable elements with a delimiter. </p>
<dl class="section note"><dt>Note</dt><dd>This overload is selected if the range values are not directly convertible to <span class="tt">std::string view</span>, and need to be default-formatted first. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Range of values to join </td></tr>
    <tr><td class="paramname">delimiter</td><td>Delimiter to insert between elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Joined string </dd></dl>

</div>
</div>
<a id="addbd41a294e15a0ec2b8c05ef65a6552" name="addbd41a294e15a0ec2b8c05ef65a6552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbd41a294e15a0ec2b8c05ef65a6552">&#9670;&#160;</a></span>joinStrings() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::ranges::range R&gt; <br />
requires detail::formattable&lt;std::ranges::range_value_t&lt;R&gt;, char&gt;</div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::joinStrings </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::format_string&lt; const std::ranges::range_value_t&lt; R &gt; &amp; &gt;</td>          <td class="paramname"><span class="paramname"><em>format</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to join a range of formattable elements with a delimiter and custom format string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Range of values to join </td></tr>
    <tr><td class="paramname">delimiter</td><td>Delimiter to insert between elements </td></tr>
    <tr><td class="paramname">format</td><td>Format string to apply to each element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Joined string </dd></dl>

</div>
</div>
<a id="af0aae08c33000aa753f3f047c0258722" name="af0aae08c33000aa753f3f047c0258722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0aae08c33000aa753f3f047c0258722">&#9670;&#160;</a></span>localIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename grid_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; typename grid_type::index_t &gt; Acts::localIndices </td>
          <td>(</td>
          <td class="paramtype">const grid_type &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename grid_type::point_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>queries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expansion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to fill local bins given a set of query points bin in between the extra points are filled, and a possible expansion of the bin window can be chosen. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">grid_type</td><td>the type of the grid that determines locall binning</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the grid used for this </td></tr>
    <tr><td class="paramname">queries</td><td>the grid positions for the bin queries </td></tr>
    <tr><td class="paramname">expansion</td><td>are the additional (configured) number of bins to expand the view</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a set of unique indices </dd></dl>

</div>
</div>
<a id="a76fa69095a6c107291628ba01d426ddb" name="a76fa69095a6c107291628ba01d426ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fa69095a6c107291628ba01d426ddb">&#9670;&#160;</a></span>make_error_code() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga5708898bc604b9dfedc12319218b8c1b">Acts::CombinatorialKalmanFilterError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from <a class="el" href="group__errors.html#ga5708898bc604b9dfedc12319218b8c1b">CombinatorialKalmanFilterError</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a190c3b5e3ff20dbd35833e207d4f62c1" name="a190c3b5e3ff20dbd35833e207d4f62c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a190c3b5e3ff20dbd35833e207d4f62c1">&#9670;&#160;</a></span>make_error_code() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#gac3f65a46059b0f9516370f5bdcb9bddd">Acts::KalmanFitterError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from <a class="el" href="group__errors.html#gac3f65a46059b0f9516370f5bdcb9bddd">KalmanFitterError</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a25f5d4485b7a41d484c83c920e320f12" name="a25f5d4485b7a41d484c83c920e320f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f5d4485b7a41d484c83c920e320f12">&#9670;&#160;</a></span>make_error_code() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#gaf2646ee646a0b70b9c7ebe6e7f473629">Acts::MultiStepperError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from MultiStepperError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="ace837699dafcfe04fb90daf56bc45e0c" name="ace837699dafcfe04fb90daf56bc45e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace837699dafcfe04fb90daf56bc45e0c">&#9670;&#160;</a></span>make_error_code() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga2cc876d4889b5c6656ed7d5e0c1fca19">Acts::NavigatorError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from NavigatorError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a3326d9e357aef12edb2f49a4ea8bae95" name="a3326d9e357aef12edb2f49a4ea8bae95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3326d9e357aef12edb2f49a4ea8bae95">&#9670;&#160;</a></span>make_error_code() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#gad9ea430c0897aa29fcaccb4fa68aa459">Acts::PortalError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from PortalError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a59c48d818496d25601d010382d0a0949" name="a59c48d818496d25601d010382d0a0949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c48d818496d25601d010382d0a0949">&#9670;&#160;</a></span>make_error_code() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#gae4af8513760690d2518f3e01355beb88">Acts::PropagatorError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from PropagatorError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a4b8e2b066fa956db4b2b5ff5d3bb49cb" name="a4b8e2b066fa956db4b2b5ff5d3bb49cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8e2b066fa956db4b2b5ff5d3bb49cb">&#9670;&#160;</a></span>make_error_code() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#gac32894235c42ab9d5e6bf5c5cd1f6f3d">Acts::SurfaceError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from SurfaceError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="aa38979d17928758be33bb3b9bbe7471c" name="aa38979d17928758be33bb3b9bbe7471c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38979d17928758be33bb3b9bbe7471c">&#9670;&#160;</a></span>make_error_code() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga1f61f3856fa7ffded6d06723801cf8e6">Acts::VertexingError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from VertexingError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="aa056d6844123e85684dfa0a1b8e54ddd" name="aa056d6844123e85684dfa0a1b8e54ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa056d6844123e85684dfa0a1b8e54ddd">&#9670;&#160;</a></span>make_error_code() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga21cb0f3d4dc02db3af0291385e70d4e0">EigenStepperError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from EigenStepperError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a4a880fdaf6088e3efa05b6c61fab3874" name="a4a880fdaf6088e3efa05b6c61fab3874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a880fdaf6088e3efa05b6c61fab3874">&#9670;&#160;</a></span>make_error_code() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga83f8b59ffc557631bb7fdd01c18431ca">GsfError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from <a class="el" href="group__errors.html#ga83f8b59ffc557631bb7fdd01c18431ca">GsfError</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="a011628b4fe22e244f04ee152403c6d5f" name="a011628b4fe22e244f04ee152403c6d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011628b4fe22e244f04ee152403c6d5f">&#9670;&#160;</a></span>make_error_code() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga15d42dcaa6c43d68f6d711f04f9594bd">SpacePointFormationError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from SpacePointFormationError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="aa5667ec3badff6cf983c82c9c9ba533e" name="aa5667ec3badff6cf983c82c9c9ba533e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5667ec3badff6cf983c82c9c9ba533e">&#9670;&#160;</a></span>make_error_code() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::error_code Acts::make_error_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__errors.html#ga6a0e61fbedc5e6713e2830a03af01032">TrackExtrapolationError</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create error code from TrackExtrapolationError. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The error code enum value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code </dd></dl>

</div>
</div>
<a id="ab709b73059672dac9c8b63ae942d10bf" name="ab709b73059672dac9c8b63ae942d10bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab709b73059672dac9c8b63ae942d10bf">&#9670;&#160;</a></span>make_octree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename box_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">box_t * Acts::make_octree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; box_t &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>store</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; box_t * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>prims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>max_depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename box_t::value_type</td>          <td class="paramname"><span class="paramname"><em>envelope1</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an octree from a list of bounding boxes. </p>
<dl class="section note"><dt>Note</dt><dd><code class="param">store</code> and <code class="param">prims</code> do not need to contain the same objects. <code class="param">store</code> is only used to pass ownership back to the caller while preserving memory location. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">box_t</td><td>Works will all box types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>Owns the created boxes by means of <span class="tt">std::unique_ptr</span>. </td></tr>
    <tr><td class="paramname">prims</td><td>Boxes to store. This is a read only vector. </td></tr>
    <tr><td class="paramname">max_depth</td><td>No subdivisions beyond this level. </td></tr>
    <tr><td class="paramname">envelope1</td><td>Envelope to add/subtract to dimensions in all directions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the top most bounding box, containing the entire octree </dd></dl>

</div>
</div>
<a id="ad340f3a8c5e2c06a6912b8537aa08fb4" name="ad340f3a8c5e2c06a6912b8537aa08fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad340f3a8c5e2c06a6912b8537aa08fb4">&#9670;&#160;</a></span>makeAbsolutePdgParticle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> Acts::makeAbsolutePdgParticle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an anti-particle to its particle and leave particles as-is. </p>

</div>
</div>
<a id="a6273d1f24a492d8ff55bed5c32f3a77f" name="a6273d1f24a492d8ff55bed5c32f3a77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6273d1f24a492d8ff55bed5c32f3a77f">&#9670;&#160;</a></span>makeDirectionFromAxisTangents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, 3, 1 &gt; Acts::makeDirectionFromAxisTangents </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>tanAlpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>tanBeta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a normalized direction vector from the tangents of the x-axis to the z-axis and of the y-axis to the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tanAlpha</td><td>Tangent of the x-axis to the z-axis </td></tr>
    <tr><td class="paramname">tanBeta</td><td>Tangent of the y-axis to the z-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A normalized 3D direction vector constructed from the axis tangents </dd></dl>

</div>
</div>
<a id="a6a9928559b584e711a83869d56fe1bdb" name="a6a9928559b584e711a83869d56fe1bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9928559b584e711a83869d56fe1bdb">&#9670;&#160;</a></span>makeDirectionFromPhiEta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, 3, 1 &gt; Acts::makeDirectionFromPhiEta </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>phi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>eta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a normalized direction vector from phi angle and pseudorapidity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>is the direction angle in the x-y plane. </td></tr>
    <tr><td class="paramname">eta</td><td>is the pseudorapidity towards the z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A normalized 3D direction vector constructed from phi and eta</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The input arguments intentionally use the same template type so that a compile error occurs if inconsistent input types are used. Avoids unexpected implicit type conversions and forces the user to explicitly cast mismatched input types. </dd></dl>

</div>
</div>
<a id="a47bd4093e0a9133ee5ea107a3bf55f59" name="a47bd4093e0a9133ee5ea107a3bf55f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bd4093e0a9133ee5ea107a3bf55f59">&#9670;&#160;</a></span>makeDirectionFromPhiTheta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, 3, 1 &gt; Acts::makeDirectionFromPhiTheta </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>phi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a normalized direction vector from phi and theta angle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>is the direction angle in radian in the x-y plane. </td></tr>
    <tr><td class="paramname">theta</td><td>is the polar angle in radian towards the z-axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A normalized 3D direction vector constructed from phi and theta</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The input arguments intentionally use the same template type so that a compile error occurs if inconsistent input types are used. Avoids unexpected implicit type conversions and forces the user to explicitly cast mismatched input types. </dd></dl>

</div>
</div>
<a id="a40b3a30a8131177dae1e7d5c6bf8b5e0" name="a40b3a30a8131177dae1e7d5c6bf8b5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b3a30a8131177dae1e7d5c6bf8b5e0">&#9670;&#160;</a></span>makeGrid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename payload_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_acts_1_1_i_grid.html">IGrid</a> &gt; Acts::makeGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to create a 1D grid from a single proto axis. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">payload_t</td><td>the grid payloat type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the proto axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an IGrid unique ptr and hence transfers ownership </dd></dl>

</div>
</div>
<a id="a424d9f0cd5324b8c7aa9b7d108626772" name="a424d9f0cd5324b8c7aa9b7d108626772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424d9f0cd5324b8c7aa9b7d108626772">&#9670;&#160;</a></span>makeGrid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename payload_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_acts_1_1_i_grid.html">IGrid</a> &gt; Acts::makeGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to create a 2D grid from a two proto axes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">payload_t</td><td>the grid payloat type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first proto axis </td></tr>
    <tr><td class="paramname">b</td><td>the second proto axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an IGrid unique ptr and hence transfers ownership </dd></dl>

</div>
</div>
<a id="aba9e1010998ed0a39553174f81cc6c3c" name="aba9e1010998ed0a39553174f81cc6c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9e1010998ed0a39553174f81cc6c3c">&#9670;&#160;</a></span>makeNucleusGroundState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> Acts::makeNucleusGroundState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an excited nucleus to its ground state. </p>
<p>PDG number of a nucleus has a form 10LZZZAAAI, where I is isomer level; I=0 is the ground state. See PDG section "Monte Carlo Particle Numbering Scheme", point 16: <a href="https://pdg.lbl.gov/2025/reviews/rpp2024-rev-monte-carlo-numbering.pdf">https://pdg.lbl.gov/2025/reviews/rpp2024-rev-monte-carlo-numbering.pdf</a> </p>

</div>
</div>
<a id="aa43f78ba3fcf4f16c256f1b3ac56f90b" name="aa43f78ba3fcf4f16c256f1b3ac56f90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43f78ba3fcf4f16c256f1b3ac56f90b">&#9670;&#160;</a></span>makePhiThetaFromDirection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; T, 2, 1 &gt; Acts::makePhiThetaFromDirection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unitDir</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a phi and theta angle from a direction vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unitDir</td><td>3D vector indicating a direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D vector containing phi and theta angles [phi, theta] </dd></dl>

</div>
</div>
<a id="a129628bceba57d023385eb65dc145ad0" name="a129628bceba57d023385eb65dc145ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129628bceba57d023385eb65dc145ad0">&#9670;&#160;</a></span>mapMaterialPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6bacc83149ffd31c3d1c02297b63a884">MaterialGrid2D</a> Acts::mapMaterialPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab0989576baab7a8793e3f7cbeec08cae">Grid2D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average the material collected in a 2D grid and use it to create a 2D material grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The material collecting grid coordinate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average material grid decomposed into classification numbers </dd></dl>

</div>
</div>
<a id="ad0936c1a6d966edd3d54a30ed376a45c" name="ad0936c1a6d966edd3d54a30ed376a45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0936c1a6d966edd3d54a30ed376a45c">&#9670;&#160;</a></span>mapMaterialPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae34013557b3d2c0ee081ec4b1c408b38">MaterialGrid3D</a> Acts::mapMaterialPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9449d6ac28ec406ddfcf71fd50003e59">Grid3D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Average the material collected in a 3D grid and use it to create a 3D material grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">grid</td><td>The material collecting grid coordinate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The average material grid decomposed into classification numbers </dd></dl>

</div>
</div>
<a id="a3dcc6435e936f830c8ce3e2c67122fd5" name="a3dcc6435e936f830c8ce3e2c67122fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcc6435e936f830c8ce3e2c67122fd5">&#9670;&#160;</a></span>matrixToBitset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::matrixToBitset </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an integer matrix to a bitset. </p>
<dl class="section note"><dt>Note</dt><dd>How the bits are ordered depends on the storage type of the matrix being converted (row-major or col-major) </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Eigen base concrete type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Matrix that is converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted bitset. </dd></dl>

</div>
</div>
<a id="a52e4174147933a017fd8663abf8ae740" name="a52e4174147933a017fd8663abf8ae740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e4174147933a017fd8663abf8ae740">&#9670;&#160;</a></span>normalizeBoundParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> Acts::normalizeBoundParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundParams</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize the bound parameter angles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundParams</td><td>The bound parameters to normalize</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normalized bound parameters </dd></dl>

</div>
</div>
<a id="a297fc9345930e9e61a5771aad5dc17c5" name="a297fc9345930e9e61a5771aad5dc17c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297fc9345930e9e61a5771aad5dc17c5">&#9670;&#160;</a></span>numAxisDirections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Acts::numAxisDirections </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of axis directions. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of axis directions </dd></dl>

</div>
</div>
<a id="a19fedc5d26afa78af1bca76bf2b8e62a" name="a19fedc5d26afa78af1bca76bf2b8e62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fedc5d26afa78af1bca76bf2b8e62a">&#9670;&#160;</a></span>operator*() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> Acts::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply Vector3 with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Vector3 to multiply </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed Vector3 result </dd></dl>

</div>
</div>
<a id="a42d92c82b2ff4bb3e507c65bb8ee1a7c" name="a42d92c82b2ff4bb3e507c65bb8ee1a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d92c82b2ff4bb3e507c65bb8ee1a7c">&#9670;&#160;</a></span>operator*() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> Acts::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply Direction with Vector3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
    <tr><td class="paramname">value</td><td>Vector3 to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed Vector3 result </dd></dl>

</div>
</div>
<a id="ab363071b4a31676e883a3b3902c21199" name="ab363071b4a31676e883a3b3902c21199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab363071b4a31676e883a3b3902c21199">&#9670;&#160;</a></span>operator*() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Acts::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply Direction with double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
    <tr><td class="paramname">value</td><td>Double to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed double result </dd></dl>

</div>
</div>
<a id="adf66c1a2997754ef9b2446b08b0e11d7" name="adf66c1a2997754ef9b2446b08b0e11d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf66c1a2997754ef9b2446b08b0e11d7">&#9670;&#160;</a></span>operator*() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply Direction with float. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
    <tr><td class="paramname">value</td><td>Float to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed float result </dd></dl>

</div>
</div>
<a id="a75e0f8b70f2049a83af6fcefd0f8093e" name="a75e0f8b70f2049a83af6fcefd0f8093e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e0f8b70f2049a83af6fcefd0f8093e">&#9670;&#160;</a></span>operator*() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Acts::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply Direction with integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
    <tr><td class="paramname">value</td><td>Integer to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed integer result </dd></dl>

</div>
</div>
<a id="aa914c08281fc46ac3d7df031f44e4264" name="aa914c08281fc46ac3d7df031f44e4264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa914c08281fc46ac3d7df031f44e4264">&#9670;&#160;</a></span>operator*() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Acts::operator* </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply double with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Double to multiply </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed double result </dd></dl>

</div>
</div>
<a id="a250fdefc5104f8449c2eb60b11400520" name="a250fdefc5104f8449c2eb60b11400520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250fdefc5104f8449c2eb60b11400520">&#9670;&#160;</a></span>operator*() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::operator* </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply float with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Float to multiply </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed float result </dd></dl>

</div>
</div>
<a id="ae700061586be6ebb696cd0a611741071" name="ae700061586be6ebb696cd0a611741071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae700061586be6ebb696cd0a611741071">&#9670;&#160;</a></span>operator*() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Acts::operator* </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply integer with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer to multiply </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed integer result </dd></dl>

</div>
</div>
<a id="abbc8ef8ab345e51b0bec867deb598869" name="abbc8ef8ab345e51b0bec867deb598869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc8ef8ab345e51b0bec867deb598869">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp; Acts::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply-assign Vector3 with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Vector3 reference to modify </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to modified Vector3 </dd></dl>

</div>
</div>
<a id="a0e2b412bc101d9c5e703c26d9a7802c8" name="a0e2b412bc101d9c5e703c26d9a7802c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2b412bc101d9c5e703c26d9a7802c8">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Acts::operator*= </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-assign double with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Double reference to modify </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to modified double </dd></dl>

</div>
</div>
<a id="a09b6ea68a647128b85d554b381fd4c77" name="a09b6ea68a647128b85d554b381fd4c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6ea68a647128b85d554b381fd4c77">&#9670;&#160;</a></span>operator*=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::operator*= </td>
          <td>(</td>
          <td class="paramtype">float &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-assign float with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Float reference to modify </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to modified float </dd></dl>

</div>
</div>
<a id="a61cc9ce9d77ed191d22251f2fd7af429" name="a61cc9ce9d77ed191d22251f2fd7af429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cc9ce9d77ed191d22251f2fd7af429">&#9670;&#160;</a></span>operator*=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Acts::operator*= </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply-assign integer with Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Integer reference to modify </td></tr>
    <tr><td class="paramname">dir</td><td>Direction value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to modified integer </dd></dl>

</div>
</div>
<a id="a8c289cbcb6bb87a3a4e60b4e968eb225" name="a8c289cbcb6bb87a3a4e60b4e968eb225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c289cbcb6bb87a3a4e60b4e968eb225">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7">AxisBoundaryType</a></td>          <td class="paramname"><span class="paramname"><em>bdt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for AxisBoundaryType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">bdt</td><td>AxisBoundaryType to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a28ea8e56599eede759a6ae23bcc4af04" name="a28ea8e56599eede759a6ae23bcc4af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ea8e56599eede759a6ae23bcc4af04">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a1462738699cb376ae92c59811987f4ea">AxisDirection</a></td>          <td class="paramname"><span class="paramname"><em>aDir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream operator for <code>AxisDirection</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>is the output stream </td></tr>
    <tr><td class="paramname">aDir</td><td>is the axis direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output stream </dd></dl>

</div>
</div>
<a id="aeedb8d78036b12103c3764910ef88e4c" name="aeedb8d78036b12103c3764910ef88e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedb8d78036b12103c3764910ef88e4c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2472b7e663ee623501edad0bbcd8a32f">AxisType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for AxisType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">type</td><td>AxisType to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a606b394839619dca8056f6ca7f7a9cd9" name="a606b394839619dca8056f6ca7f7a9cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606b394839619dca8056f6ca7f7a9cd9">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a324b54b2d52fbc9244d94e305d9203d3">BoundarySurfaceFace</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>face</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for BoundarySurfaceFace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">face</td><td>BoundarySurfaceFace to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="ad091d6f5ca02eacdd0ecbbb216893287" name="ad091d6f5ca02eacdd0ecbbb216893287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad091d6f5ca02eacdd0ecbbb216893287">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[5/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U, std::size_t V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_axis_aligned_bounding_box.html">AxisAlignedBoundingBox</a>&lt; T, U, V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the &lt;&lt; operator for bounding boxes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>entity type </td></tr>
    <tr><td class="paramname">U</td><td>value type </td></tr>
    <tr><td class="paramname">V</td><td>dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">box</td><td>The bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The given output stream. </dd></dl>

</div>
</div>
<a id="aff2f246860b0974632cebefff000f4ae" name="aff2f246860b0974632cebefff000f4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff2f246860b0974632cebefff000f4ae">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[6/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_constrained_step.html">ConstrainedStep</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>step</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for ConstrainedStep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">step</td><td>ConstrainedStep to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a9e78e7ac990dd63dd3acaa80bdb0eb57" name="a9e78e7ac990dd63dd3acaa80bdb0eb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e78e7ac990dd63dd3acaa80bdb0eb57">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[7/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_i_visualization3_d.html">IVisualization3D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hlp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for IVisualization3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">hlp</td><td>The helper instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="aa12edcaa0d2e0855219568de3447b8f0" name="aa12edcaa0d2e0855219568de3447b8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12edcaa0d2e0855219568de3447b8f0">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[8/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material.html">Material</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>material</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for Material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">material</td><td>Material to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a6892e054d938002cb1cc681d19619ad5" name="a6892e054d938002cb1cc681d19619ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6892e054d938002cb1cc681d19619ad5">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[9/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_material_slab.html">MaterialSlab</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>materialSlab</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for MaterialSlab. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">materialSlab</td><td>MaterialSlab to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="ad07b2ff48a82de9bd465cbcdacc066a1" name="ad07b2ff48a82de9bd465cbcdacc066a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07b2ff48a82de9bd465cbcdacc066a1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[10/32]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_ray.html">Ray</a>&lt; T, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ray</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the outstream operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The out stream </td></tr>
    <tr><td class="paramname">ray</td><td>The ray to write to <code class="param">os</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The outstream given in <code class="param">os</code> </dd></dl>

</div>
</div>
<a id="a143a8d24731524bb6cd89f6cd3891442" name="a143a8d24731524bb6cd89f6cd3891442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143a8d24731524bb6cd89f6cd3891442">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[11/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_acts_1_1_directed_proto_axis.html">DirectedProtoAxis</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for vector of DirectedProtoAxis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">a</td><td>Vector of DirectedProtoAxis to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a27d200860531f17827d06e26264b903d" name="a27d200860531f17827d06e26264b903d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d200860531f17827d06e26264b903d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[12/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_acts_1_1_proto_axis.html">ProtoAxis</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for vector of ProtoAxis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">a</td><td>Vector of ProtoAxis to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a8dd997fcf86fcd3b1dad24e355dc76ad" name="a8dd997fcf86fcd3b1dad24e355dc76ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd997fcf86fcd3b1dad24e355dc76ad">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[13/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_track_selector_1_1_config.html">TrackSelector::Config</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cuts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">cuts</td><td>Cuts to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream </dd></dl>

</div>
</div>
<a id="ae3082f2d05cfd560ec1fdbea0910f489" name="ae3082f2d05cfd560ec1fdbea0910f489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3082f2d05cfd560ec1fdbea0910f489">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[14/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_track_selector_1_1_eta_binned_config.html">TrackSelector::EtaBinnedConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cfg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">cfg</td><td>Configuration to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream </dd></dl>

</div>
</div>
<a id="a9611b708f395b658bf7b6dcc5d003726" name="a9611b708f395b658bf7b6dcc5d003726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9611b708f395b658bf7b6dcc5d003726">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[15/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_cuboid_volume_bounds.html#acbc4cbe27928efcbf0da00457ad799ac">CuboidPortalShell::Face</a></td>          <td class="paramname"><span class="paramname"><em>face</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream operator for the CuboidPortalShell::Face enum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">face</td><td>The face to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a065f7ca1306c553e4f48716204acdb6d" name="a065f7ca1306c553e4f48716204acdb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065f7ca1306c553e4f48716204acdb6d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[16/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_cylinder_volume_bounds.html#a51216b38aa994bf843ad58377b046a02">CylinderPortalShell::Face</a></td>          <td class="paramname"><span class="paramname"><em>face</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream operator for the CylinderPortalShell::Face enum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">face</td><td>The face to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a4b1f32495595f4b13b24c9acecabadaf" name="a4b1f32495595f4b13b24c9acecabadaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1f32495595f4b13b24c9acecabadaf">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[17/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_diamond_volume_bounds.html#a159c5f1828479b1fd03304934c214b41">DiamondPortalShell::Face</a></td>          <td class="paramname"><span class="paramname"><em>face</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">face</td><td>The face to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a10610de7dd2a36c1945fa5bc214cbbd1" name="a10610de7dd2a36c1945fa5bc214cbbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10610de7dd2a36c1945fa5bc214cbbd1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[18/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_direction.html">Direction</a></td>          <td class="paramname"><span class="paramname"><em>dir</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for Direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">dir</td><td>Direction to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a7b065972c1a1757a5262be3fa4ed9e13" name="a7b065972c1a1757a5262be3fa4ed9e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b065972c1a1757a5262be3fa4ed9e13">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[19/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for GeometryIdentifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">id</td><td>GeometryIdentifier to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a33de5ebd2b70f42d6ea0a11a1d6025a8" name="a33de5ebd2b70f42d6ea0a11a1d6025a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33de5ebd2b70f42d6ea0a11a1d6025a8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[20/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af38a8ff832aa2393884b0dbed498973c">HadronType</a></td>          <td class="paramname"><span class="paramname"><em>hadron</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a772325cf43d5342e1cb392648abc8dfd" name="a772325cf43d5342e1cb392648abc8dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772325cf43d5342e1cb392648abc8dfd">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[21/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a52191edec34daa17746d1937fb06c1fb">IntersectionStatus</a></td>          <td class="paramname"><span class="paramname"><em>status</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ostream-operator for the IntersectionStatus enum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">status</td><td>IntersectionStatus to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="aaf945d5e789508b76330e694c2a986e2" name="aaf945d5e789508b76330e694c2a986e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf945d5e789508b76330e694c2a986e2">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[22/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab0d37c993fdcfd74f77026bbee8e6d02">MaterialUpdateStage</a></td>          <td class="paramname"><span class="paramname"><em>matUpdate</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for MaterialUpdateStage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">matUpdate</td><td>MaterialUpdateStage to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a08e665476c1a12306164bb3aec8904a1" name="a08e665476c1a12306164bb3aec8904a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e665476c1a12306164bb3aec8904a1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[23/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print PDG particle numbers with a descriptive name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">pdg</td><td>PDG particle to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a791f673965f85f8c894dd07a00d8bd61" name="a791f673965f85f8c894dd07a00d8bd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791f673965f85f8c894dd07a00d8bd61">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[24/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for TrackStatePropMask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">mask</td><td>TrackStatePropMask to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a37a7254cbaee8f26160339b7a71879ec" name="a37a7254cbaee8f26160339b7a71879ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a7254cbaee8f26160339b7a71879ec">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[25/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_trapezoid_volume_bounds.html#a37a239bc146009fe37f583174d13feeb">TrapezoidPortalShell::Face</a></td>          <td class="paramname"><span class="paramname"><em>face</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output stream operator for the TrapezoidPortalShell::Face enum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The output stream </td></tr>
    <tr><td class="paramname">face</td><td>The face to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream </dd></dl>

</div>
</div>
<a id="a9a735e14b24e2da1c37ef72e699a65c7" name="a9a735e14b24e2da1c37ef72e699a65c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a735e14b24e2da1c37ef72e699a65c7">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[26/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a281bb3932c0b5a0fb38fdab58f043848">VolumeAttachmentStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for VolumeAttachmentStrategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">strategy</td><td>VolumeAttachmentStrategy to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="ac927a1726a9183b3cec107a3dde66eba" name="ac927a1726a9183b3cec107a3dde66eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac927a1726a9183b3cec107a3dde66eba">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[27/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8e7b9ba567f3fce3fb39c1c9ce093e93">VolumeResizeStrategy</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for VolumeResizeStrategy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream </td></tr>
    <tr><td class="paramname">strategy</td><td>VolumeResizeStrategy to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a9c79baf2a53c547a0ca47f008c6230d8" name="a9c79baf2a53c547a0ca47f008c6230d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c79baf2a53c547a0ca47f008c6230d8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[28/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_extent.html">Extent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of &lt;&lt; operator for std::ostream for debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>Output stream </td></tr>
    <tr><td class="paramname">rhs</td><td>Extent to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a782bdddc08a3a0fcdd0412cb04976b9a" name="a782bdddc08a3a0fcdd0412cb04976b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782bdddc08a3a0fcdd0412cb04976b9a">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[29/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_glue_volumes_descriptor.html">GlueVolumesDescriptor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gvd</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for GlueVolumesDescriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>Output stream </td></tr>
    <tr><td class="paramname">gvd</td><td>GlueVolumesDescriptor to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="acba1f415cfc3ca78946e3da805258994" name="acba1f415cfc3ca78946e3da805258994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba1f415cfc3ca78946e3da805258994">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[30/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_volume.html">Volume</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vol</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of &lt;&lt; operator for std::ostream for debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>Output stream </td></tr>
    <tr><td class="paramname">vol</td><td>Volume to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="aabd1454e2e9e50489ad2e76fb3b3efc3" name="aabd1454e2e9e50489ad2e76fb3b3efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd1454e2e9e50489ad2e76fb3b3efc3">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[31/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vb</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of &lt;&lt; operator for std::ostream for debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>Output stream </td></tr>
    <tr><td class="paramname">vb</td><td>VolumeBounds to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a8f4f4d5d7389b079520fdf69e9a827a8" name="a8f4f4d5d7389b079520fdf69e9a827a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4f4d5d7389b079520fdf69e9a827a8">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[32/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Acts::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_volume_bounds.html#a3840f312b207bfdd5cbbcc4ac9981495">VolumeBounds::BoundsType</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>bt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream operator for VolumeBounds::BoundsType. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>Output stream </td></tr>
    <tr><td class="paramname">bt</td><td>BoundsType to output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to output stream </dd></dl>

</div>
</div>
<a id="a26ed6ffd83366a80eb98a79799a707e2" name="a26ed6ffd83366a80eb98a79799a707e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ed6ffd83366a80eb98a79799a707e2">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality comparison for VolumeBounds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Left-hand side VolumeBounds </td></tr>
    <tr><td class="paramname">rhs</td><td>Right-hand side VolumeBounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if bounds are equal </dd></dl>

</div>
</div>
<a id="a792bc132f7117ed5a07faf80ec2ef0c3" name="a792bc132f7117ed5a07faf80ec2ef0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792bc132f7117ed5a07faf80ec2ef0c3">&#9670;&#160;</a></span>outputIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename local_bin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::outputIndices </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; local_bin &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lbins</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to screen output the local bins. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">local_bin</td><td>the type of the local bins</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lbins</td><td>the local bins</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string containing the local bins ordered in a set </dd></dl>

</div>
</div>
<a id="accbf0a2a5f699fb8704e1cc75aee2121" name="accbf0a2a5f699fb8704e1cc75aee2121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbf0a2a5f699fb8704e1cc75aee2121">&#9670;&#160;</a></span>overloaded()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::overloaded </td>
          <td>(</td>
          <td class="paramtype">Ts...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td>-&gt;overloaded&lt; Ts... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for overloaded visitor pattern. </p>

</div>
</div>
<a id="a59e8d56f5a930d507527de2100a1adc4" name="a59e8d56f5a930d507527de2100a1adc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e8d56f5a930d507527de2100a1adc4">&#9670;&#160;</a></span>parsePdgParticle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a> Acts::parsePdgParticle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a PdgParticle from a particle name string. </p>
<p>Supports common particle names like "e-", "e+", "mu-", "mu+", "tau-", "tau+", "gamma", "pi0", "pi+", "pi-", "K+", "K-", "n", "n~", "p", "p~", "Pb". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The particle name string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding PdgParticle enum value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name is not recognized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1701552b7b37a88b1b91c012100d690a" name="a1701552b7b37a88b1b91c012100d690a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1701552b7b37a88b1b91c012100d690a">&#9670;&#160;</a></span>pdgToShortAbsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::string_view &gt; Acts::pdgToShortAbsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9be1c6a7aba3d2c58133f9f2f10db45a">PdgParticle</a></td>          <td class="paramname"><span class="paramname"><em>pdg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get short absolute string representation of PDG particle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pdg</td><td>PDG particle number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Optional string view of particle name </dd></dl>

</div>
</div>
<a id="a5f8134aad04c378ce314dd9e115f3c17" name="a5f8134aad04c378ce314dd9e115f3c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8134aad04c378ce314dd9e115f3c17">&#9670;&#160;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::integral P&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Acts::pow </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the ordinary power of the number x. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Number to take the power from </td></tr>
    <tr><td class="paramname">p</td><td>Power to take </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x raised to the power p </dd></dl>

</div>
</div>
<a id="a0a9dad86571acffdac06f3af7087d27f" name="a0a9dad86571acffdac06f3af7087d27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9dad86571acffdac06f3af7087d27f">&#9670;&#160;</a></span>projectorToSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t kFullSize, typename Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; kFullSize &gt; Acts::projectorToSubspaceIndices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; Derived &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>projector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a projector to subspace indices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kFullSize</td><td>the full size of the subspace </td></tr>
    <tr><td class="paramname">Derived</td><td>the derived type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projector</td><td>the projector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the subspace indices </dd></dl>

</div>
</div>
<a id="a65c77310254a757a6edcb57a670d058c" name="a65c77310254a757a6edcb57a670d058c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c77310254a757a6edcb57a670d058c">&#9670;&#160;</a></span>range_medium()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; typename T::value_type, double &gt; Acts::range_medium </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>tseries</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return range and medium of an unsorted numeric series. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numeric series</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tseries</td><td>is the number series</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[ range, medium ] in an tuple </dd></dl>

</div>
</div>
<a id="ac6d9beca13049b91d5c9e5991f60532d" name="ac6d9beca13049b91d5c9e5991f60532d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d9beca13049b91d5c9e5991f60532d">&#9670;&#160;</a></span>rangeContainsValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::rangeContainsValue </td>
          <td>(</td>
          <td class="paramtype">const R &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This can be replaced with C++23 to use the std::ranges::contains method. </p>
<p>This function searches through the given range for a specified value and returns <span class="tt">true</span> if the value is found, or <span class="tt">false</span> otherwise.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The type of the range (e.g., vector, list, array). </td></tr>
    <tr><td class="paramname">T</td><td>The type of the value to search for within the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to search within. This can be any range-compatible container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to search for in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><span class="tt">true</span> if the value is found within the range, <span class="tt">false</span> otherwise. </dd></dl>

</div>
</div>
<a id="a448dd6193a51777a8b7c05bb1a5630eb" name="a448dd6193a51777a8b7c05bb1a5630eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448dd6193a51777a8b7c05bb1a5630eb">&#9670;&#160;</a></span>reflectBoundParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> Acts::reflectBoundParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundParams</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reflect bound track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundParams</td><td>Bound track parameters vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reflected bound track parameters vector </dd></dl>

</div>
</div>
<a id="a13a84cd96d8549b4be2395a91041f6cf" name="a13a84cd96d8549b4be2395a91041f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a84cd96d8549b4be2395a91041f6cf">&#9670;&#160;</a></span>reflectFreeParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> Acts::reflectFreeParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>freeParams</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reflect free track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freeParams</td><td>Free track parameters vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reflected free track parameters vector </dd></dl>

</div>
</div>
<a id="ac74ee49f1e16ede102272f390974153b" name="ac74ee49f1e16ede102272f390974153b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74ee49f1e16ede102272f390974153b">&#9670;&#160;</a></span>safeExp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Acts::safeExp </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the exponential function while avoiding FPEs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>argument for which the exponential function should be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 in the case of underflow, std::numeric_limits&lt;T&gt;::infinity in the case of overflow, std::exp(val) else </dd></dl>

</div>
</div>
<a id="a578b23613377e931e706252251c5f9ad" name="a578b23613377e931e706252251c5f9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578b23613377e931e706252251c5f9ad">&#9670;&#160;</a></span>safeInverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType, typename ResultType = MatrixType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; ResultType &gt; Acts::safeInverse </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FPE "safe" functions. </p>
<p>Our main motivation for this is that users might have a strict FPE policy which would flag every single occurrence as a failure and then somebody has to investigate. Since we are processing a high number of events and floating point numbers sometimes work in mysterious ways the caller of this function might want to hide FPEs and handle them in a more controlled way. Calculate the inverse of an Eigen matrix after checking if it can be numerically inverted. This allows to catch potential FPEs before they occur. For matrices up to 4x4, the inverse is computed directly. For larger matrices, and dynamic matrices the FullPivLU is used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>Eigen derived concrete type </td></tr>
    <tr><td class="paramname">Result</td><td>Eigen result type defaulted to input type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Eigen matrix to invert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The theta value </dd></dl>

</div>
</div>
<a id="a3cd785914bda5c3810e21a5f54386fd5" name="a3cd785914bda5c3810e21a5f54386fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd785914bda5c3810e21a5f54386fd5">&#9670;&#160;</a></span>serializeSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t FullSize&gt; <br />
requires (FullSize &lt;= 8)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac7fe124c6f6fda8fa31781f93cbd36b8">SerializedSubspaceIndices</a> Acts::serializeSubspaceIndices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a6a670110d0ebb9267ec1256f8bd88b6e">SubspaceIndices</a>&lt; FullSize &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize subspace indices to a single 64 bit integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FullSize</td><td>the full size of the subspace</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>the subspace indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the serialized subspace indices </dd></dl>

</div>
</div>
<a id="af71f1524930917d44ddc5444d2b5193f" name="af71f1524930917d44ddc5444d2b5193f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71f1524930917d44ddc5444d2b5193f">&#9670;&#160;</a></span>smoothTrack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t, typename smoother_t = GainMatrixSmoother&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt; Acts::smoothTrack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geoContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>track</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval">*<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackSmoother&quot;,&#160;<a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>)</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smoother_t</td>          <td class="paramname"><span class="paramname"><em>smoother</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_1_1_gain_matrix_smoother.html">GainMatrixSmoother</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth a track using the gain matrix smoother. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>The track proxy type </td></tr>
    <tr><td class="paramname">smoother_t</td><td>The smoother type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geoContext</td><td>The geometry context </td></tr>
    <tr><td class="paramname">track</td><td>The track to smooth </td></tr>
    <tr><td class="paramname">logger</td><td>The logger </td></tr>
    <tr><td class="paramname">smoother</td><td>The smoother</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the smoothing </dd></dl>

</div>
</div>
<a id="aa55a3919271931efb60a076dc3a7bf8c" name="aa55a3919271931efb60a076dc3a7bf8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55a3919271931efb60a076dc3a7bf8c">&#9670;&#160;</a></span>smoothTracks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackContainerFrontend track_container_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; void &gt; Acts::smoothTracks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geoContext</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const track_container_t &amp;</td>          <td class="paramname"><span class="paramname"><em>trackContainer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval">*<a class="el" href="#a9b4dee934b0b193d57604b19bc8cd527">getDefaultLogger</a>(&quot;TrackSmoother&quot;,&#160;<a class="el" href="group__logging.html#gga9b12dd924a4bd3aed921a33779ece95ba003d450a1d7eb775ce93a8374ca21260">Logging::INFO</a>)</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth tracks using the gain matrix smoother. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_container_t</td><td>The track container type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geoContext</td><td>The geometry context </td></tr>
    <tr><td class="paramname">trackContainer</td><td>The track container </td></tr>
    <tr><td class="paramname">logger</td><td>The logger</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the smoothing </dd></dl>

</div>
</div>
<a id="a7f3025a1035f83082b5d5bc164041ae7" name="a7f3025a1035f83082b5d5bc164041ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3025a1035f83082b5d5bc164041ae7">&#9670;&#160;</a></span>sphericalToFreeDirectionJacobian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; 3, 2 &gt; Acts::sphericalToFreeDirectionJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Jacobian for spherical to free direction vector transformation. </p>
<dl class="section note"><dt>Note</dt><dd>We use the direction vector as an input because the trigonometric simplify that way</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The normalised direction vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Jacobian d(dir_x, dir_y, dir_z) / d(phi, theta) </dd></dl>

</div>
</div>
<a id="a838abb77213dd8944857456b1e506b02" name="a838abb77213dd8944857456b1e506b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838abb77213dd8944857456b1e506b02">&#9670;&#160;</a></span>square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::square </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the square of the passed number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The number to square </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square of the input </dd></dl>

</div>
</div>
<a id="a263c06f4eb074079421fd6fefe19a873" name="a263c06f4eb074079421fd6fefe19a873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263c06f4eb074079421fd6fefe19a873">&#9670;&#160;</a></span>subtractBoundParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> Acts::subtractBoundParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract bound parameters and take care of angle periodicity for phi and theta. </p>
<p>This is intended for small differences only i.e. KF updates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand side bound parameters </td></tr>
    <tr><td class="paramname">rhs</td><td>The right hand side bound parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The difference of the bound parameters </dd></dl>

</div>
</div>
<a id="ad66d0dd0baa4fbbc5e1bdbe45a311bd6" name="ad66d0dd0baa4fbbc5e1bdbe45a311bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66d0dd0baa4fbbc5e1bdbe45a311bd6">&#9670;&#160;</a></span>sumUpToN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::integral T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Acts::sumUpToN </td>
          <td>(</td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the sum of 1 + 2 + 3+ ... + N using the Gaussian sum formula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Number until which the sum runs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of integers from 1 to N </dd></dl>

</div>
</div>
<a id="a53977e204b4bd2fafd0c06c26ab2332a" name="a53977e204b4bd2fafd0c06c26ab2332a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53977e204b4bd2fafd0c06c26ab2332a">&#9670;&#160;</a></span>symMatIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; <br />
requires (N &gt; 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::size_t, 2 &gt; Acts::symMatIndices </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map an unrolled vector index to the indices of the lower triangular part of a symmetric N x N matrix. </p>
<p>Inverse of <span class="tt">vecIdxFromSymMat</span>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The unrolled vector index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of indices (i, j) such that the element at (i, j) in the symmetric matrix corresponds to the k-th element in the unrolled vector. </dd></dl>

</div>
</div>
<a id="a41bb20848824690a2a72250980a81e4e" name="a41bb20848824690a2a72250980a81e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bb20848824690a2a72250980a81e4e">&#9670;&#160;</a></span>template_switch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; std::size_t &gt; class Callable, std::size_t N, std::size_t NMAX, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::template_switch </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a call based on a runtime value on a function taking the value at compile time. </p>
<p>This function allows to write a templated functor, which accepts a <code>std::size_t</code> like parameter at compile time. It is then possible to make a call to the corresponding instance of the functor based on a runtime value. To achieve this, the function essentially created a if cascade between <code>N</code> and <code>NMAX</code>, attempting to find the right instance. Because the cascade is visible to the compiler entirely, it should be able to optimize.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Callable</td><td>Type which takes a std::size_t as a compile time param </td></tr>
    <tr><td class="paramname">N</td><td>Value from which to start the dispatch chain, i.e. 0 in most cases </td></tr>
    <tr><td class="paramname">NMAX</td><td>Maximum value up to which to attempt a dispatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The runtime value to dispatch on </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments passed to <code>Callable::invoke()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of calling the dispatched template instance </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>Callable</code> is expected to have a static member function <code>invoke</code> that is callable with <code>Args</code> </dd></dl>

</div>
</div>
<a id="a508ee0f24c070e5785bb517a4b449e69" name="a508ee0f24c070e5785bb517a4b449e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508ee0f24c070e5785bb517a4b449e69">&#9670;&#160;</a></span>template_switch_lambda()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, std::size_t NMAX, typename Lambda, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::template_switch_lambda </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lambda &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative version of <code>template_switch</code> which accepts a generic lambda and communicates the dimension via an integral constant type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>Value from which to start the dispatch chain, i.e. 0 in most cases </td></tr>
    <tr><td class="paramname">NMAX</td><td>Maximum value up to which to attempt a dispatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The runtime value to dispatch on </td></tr>
    <tr><td class="paramname">func</td><td>The lambda to invoke </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments passed to <code class="param">func</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of calling the dispatched lambda function </dd></dl>

</div>
</div>
<a id="af63cae486ae37da877b7ec92f7a74f1e" name="af63cae486ae37da877b7ec92f7a74f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63cae486ae37da877b7ec92f7a74f1e">&#9670;&#160;</a></span>toArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t kDIM, typename value_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; value_t, kDIM &gt; Acts::toArray </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vecvals</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector to a fixed-size array with truncating or padding. </p>
<p>This function copies elements from the input vector into a fixed-size array. If the vector contains more than <span class="tt">kDIM</span> elements, the array is truncated to fit. If the vector contains fewer elements than <span class="tt">kDIM</span>, the remaining array elements are value-initialized (default-initialized, i.e., filled with zero or default values).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">kDIM</td><td>The size of the resulting array. </td></tr>
    <tr><td class="paramname">value_t</td><td>The type of elements in the vector and the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecvals</td><td>The input vector to be converted to an array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array containing the first <span class="tt">kDIM</span> elements of the vector. </dd></dl>

</div>
</div>
<a id="a9a4d2dc77ae0f047a17aa6a9af7f97b6" name="a9a4d2dc77ae0f047a17aa6a9af7f97b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4d2dc77ae0f047a17aa6a9af7f97b6">&#9670;&#160;</a></span>toString() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Acts::Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a transform in a structured way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform to print </td></tr>
    <tr><td class="paramname">precision</td><td>Numeric output precision </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in front of matrix lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The printed string </dd></dl>

</div>
</div>
<a id="a4f4ce7355440a386097b704d74051925" name="a4f4ce7355440a386097b704d74051925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4ce7355440a386097b704d74051925">&#9670;&#160;</a></span>toString() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga1a7960bfb4807cba616fd8bdf81d3d00">Acts::Translation3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>translation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a translation in a structured way. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">translation</td><td>The translation to print </td></tr>
    <tr><td class="paramname">precision</td><td>Numeric output precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The printed string </dd></dl>

</div>
</div>
<a id="a9b366bb0c46e39601d88e99f770a0b37" name="a9b366bb0c46e39601d88e99f770a0b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b366bb0c46e39601d88e99f770a0b37">&#9670;&#160;</a></span>toString() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename derived_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::toString </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; derived_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a matrix in a structured way. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">derived_t</td><td>Type of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to print </td></tr>
    <tr><td class="paramname">precision</td><td>Numeric output precision </td></tr>
    <tr><td class="paramname">offset</td><td>Offset in front of matrix lines </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The printed string </dd></dl>

</div>
</div>
<a id="afd7b6468aa0247124a2f6e19ed60bfd0" name="afd7b6468aa0247124a2f6e19ed60bfd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd7b6468aa0247124a2f6e19ed60bfd0">&#9670;&#160;</a></span>toString() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::toString </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pVector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>precision</em></span><span class="paramdefsep"> = </span><span class="paramdefval">4</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out a vector of double. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVector</td><td>The vector to print </td></tr>
    <tr><td class="paramname">precision</td><td>Numeric output precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A formatted string representation of the vector </dd></dl>

</div>
</div>
<a id="a4e21d6cf5d7c1244c2f008471cc5ba7e" name="a4e21d6cf5d7c1244c2f008471cc5ba7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e21d6cf5d7c1244c2f008471cc5ba7e">&#9670;&#160;</a></span>toUnderlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename enum_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::underlying_type_t&lt; enum_t &gt; Acts::toUnderlying </td>
          <td>(</td>
          <td class="paramtype">enum_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert enum to its underlying type value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Enum value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Underlying type value </dd></dl>

</div>
</div>
<a id="a0797332fbe40a114904edb3cba7fe644" name="a0797332fbe40a114904edb3cba7fe644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0797332fbe40a114904edb3cba7fe644">&#9670;&#160;</a></span>TrackContainer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackContainerBackend track_container_t, typename traj_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::TrackContainer </td>
          <td>(</td>
          <td class="paramtype">const track_container_t &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const traj_t &amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em></span>&#160;)-&gt;TrackContainer&lt; track_container_t, traj_t, detail::ConstRefHolder &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for TrackContainer with const references. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Const track container reference </td></tr>
    <tr><td class="paramname">traj</td><td>Const trajectory reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063c0b62e180a9fa73dff3dff298388a" name="a063c0b62e180a9fa73dff3dff298388a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063c0b62e180a9fa73dff3dff298388a">&#9670;&#160;</a></span>TrackContainer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackContainerBackend track_container_t, typename traj_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::TrackContainer </td>
          <td>(</td>
          <td class="paramtype">track_container_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">traj_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em></span>&#160;)-&gt;TrackContainer&lt; track_container_t, traj_t, detail::ValueHolder &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for TrackContainer with rvalue references. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Track container rvalue reference </td></tr>
    <tr><td class="paramname">traj</td><td>Trajectory rvalue reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cc9b6fab49588cfd71d4bef57098a06" name="a8cc9b6fab49588cfd71d4bef57098a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc9b6fab49588cfd71d4bef57098a06">&#9670;&#160;</a></span>TrackContainer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackContainerBackend track_container_t, typename traj_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Acts::TrackContainer </td>
          <td>(</td>
          <td class="paramtype">track_container_t &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">traj_t &amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em></span>&#160;)-&gt;TrackContainer&lt; track_container_t, traj_t, detail::RefHolder &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for TrackContainer with lvalue references. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Track container reference </td></tr>
    <tr><td class="paramname">traj</td><td>Trajectory reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9f59a5d52f546c1b662706a19fa5f42" name="ad9f59a5d52f546c1b662706a19fa5f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f59a5d52f546c1b662706a19fa5f42">&#9670;&#160;</a></span>transformBoundToFreeParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> Acts::transformBoundToFreeParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geoCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundParams</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform bound track parameters into equivalent free track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>Surface onto which the input parameters are bound </td></tr>
    <tr><td class="paramname">geoCtx</td><td>Geometry context for the local-to-global transformation </td></tr>
    <tr><td class="paramname">boundParams</td><td>Bound track parameters vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Equivalent free trackparameters vector </dd></dl>

</div>
</div>
<a id="a03e61ea4aa32eba6186f7b1151eab506" name="a03e61ea4aa32eba6186f7b1151eab506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e61ea4aa32eba6186f7b1151eab506">&#9670;&#160;</a></span>transformCoordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename external_spacepoint_t, typename callable_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_lin_circle.html">LinCircle</a> Acts::transformCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_space_point_mutable_data.html">Acts::SpacePointMutableData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mutableData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const external_spacepoint_t &amp;</td>          <td class="paramname"><span class="paramname"><em>sp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const external_spacepoint_t &amp;</td>          <td class="paramname"><span class="paramname"><em>spM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bottom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">callable_t &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>extractFunction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a single spacepoint to u-v space coordinates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">external_spacepoint_t</td><td>The external spacepoint type </td></tr>
    <tr><td class="paramname">callable_t</td><td>The callable type for coordinate extraction </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutableData</td><td>Container for mutable variables used in seeding </td></tr>
    <tr><td class="paramname">sp</td><td>The spacepoint to transform </td></tr>
    <tr><td class="paramname">spM</td><td>The middle reference spacepoint </td></tr>
    <tr><td class="paramname">bottom</td><td>Whether this is a bottom spacepoint </td></tr>
    <tr><td class="paramname">extractFunction</td><td>Function to extract coordinates from spacepoints </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LinCircle representing the transformed coordinates </dd></dl>

</div>
</div>
<a id="ac6f70f8d70a4d580df9fb45724d40b82" name="ac6f70f8d70a4d580df9fb45724d40b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f70f8d70a4d580df9fb45724d40b82">&#9670;&#160;</a></span>transformCoordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename external_spacepoint_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::transformCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_space_point_mutable_data.html">Acts::SpacePointMutableData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mutableData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const external_spacepoint_t * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const external_spacepoint_t &amp;</td>          <td class="paramname"><span class="paramname"><em>spM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bottom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_acts_1_1_lin_circle.html">LinCircle</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>linCircleVec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a vector of spacepoints to u-v space circles with respect to a given middle spacepoint. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">external_spacepoint_t</td><td>The external spacepoint type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mutableData</td><td>Container for mutable variables used in the seeding </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>The list of bottom or top spacepoints </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spM</td><td>The middle spacepoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>Should be true if vec are bottom spacepoints. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">linCircleVec</td><td>The output vector to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68a45911e56331406f861490dc249b1c" name="a68a45911e56331406f861490dc249b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a45911e56331406f861490dc249b1c">&#9670;&#160;</a></span>transformFreeToBoundParameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &gt; Acts::transformFreeToBoundParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>freeParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geoCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert free track parameters to bound track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freeParams</td><td>Free track parameters vector </td></tr>
    <tr><td class="paramname">surface</td><td>Surface onto which the parameters are bound </td></tr>
    <tr><td class="paramname">geoCtx</td><td>Geometry context for the global-to-local transformation </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance used for globalToLocal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bound track parameters vector on the given surface </dd></dl>

</div>
</div>
<a id="ae82c7a6d9af871513fdea936d657a12d" name="ae82c7a6d9af871513fdea936d657a12d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82c7a6d9af871513fdea936d657a12d">&#9670;&#160;</a></span>transformFreeToBoundParameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> &gt; Acts::transformFreeToBoundParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>surface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>geoCtx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert position and direction to bound track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Global track three-position </td></tr>
    <tr><td class="paramname">time</td><td>Global track time </td></tr>
    <tr><td class="paramname">direction</td><td>Global direction three-vector; normalization is ignored. </td></tr>
    <tr><td class="paramname">qOverP</td><td>Charge-over-momentum-like parameter </td></tr>
    <tr><td class="paramname">surface</td><td>Surface onto which the parameters are bound </td></tr>
    <tr><td class="paramname">geoCtx</td><td>Geometry context for the global-to-local transformation </td></tr>
    <tr><td class="paramname">tolerance</td><td>Tolerance used for globalToLocal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Equivalent bound parameters vector on the given surface </dd></dl>

</div>
</div>
<a id="a75b7d632126d8eca83e972e0a282ffa1" name="a75b7d632126d8eca83e972e0a282ffa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b7d632126d8eca83e972e0a282ffa1">&#9670;&#160;</a></span>transformFreeToCurvilinearParameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> Acts::transformFreeToCurvilinearParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert direction to curvilinear track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Global track time </td></tr>
    <tr><td class="paramname">direction</td><td>Global direction three-vector; normalization is ignored. </td></tr>
    <tr><td class="paramname">qOverP</td><td>Charge-over-momentum-like parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Equivalent bound parameters vector on the curvilinear surface</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The parameters are assumed to be defined at the origin of the curvilinear frame derived from the direction vector. The local coordinates are zero by construction. </dd></dl>

</div>
</div>
<a id="a0df692764710bba740096a20fd161cf0" name="a0df692764710bba740096a20fd161cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df692764710bba740096a20fd161cf0">&#9670;&#160;</a></span>transformFreeToCurvilinearParameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af2571f8c8ebccb37165c668fab4a1c4f">BoundVector</a> Acts::transformFreeToCurvilinearParameters </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>phi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>theta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>qOverP</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert direction angles to curvilinear track parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Global track time </td></tr>
    <tr><td class="paramname">phi</td><td>Global transverse direction angle </td></tr>
    <tr><td class="paramname">theta</td><td>Global longitudinal direction angle </td></tr>
    <tr><td class="paramname">qOverP</td><td>Charge-over-momentum-like parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Equivalent bound parameters vector on the curvilinear surface</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The parameters are assumed to be defined at the origin of the curvilinear frame derived from the direction angles. The local coordinates are zero by construction. </dd></dl>

</div>
</div>
<a id="a6e6d2189fe95760f3a86d6ebe3b9c4c5" name="a6e6d2189fe95760f3a86d6ebe3b9c4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6d2189fe95760f3a86d6ebe3b9c4c5">&#9670;&#160;</a></span>trimTrack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::trimTrack </td>
          <td>(</td>
          <td class="paramtype">track_proxy_t</td>          <td class="paramname"><span class="paramname"><em>track</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimHoles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimOutliers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimMaterial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimOtherNoneMeasurement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to trim track states from the front and back of a track. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>the track proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>the track to trim </td></tr>
    <tr><td class="paramname">trimHoles</td><td>whether to trim holes </td></tr>
    <tr><td class="paramname">trimOutliers</td><td>whether to trim outliers </td></tr>
    <tr><td class="paramname">trimMaterial</td><td>whether to trim pure material states </td></tr>
    <tr><td class="paramname">trimOtherNoneMeasurement</td><td>whether to trim other, non measurement, states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a324f2413eb01813d83b0e41bddf41e0a" name="a324f2413eb01813d83b0e41bddf41e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324f2413eb01813d83b0e41bddf41e0a">&#9670;&#160;</a></span>trimTrackBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::trimTrackBack </td>
          <td>(</td>
          <td class="paramtype">track_proxy_t</td>          <td class="paramname"><span class="paramname"><em>track</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimHoles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimOutliers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimMaterial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimOtherNoneMeasurement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to trim track states from the back of a track. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>the track proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>the track to trim </td></tr>
    <tr><td class="paramname">trimHoles</td><td>whether to trim holes </td></tr>
    <tr><td class="paramname">trimOutliers</td><td>whether to trim outliers </td></tr>
    <tr><td class="paramname">trimMaterial</td><td>whether to trim pure material states </td></tr>
    <tr><td class="paramname">trimOtherNoneMeasurement</td><td>whether to trim other, non measurement, states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad010dd74247d5542680768a03ce1fd08" name="ad010dd74247d5542680768a03ce1fd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad010dd74247d5542680768a03ce1fd08">&#9670;&#160;</a></span>trimTrackFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!track_proxy_t::ReadOnly)</div>
      <table class="memname">
        <tr>
          <td class="memname">void Acts::trimTrackFront </td>
          <td>(</td>
          <td class="paramtype">track_proxy_t</td>          <td class="paramname"><span class="paramname"><em>track</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimHoles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimOutliers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimMaterial</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trimOtherNoneMeasurement</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to trim track states from the front of a track. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>the track proxy type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">track</td><td>the track to trim </td></tr>
    <tr><td class="paramname">trimHoles</td><td>whether to trim holes </td></tr>
    <tr><td class="paramname">trimOutliers</td><td>whether to trim outliers </td></tr>
    <tr><td class="paramname">trimMaterial</td><td>whether to trim pure material states </td></tr>
    <tr><td class="paramname">trimOtherNoneMeasurement</td><td>whether to trim other, non measurement, states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af643ac54ae22c8fa907f52f4af9ca248" name="af643ac54ae22c8fa907f52f4af9ca248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af643ac54ae22c8fa907f52f4af9ca248">&#9670;&#160;</a></span>unpackConstSmartPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SmartPointerConcept T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::add_pointer_t&lt; std::add_const_t&lt; typename T::element_type &gt; &gt; &gt; Acts::unpackConstSmartPointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to unpack a vector of smart pointers (e.g. </p>
<p><code>shared_ptr</code> ) into a vector of raw const pointers </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the stored type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The vector of smart pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unpacked vector </dd></dl>

</div>
</div>
<a id="afe4ec039852e4c66c51e003dad4059d4" name="afe4ec039852e4c66c51e003dad4059d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4ec039852e4c66c51e003dad4059d4">&#9670;&#160;</a></span>unpackSmartPointers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const T * &gt; Acts::unpackSmartPointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; const T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to unpack a vector of <code>shared_ptr</code> into a vector of raw pointers (const version). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the stored type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The vector of <code>shared_ptr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unpacked vector </dd></dl>

</div>
</div>
<a id="a9d506a7514329cb489387ca5db28c266" name="a9d506a7514329cb489387ca5db28c266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d506a7514329cb489387ca5db28c266">&#9670;&#160;</a></span>unpackSmartPointers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SmartPointerConcept T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::add_pointer_t&lt; typename T::element_type &gt; &gt; Acts::unpackSmartPointers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>items</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to unpack a vector of <code>shared_ptr</code> into a vector of raw pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the stored type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>The vector of <code>shared_ptr</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unpacked vector </dd></dl>

</div>
</div>
<a id="af0f11c97998b7bf2a9fc8fabb700798b" name="af0f11c97998b7bf2a9fc8fabb700798b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f11c97998b7bf2a9fc8fabb700798b">&#9670;&#160;</a></span>vecIdxFromSymMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; <br />
requires (N &gt; 0)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Acts::vecIdxFromSymMat </td>
          <td>(</td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map the indices of the lower triangular part of a symmetric N x N matrix to an unrolled vector index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the symmetric matrix </td></tr>
    <tr><td class="paramname">k</td><td>The column index of the symmetric matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding vector index in the unrolled storage </dd></dl>

</div>
</div>
<a id="a480df02015f977ce0a30d288861639ba" name="a480df02015f977ce0a30d288861639ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480df02015f977ce0a30d288861639ba">&#9670;&#160;</a></span>visit_measurement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L, typename A, typename B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::visit_measurement </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>param</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>cov</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a lambda call on an overallocated parameter vector and covariance matrix, based on a runtime dimension value. </p>
<p>Inside the lambda call, the vector and matrix will have fixed dimensions, but will still point back to the originally given overallocated values. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>The lambda type </td></tr>
    <tr><td class="paramname">A</td><td>The parameter vector type </td></tr>
    <tr><td class="paramname">B</td><td>The covariance matrix type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No requirements on <code>A</code> and <code>B</code> are made, to enable a single overload for both const and non-const matrices/vectors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>The parameter vector </td></tr>
    <tr><td class="paramname">cov</td><td>The covariance matrix </td></tr>
    <tr><td class="paramname">dim</td><td>The actual dimension as a runtime value </td></tr>
    <tr><td class="paramname">lambda</td><td>The lambda to call with the statically sized subsets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of calling the lambda with the statically sized measurement components </dd></dl>

</div>
</div>
<a id="acec7ac380cac45f6887d3e73e0f36178" name="acec7ac380cac45f6887d3e73e0f36178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec7ac380cac45f6887d3e73e0f36178">&#9670;&#160;</a></span>visit_measurement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::visit_measurement </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lambda</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch a generic lambda on a measurement dimension. </p>
<p>This overload doesn't assume anything about what is needed inside the lambda, it communicates the dimension via an integral constant type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>The generic lambda type to call </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>The runtime dimension of the measurement </td></tr>
    <tr><td class="paramname">lambda</td><td>The generic lambda instance to call </td></tr>
    <tr><td class="paramname">args</td><td>Additional arguments passed to <code class="param">lambda</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the lambda return value </dd></dl>

</div>
</div>
<a id="ad202ce3349c6cd35350fa8d6d0a2ecbb" name="ad202ce3349c6cd35350fa8d6d0a2ecbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad202ce3349c6cd35350fa8d6d0a2ecbb">&#9670;&#160;</a></span>xyzCoordinateCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename external_spacepoint_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::xyzCoordinateCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_seed_finder_config.html">Acts::SeedFinderConfig</a>&lt; external_spacepoint_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const external_spacepoint_t &amp;</td>          <td class="paramname"><span class="paramname"><em>sp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>spacepointPosition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>outputCoordinates</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the compatibility of spacepoint coordinates in xyz assuming the Bottom-Middle direction with the strip meassument details. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">external_spacepoint_t</td><td>The external spacepoint type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>SeedFinder config containing the delegates to the strip measurement details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Input space point used in the check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spacepointPosition</td><td>Spacepoint coordinates in xyz plane. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputCoordinates</td><td>The output vector to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean that says if spacepoint is compatible with being inside the detector element. </dd></dl>

</div>
</div>
<a id="a2baea39f1436221b34dfec4ffac66ee6" name="a2baea39f1436221b34dfec4ffac66ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2baea39f1436221b34dfec4ffac66ee6">&#9670;&#160;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... R&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::zip </td>
          <td>(</td>
          <td class="paramtype">R &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that allows to zip some ranges to be used in a range-based for loop. </p>
<p>When wanting to mutate the entries, the result must be captured by value:</p>
<p>for(auto [a, b, c] : zip(ra, rb, rc)) { a+=2; }</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>The ranges type pack </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The ranges parameter pack </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the behaviour is undefined if the ranges do not have equal range</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Zip object providing iteration over multiple ranges simultaneously </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a507e1521b4ba13a3413804400712f00a" name="a507e1521b4ba13a3413804400712f00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507e1521b4ba13a3413804400712f00a">&#9670;&#160;</a></span>AxisBound</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::AxisBound = <a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7a685d1f2146dd079015e81918414e8971">AxisBoundaryType::Bound</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant for bound boundary type axis. </p>

</div>
</div>
<a id="a175a5c9afec75e82bcac5d420a12a51a" name="a175a5c9afec75e82bcac5d420a12a51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175a5c9afec75e82bcac5d420a12a51a">&#9670;&#160;</a></span>AxisClosed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::AxisClosed = <a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7a03f4a47830f97377a35321051685071e">AxisBoundaryType::Closed</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant for closed boundary type axis. </p>

</div>
</div>
<a id="ad651c70eef2af54126bd856e558b80ed" name="ad651c70eef2af54126bd856e558b80ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad651c70eef2af54126bd856e558b80ed">&#9670;&#160;</a></span>AxisOpen</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto Acts::AxisOpen = <a class="el" href="struct_acts_1_1_axis_boundary_type_tag.html">AxisBoundaryTypeTag</a>&lt;<a class="el" href="#a8cacb654fb3407f6911cfcf424f69ba7ac3bf447eabe632720a3aa1a7ce401274">AxisBoundaryType::Open</a>&gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience typedefs for AxisBoundaryTypeTag Constant for open boundary type axis. </p>

</div>
</div>
<a id="a5126c57045207c4b5f7e5a88b02e8ed1" name="a5126c57045207c4b5f7e5a88b02e8ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5126c57045207c4b5f7e5a88b02e8ed1">&#9670;&#160;</a></span>kBoundSubspaceIndicesInvalid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a> Acts::kBoundSubspaceIndicesInvalid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <a class="code hl_enumvalue" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="code hl_enumvalue" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="code hl_enumvalue" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="code hl_enumvalue" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="code hl_enumvalue" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>, <a class="code hl_enumvalue" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a>}</div>
<div class="ttc" id="anamespace_acts_html_ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8"><div class="ttname"><a href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">Acts::eBoundSize</a></div><div class="ttdeci">@ eBoundSize</div><div class="ttdef"><b>Definition</b> TrackParametrization.hpp:55</div></div>
</div><!-- fragment -->
<p>type alias for indices of bound track parameters subspace </p>
<p>used to specify which components of the bound track parameters are being referenced </p>

</div>
</div>
<a id="a1c422bbaca4aaec733b49b97645ea1b4" name="a1c422bbaca4aaec733b49b97645ea1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c422bbaca4aaec733b49b97645ea1b4">&#9670;&#160;</a></span>kMeasurementSizeMax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Acts::kMeasurementSizeMax = <a class="el" href="#ad2b38e86cfd40fa19fe61c74e8ca9fc7a5db0a5bb5e8e9b2b691dbab14f6168b8">eBoundSize</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of measurement dimension supported. </p>

</div>
</div>
<a id="a589e3f01b082df3de46c2a6f5e6ce749" name="a589e3f01b082df3de46c2a6f5e6ce749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589e3f01b082df3de46c2a6f5e6ce749">&#9670;&#160;</a></span>kTrackIndexInvalid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a> Acts::kTrackIndexInvalid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::numeric_limits&lt;TrackIndexType&gt;::max()</div>
</div><!-- fragment -->
<p>Sentinel value for an invalid / unset track EDM related index. </p>

</div>
</div>
<a id="aff077588e6b9207d49c53b1556be3a23" name="aff077588e6b9207d49c53b1556be3a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff077588e6b9207d49c53b1556be3a23">&#9670;&#160;</a></span>NoTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float Acts::NoTime = std::numeric_limits&lt;float&gt;::quiet_NaN()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a526e32fbccfb7d636cadc94909fa448d" name="a526e32fbccfb7d636cadc94909fa448d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526e32fbccfb7d636cadc94909fa448d">&#9670;&#160;</a></span>PolygonDynamic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Acts::PolygonDynamic = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tag to trigger specialization of a dynamic polygon. </p>

</div>
</div>
<a id="a1f4c781401229c29df002208ff1dc1ba" name="a1f4c781401229c29df002208ff1dc1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4c781401229c29df002208ff1dc1ba">&#9670;&#160;</a></span>s_curvilinearProjTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Acts::s_curvilinearProjTolerance = 0.999995</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerance for not being within curvilinear projection this allows using the same curvilinear frame to eta = 6, validity tested with IntegrationTests/PropagationTest. </p>

</div>
</div>
<a id="ad0707e56cf6d115c562bd792d8f6654f" name="ad0707e56cf6d115c562bd792d8f6654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0707e56cf6d115c562bd792d8f6654f">&#9670;&#160;</a></span>s_defaultPortalColor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_color.html">Color</a> Acts::s_defaultPortalColor {&quot;#308c48&quot;}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default color for portals. </p>

</div>
</div>
<a id="aba3b6dc8a453241ed35c45d00c833b65" name="aba3b6dc8a453241ed35c45d00c833b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3b6dc8a453241ed35c45d00c833b65">&#9670;&#160;</a></span>s_defaultSurfaceColor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_color.html">Color</a> Acts::s_defaultSurfaceColor {&quot;#0000aa&quot;}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default color for surfaces. </p>

</div>
</div>
<a id="a19ae35bb28a080cd8bb870efe6ddd14d" name="a19ae35bb28a080cd8bb870efe6ddd14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ae35bb28a080cd8bb870efe6ddd14d">&#9670;&#160;</a></span>s_defaultVolumColor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_color.html">Color</a> Acts::s_defaultVolumColor {&quot;#ffaa00&quot;}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default color for volumes. </p>

</div>
</div>
<a id="aec5e2fa11844ec94a3fbe5b522de31f0" name="aec5e2fa11844ec94a3fbe5b522de31f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5e2fa11844ec94a3fbe5b522de31f0">&#9670;&#160;</a></span>s_epsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Acts::s_epsilon = 3 * std::numeric_limits&lt;double&gt;::epsilon()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerance for being numerical equal for geometry building. </p>

</div>
</div>
<a id="a3139a86b74eaa775555ed463c528edf5" name="a3139a86b74eaa775555ed463c528edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3139a86b74eaa775555ed463c528edf5">&#9670;&#160;</a></span>s_maximumNumberOfIntersections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af9169827ccc34e24679e5d48aa3cd8a1">IntersectionIndex</a> Acts::s_maximumNumberOfIntersections = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff17152369521bfeda43fe4318dedaa" name="a3ff17152369521bfeda43fe4318dedaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff17152369521bfeda43fe4318dedaa">&#9670;&#160;</a></span>s_noBounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_infinite_bounds.html">InfiniteBounds</a> Acts::s_noBounds {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a062150b6d58b9acb88af2feaf8d3aa2b" name="a062150b6d58b9acb88af2feaf8d3aa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062150b6d58b9acb88af2feaf8d3aa2b">&#9670;&#160;</a></span>s_onSurfaceTolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Acts::s_onSurfaceTolerance = 1e-4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerance for being on Surface. </p>
<dl class="section note"><dt>Note</dt><dd>This is intentionally given w/o an explicit unit to avoid having to include the units header unnecessarily. With the native length unit of mm this corresponds to 0.1um. </dd></dl>

</div>
</div>
<a id="a20e9389f108112123af72da0b35415b7" name="a20e9389f108112123af72da0b35415b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e9389f108112123af72da0b35415b7">&#9670;&#160;</a></span>s_planeXY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> Acts::s_planeXY = Transform3::Identity()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a742fe36753d6446db9ea8c0f8701a352" name="a742fe36753d6446db9ea8c0f8701a352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742fe36753d6446db9ea8c0f8701a352">&#9670;&#160;</a></span>s_planeYZ</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> Acts::s_planeYZ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code hl_typedef" href="group__algebra__types.html#gad51b61e2bb0e1f7a1a6216925133f0e2">AngleAxis3</a>(std::numbers::pi / 2., Vector3::UnitY()) *</div>
<div class="line">    <a class="code hl_typedef" href="group__algebra__types.html#gad51b61e2bb0e1f7a1a6216925133f0e2">AngleAxis3</a>(std::numbers::pi / 2., Vector3::UnitZ()) *</div>
<div class="line">    Transform3::Identity()</div>
<div class="ttc" id="agroup__algebra__types_html_gad51b61e2bb0e1f7a1a6216925133f0e2"><div class="ttname"><a href="group__algebra__types.html#gad51b61e2bb0e1f7a1a6216925133f0e2">Acts::AngleAxis3</a></div><div class="ttdeci">Eigen::AngleAxis&lt; double &gt; AngleAxis3</div><div class="ttdoc">Rotation defined by an angle around a rotation axis in 3D.</div><div class="ttdef"><b>Definition</b> Algebra.hpp:94</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af36def3e2f9465f929dd4d273b1e1149" name="af36def3e2f9465f929dd4d273b1e1149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36def3e2f9465f929dd4d273b1e1149">&#9670;&#160;</a></span>s_planeZX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> Acts::s_planeZX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code hl_typedef" href="group__algebra__types.html#gad51b61e2bb0e1f7a1a6216925133f0e2">AngleAxis3</a>(-std::numbers::pi / 2., Vector3::UnitX()) *</div>
<div class="line">    <a class="code hl_typedef" href="group__algebra__types.html#gad51b61e2bb0e1f7a1a6216925133f0e2">AngleAxis3</a>(-std::numbers::pi / 2., Vector3::UnitZ()) *</div>
<div class="line">    Transform3::Identity()</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8eecb9e1cadbd7e2d179dc57de6c37b7" name="a8eecb9e1cadbd7e2d179dc57de6c37b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eecb9e1cadbd7e2d179dc57de6c37b7">&#9670;&#160;</a></span>s_viewFiltered</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewFiltered = {.color = {255, 255, 0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afea1b5aedf4f718a6a97e9363622ded3" name="afea1b5aedf4f718a6a97e9363622ded3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea1b5aedf4f718a6a97e9363622ded3">&#9670;&#160;</a></span>s_viewGrid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewGrid = {.color = {220, 0, 0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff982fda48acad30c85288b19b33fb86" name="aff982fda48acad30c85288b19b33fb86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff982fda48acad30c85288b19b33fb86">&#9670;&#160;</a></span>s_viewLine</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewLine = {.color = {0, 0, 220}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a554d4531937faeff795eae33ae831c" name="a2a554d4531937faeff795eae33ae831c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a554d4531937faeff795eae33ae831c">&#9670;&#160;</a></span>s_viewMeasurement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewMeasurement = {.color = {255, 102, 0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c6d8b5fc1957cd0190dc2d3ecd70818" name="a4c6d8b5fc1957cd0190dc2d3ecd70818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c6d8b5fc1957cd0190dc2d3ecd70818">&#9670;&#160;</a></span>s_viewParameter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewParameter = {.color = {0, 0, 255}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f54455611bad47046df232ba50ad6a5" name="a1f54455611bad47046df232ba50ad6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f54455611bad47046df232ba50ad6a5">&#9670;&#160;</a></span>s_viewPassive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewPassive = {.color = {240, 280, 0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f126ed2df82acedde2e6dfdd7c716e5" name="a6f126ed2df82acedde2e6dfdd7c716e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f126ed2df82acedde2e6dfdd7c716e5">&#9670;&#160;</a></span>s_viewPortal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewPortal = {.color = <a class="el" href="struct_acts_1_1_color.html">Color</a>{&quot;#308c48&quot;}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a254ae108fc03e77b6696a99306f5cf97" name="a254ae108fc03e77b6696a99306f5cf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254ae108fc03e77b6696a99306f5cf97">&#9670;&#160;</a></span>s_viewPredicted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewPredicted = {.color = {51, 204, 51}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e6deff8fee97c4b0739e26f4ad59496" name="a2e6deff8fee97c4b0739e26f4ad59496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6deff8fee97c4b0739e26f4ad59496">&#9670;&#160;</a></span>s_viewSensitive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewSensitive = {.color = {0, 180, 240}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11cf9f040a91360f791598e0fec7b03a" name="a11cf9f040a91360f791598e0fec7b03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf9f040a91360f791598e0fec7b03a">&#9670;&#160;</a></span>s_viewSmoothed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewSmoothed = {.color = {0, 102, 25}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e88165f9dc20c209a6761493b8eb986" name="a0e88165f9dc20c209a6761493b8eb986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e88165f9dc20c209a6761493b8eb986">&#9670;&#160;</a></span>s_viewSurface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewSurface = {.color = {170, 170, 170}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b24d457aac2fdb38a4b9b4e0450f093" name="a5b24d457aac2fdb38a4b9b4e0450f093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b24d457aac2fdb38a4b9b4e0450f093">&#9670;&#160;</a></span>s_viewVolume</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> Acts::s_viewVolume = {.color = {220, 220, 0}}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae88a24bc8e6cfe39de34f12bda049edd" name="ae88a24bc8e6cfe39de34f12bda049edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88a24bc8e6cfe39de34f12bda049edd">&#9670;&#160;</a></span>SupportsBoundParameters_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stepper_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::SupportsBoundParameters_v</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code hl_struct" href="struct_acts_1_1_supports_bound_parameters.html">SupportsBoundParameters&lt;stepper_t&gt;::value</a></div>
<div class="ttc" id="astruct_acts_1_1_supports_bound_parameters_html"><div class="ttname"><a href="struct_acts_1_1_supports_bound_parameters.html">Acts::SupportsBoundParameters</a></div><div class="ttdef"><b>Definition</b> PropagatorTraits.hpp:16</div></div>
</div><!-- fragment -->
<p>Variable template for checking bound parameters support. </p>

</div>
</div>
<a id="a7fc11ee35d17cdf6bb12607b24ef9e7d" name="a7fc11ee35d17cdf6bb12607b24ef9e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc11ee35d17cdf6bb12607b24ef9e7d">&#9670;&#160;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_type_tag.html">TypeTag</a>&lt;T&gt; Acts::Type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience variable for creating TypeTag instances. </p>

</div>
</div>
<a id="ab012b1460d76cf4a86e93f2236859d5a" name="ab012b1460d76cf4a86e93f2236859d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab012b1460d76cf4a86e93f2236859d5a">&#9670;&#160;</a></span>zeroEnvelope</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aa009e51d59c1a881d343ba0f9fcacbbc">Envelope</a> Acts::zeroEnvelope = {0, 0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero envelope constant for no extension. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
