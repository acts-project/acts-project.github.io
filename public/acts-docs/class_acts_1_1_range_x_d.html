<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::RangeXD&lt; Dims, Type, Vector &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_range_x_d.html','','class_acts_1_1_range_x_d-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::RangeXD&lt; Dims, Type, Vector &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An orthogonal range in an arbitrary number of dimensions.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_range_x_d_8hpp_source.html">Acts/Utilities/RangeXD.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::RangeXD&lt; Dims, Type, Vector &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_range_x_d__inherit__graph.svg" width="632" height="252"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeec3aae321f39c59debe6164fd8a581b" id="r_aeec3aae321f39c59debe6164fd8a581b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a> ()</td></tr>
<tr class="memitem:a638cb9e451363dbbe8ff00f818334d84" id="r_a638cb9e451363dbbe8ff00f818334d84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a638cb9e451363dbbe8ff00f818334d84">RangeXD</a> (const std::pair&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &gt; &amp;p)</td></tr>
<tr class="memdesc:a638cb9e451363dbbe8ff00f818334d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range from a pair of minimum and maximum values.  <br /></td></tr>
<tr class="memitem:a0e8f622d929981f93a7a8e111e562565" id="r_a0e8f622d929981f93a7a8e111e562565"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e8f622d929981f93a7a8e111e562565">RangeXD</a> (<a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> minimum, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> maximum)</td></tr>
<tr class="memdesc:a0e8f622d929981f93a7a8e111e562565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range from a pair of single minimum and maximum values.  <br /></td></tr>
<tr class="memitem:aeb5d87f5c50592ad95a57fe5c21863d0" id="r_aeb5d87f5c50592ad95a57fe5c21863d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb5d87f5c50592ad95a57fe5c21863d0">RangeXD</a> (Vector&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Dims &gt; minima, Vector&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Dims &gt; maxima)</td></tr>
<tr class="memdesc:aeb5d87f5c50592ad95a57fe5c21863d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a range from a pair of minimum and maximum values.  <br /></td></tr>
<tr class="memitem:ad29c7d8ea95e4df489438f397bdc444a" id="r_ad29c7d8ea95e4df489438f397bdc444a"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, std::size_t &gt; typename coordinate_t = std::array&gt; </td></tr>
<tr class="memitem:ad29c7d8ea95e4df489438f397bdc444a template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad29c7d8ea95e4df489438f397bdc444a">contains</a> (const coordinate_t&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Dims &gt; &amp;v) const</td></tr>
<tr class="memdesc:ad29c7d8ea95e4df489438f397bdc444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the range contains a certain point.  <br /></td></tr>
<tr class="memitem:a76e2b0582e2080497364fcb4423381ee" id="r_a76e2b0582e2080497364fcb4423381ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e2b0582e2080497364fcb4423381ee">degenerate</a> () const</td></tr>
<tr class="memdesc:a76e2b0582e2080497364fcb4423381ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this range is degenerate.  <br /></td></tr>
<tr class="memitem:a4e5d353c3d2196ebe3ec2a9f55bf26b6" id="r_a4e5d353c3d2196ebe3ec2a9f55bf26b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e5d353c3d2196ebe3ec2a9f55bf26b6">expand</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a>, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a>)</td></tr>
<tr class="memdesc:a4e5d353c3d2196ebe3ec2a9f55bf26b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a range on both ends.  <br /></td></tr>
<tr class="memitem:a8d191f30c404545286b22e4ef1934c81" id="r_a8d191f30c404545286b22e4ef1934c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d191f30c404545286b22e4ef1934c81">expandMax</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:a8d191f30c404545286b22e4ef1934c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a range by increasing the maximum value.  <br /></td></tr>
<tr class="memitem:a5df879f3df4a752759c3e94136c2c031" id="r_a5df879f3df4a752759c3e94136c2c031"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5df879f3df4a752759c3e94136c2c031">expandMin</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:a5df879f3df4a752759c3e94136c2c031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a range by decreasing the minimum value.  <br /></td></tr>
<tr class="memitem:a635805d8c598f59e5c4a30b3c93fa2a1" id="r_a635805d8c598f59e5c4a30b3c93fa2a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a> (std::size_t i)</td></tr>
<tr class="memdesc:a635805d8c598f59e5c4a30b3c93fa2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum value of the range <code class="param">i</code> (inclusive).  <br /></td></tr>
<tr class="memitem:af2d6631036f001a5be834e4b1e93ca4e" id="r_af2d6631036f001a5be834e4b1e93ca4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2d6631036f001a5be834e4b1e93ca4e">max</a> (std::size_t i) const</td></tr>
<tr class="memdesc:af2d6631036f001a5be834e4b1e93ca4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum value of the range <code class="param">i</code> (inclusive).  <br /></td></tr>
<tr class="memitem:a706009f7f3ecaadb1acdbfd4f25b0950" id="r_a706009f7f3ecaadb1acdbfd4f25b0950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a> (std::size_t i)</td></tr>
<tr class="memdesc:a706009f7f3ecaadb1acdbfd4f25b0950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum value of the range <code class="param">i</code> (inclusive).  <br /></td></tr>
<tr class="memitem:a9cb7df2f26d79a8fb538b9445e30427e" id="r_a9cb7df2f26d79a8fb538b9445e30427e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb7df2f26d79a8fb538b9445e30427e">min</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a9cb7df2f26d79a8fb538b9445e30427e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum value of the range <code class="param">i</code> (inclusive).  <br /></td></tr>
<tr class="memitem:af35555a11f8c6c19b711092a0d38d8d3" id="r_af35555a11f8c6c19b711092a0d38d8d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af35555a11f8c6c19b711092a0d38d8d3">operator&amp;</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;o) const</td></tr>
<tr class="memdesc:af35555a11f8c6c19b711092a0d38d8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection of this range with another range.  <br /></td></tr>
<tr class="memitem:ad1852a418fb2c6ba209bbf54a91941e0" id="r_ad1852a418fb2c6ba209bbf54a91941e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1852a418fb2c6ba209bbf54a91941e0">operator&amp;&amp;</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;r) const</td></tr>
<tr class="memdesc:ad1852a418fb2c6ba209bbf54a91941e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this range intersects another.  <br /></td></tr>
<tr class="memitem:a826bbc556c8c949e7367ca89482ca901" id="r_a826bbc556c8c949e7367ca89482ca901"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826bbc556c8c949e7367ca89482ca901">operator&amp;=</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;o)</td></tr>
<tr class="memdesc:a826bbc556c8c949e7367ca89482ca901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the range to the intersection with another range.  <br /></td></tr>
<tr class="memitem:a1f3a7f4fa96404fec2da3de3e7bb75d8" id="r_a1f3a7f4fa96404fec2da3de3e7bb75d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f3a7f4fa96404fec2da3de3e7bb75d8">operator&lt;=</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;o) const</td></tr>
<tr class="memdesc:a1f3a7f4fa96404fec2da3de3e7bb75d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether one range is a subset of another range.  <br /></td></tr>
<tr class="memitem:abc4f1093f53aca01984eec8ae5c1ec4f" id="r_abc4f1093f53aca01984eec8ae5c1ec4f"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename, std::size_t &gt; typename V&gt; </td></tr>
<tr class="memitem:abc4f1093f53aca01984eec8ae5c1ec4f template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4f1093f53aca01984eec8ae5c1ec4f">operator=</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, V &gt; &amp;o)</td></tr>
<tr class="memdesc:abc4f1093f53aca01984eec8ae5c1ec4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="memitem:a328d85ac345f9f87d8248ef86176a24f" id="r_a328d85ac345f9f87d8248ef86176a24f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a328d85ac345f9f87d8248ef86176a24f">operator==</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;o) const</td></tr>
<tr class="memdesc:a328d85ac345f9f87d8248ef86176a24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two ranges are equal.  <br /></td></tr>
<tr class="memitem:aa49cf0d6080874c2ca714fa48d762d90" id="r_aa49cf0d6080874c2ca714fa48d762d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa49cf0d6080874c2ca714fa48d762d90">operator&gt;=</a> (const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;o) const</td></tr>
<tr class="memdesc:aa49cf0d6080874c2ca714fa48d762d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether one range is a superset of another range.  <br /></td></tr>
<tr class="memitem:abf3e9a2f75444319686469bf05e56262" id="r_abf3e9a2f75444319686469bf05e56262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; 1, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, SingleElementContainer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf3e9a2f75444319686469bf05e56262">operator[]</a> (const std::size_t &amp;i)</td></tr>
<tr class="memdesc:abf3e9a2f75444319686469bf05e56262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access one of the dimensional ranges of the volume.  <br /></td></tr>
<tr class="memitem:a6caa03a651f57841207e425e1e70d781" id="r_a6caa03a651f57841207e425e1e70d781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; 1, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6caa03a651f57841207e425e1e70d781">operator[]</a> (const std::size_t &amp;i) const</td></tr>
<tr class="memdesc:a6caa03a651f57841207e425e1e70d781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access one of the dimensional ranges of the volume.  <br /></td></tr>
<tr class="memitem:a46ac7130dcf84061b62cf2d0a50c4edb" id="r_a46ac7130dcf84061b62cf2d0a50c4edb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46ac7130dcf84061b62cf2d0a50c4edb">set</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a>, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a>)</td></tr>
<tr class="memdesc:a46ac7130dcf84061b62cf2d0a50c4edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum and maximum value.  <br /></td></tr>
<tr class="memitem:af265f8059ae14ee51e36311c60f6c473" id="r_af265f8059ae14ee51e36311c60f6c473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af265f8059ae14ee51e36311c60f6c473">setMax</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:af265f8059ae14ee51e36311c60f6c473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum value.  <br /></td></tr>
<tr class="memitem:a1e2988377da4a4cc7cb23059899096e1" id="r_a1e2988377da4a4cc7cb23059899096e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e2988377da4a4cc7cb23059899096e1">setMin</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:a1e2988377da4a4cc7cb23059899096e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum value.  <br /></td></tr>
<tr class="memitem:a223fe129e17ccde5425b4ad642ee02cc" id="r_a223fe129e17ccde5425b4ad642ee02cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a223fe129e17ccde5425b4ad642ee02cc">shrink</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a>, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a>)</td></tr>
<tr class="memdesc:a223fe129e17ccde5425b4ad642ee02cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a range on both ends.  <br /></td></tr>
<tr class="memitem:ae6e515d38fb1802a972264645b8978c4" id="r_ae6e515d38fb1802a972264645b8978c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6e515d38fb1802a972264645b8978c4">shrinkMax</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:ae6e515d38fb1802a972264645b8978c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a range by decreasing the maximum value.  <br /></td></tr>
<tr class="memitem:aecbcbe0adfd03e9181c0ec800b5d01af" id="r_aecbcbe0adfd03e9181c0ec800b5d01af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecbcbe0adfd03e9181c0ec800b5d01af">shrinkMin</a> (std::size_t i, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:aecbcbe0adfd03e9181c0ec800b5d01af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a range by increasing the minimum value.  <br /></td></tr>
<tr class="memitem:a9aaa46109fd363f32390f21182f3929d" id="r_a9aaa46109fd363f32390f21182f3929d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aaa46109fd363f32390f21182f3929d">toString</a> (void) const</td></tr>
<tr class="memdesc:a9aaa46109fd363f32390f21182f3929d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent the range as a string.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a571cf93c227de6a65683756a0feb5792" id="r_a571cf93c227de6a65683756a0feb5792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a571cf93c227de6a65683756a0feb5792">expandMin</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:a571cf93c227de6a65683756a0feb5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for manipulating a range of dimension 1.  <br /></td></tr>
<tr class="memitem:a2de31b80e6bdc4c80b4d38f782bdaf3e" id="r_a2de31b80e6bdc4c80b4d38f782bdaf3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2de31b80e6bdc4c80b4d38f782bdaf3e">expandMax</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:a2de31b80e6bdc4c80b4d38f782bdaf3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a range by increasing the maximum value.  <br /></td></tr>
<tr class="memitem:a62a74c19dc71934d6a1e39fd759b70a8" id="r_a62a74c19dc71934d6a1e39fd759b70a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a74c19dc71934d6a1e39fd759b70a8">expand</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a>, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a>)</td></tr>
<tr class="memdesc:a62a74c19dc71934d6a1e39fd759b70a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a range on both ends.  <br /></td></tr>
<tr class="memitem:a6ffb8110a98325ba67c922d5e39a66f3" id="r_a6ffb8110a98325ba67c922d5e39a66f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ffb8110a98325ba67c922d5e39a66f3">shrinkMin</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:a6ffb8110a98325ba67c922d5e39a66f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a range by increasing the minimum value.  <br /></td></tr>
<tr class="memitem:ac17f265b111e23903c25bb0103207b81" id="r_ac17f265b111e23903c25bb0103207b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17f265b111e23903c25bb0103207b81">shrinkMax</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:ac17f265b111e23903c25bb0103207b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a range by decreasing the maximum value.  <br /></td></tr>
<tr class="memitem:ab7d9d5d5f43705ba6c3b91c6a535c0ef" id="r_ab7d9d5d5f43705ba6c3b91c6a535c0ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7d9d5d5f43705ba6c3b91c6a535c0ef">shrink</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a>, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a>)</td></tr>
<tr class="memdesc:ab7d9d5d5f43705ba6c3b91c6a535c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink a range on both ends.  <br /></td></tr>
<tr class="memitem:ac2eced262a330adbfc6d3c6b79ab19b2" id="r_ac2eced262a330adbfc6d3c6b79ab19b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2eced262a330adbfc6d3c6b79ab19b2">setMin</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:ac2eced262a330adbfc6d3c6b79ab19b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum value.  <br /></td></tr>
<tr class="memitem:ada55a084918c1c5c9cb56653a9a40107" id="r_ada55a084918c1c5c9cb56653a9a40107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada55a084918c1c5c9cb56653a9a40107">setMax</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v)</td></tr>
<tr class="memdesc:ada55a084918c1c5c9cb56653a9a40107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum value.  <br /></td></tr>
<tr class="memitem:a82a8fd5234fed4b3352d76e2a59ad609" id="r_a82a8fd5234fed4b3352d76e2a59ad609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a8fd5234fed4b3352d76e2a59ad609">set</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a706009f7f3ecaadb1acdbfd4f25b0950">min</a>, const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;<a class="el" href="#a635805d8c598f59e5c4a30b3c93fa2a1">max</a>)</td></tr>
<tr class="memdesc:a82a8fd5234fed4b3352d76e2a59ad609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum and maximum value.  <br /></td></tr>
<tr class="memitem:ae5459dfbd483cf2980cc9017fdedbf44" id="r_ae5459dfbd483cf2980cc9017fdedbf44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5459dfbd483cf2980cc9017fdedbf44">min</a> () const</td></tr>
<tr class="memdesc:ae5459dfbd483cf2980cc9017fdedbf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum value of the range (inclusive).  <br /></td></tr>
<tr class="memitem:a56cc5ab025326b82e7a05cf0b7f7bc39" id="r_a56cc5ab025326b82e7a05cf0b7f7bc39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56cc5ab025326b82e7a05cf0b7f7bc39">min</a> ()</td></tr>
<tr class="memdesc:a56cc5ab025326b82e7a05cf0b7f7bc39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum value of the range (inclusive).  <br /></td></tr>
<tr class="memitem:ac8963f192a7aa58c111f022c71bf11b0" id="r_ac8963f192a7aa58c111f022c71bf11b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8963f192a7aa58c111f022c71bf11b0">max</a> () const</td></tr>
<tr class="memdesc:ac8963f192a7aa58c111f022c71bf11b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum value of the range (inclusive).  <br /></td></tr>
<tr class="memitem:a92b3810e5c7843d2d93fae6c1433ccf1" id="r_a92b3810e5c7843d2d93fae6c1433ccf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92b3810e5c7843d2d93fae6c1433ccf1">max</a> ()</td></tr>
<tr class="memdesc:a92b3810e5c7843d2d93fae6c1433ccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum value of the range (inclusive).  <br /></td></tr>
<tr class="memitem:a8fbd8bbc808cf2596871890f6bfa7b69" id="r_a8fbd8bbc808cf2596871890f6bfa7b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fbd8bbc808cf2596871890f6bfa7b69">size</a> () const</td></tr>
<tr class="memdesc:a8fbd8bbc808cf2596871890f6bfa7b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the range.  <br /></td></tr>
<tr class="memitem:a6e8d952cca24ae8f310c576685ee7214" id="r_a6e8d952cca24ae8f310c576685ee7214"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e8d952cca24ae8f310c576685ee7214">contains</a> (const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;v) const</td></tr>
<tr class="memdesc:a6e8d952cca24ae8f310c576685ee7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the range contains a given value.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt;<br />
class Acts::RangeXD&lt; Dims, Type, Vector &gt;</div><p>An orthogonal range in an arbitrary number of dimensions. </p>
<p>By combining a number one-dimensional ranges we can (under the assumption that our axes are orthogonal) construct an orthogonal range of values. In other words, a hyperrectangular volume in space.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dims</td><td>The number of dimensions in our range </td></tr>
    <tr><td class="paramname">Type</td><td>The scalar type of our ranges </td></tr>
    <tr><td class="paramname">Vector</td><td>The vector type used to define coordinates </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeec3aae321f39c59debe6164fd8a581b" name="aeec3aae321f39c59debe6164fd8a581b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec3aae321f39c59debe6164fd8a581b">&#9670;&#160;</a></span>RangeXD() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::RangeXD </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb5d87f5c50592ad95a57fe5c21863d0" name="aeb5d87f5c50592ad95a57fe5c21863d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5d87f5c50592ad95a57fe5c21863d0">&#9670;&#160;</a></span>RangeXD() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::RangeXD </td>
          <td>(</td>
          <td class="paramtype">Vector&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Dims &gt;</td>          <td class="paramname"><span class="paramname"><em>minima</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Dims &gt;</td>          <td class="paramname"><span class="paramname"><em>maxima</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a range from a pair of minimum and maximum values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minima</td><td>The minimum values of the range </td></tr>
    <tr><td class="paramname">maxima</td><td>The maximum values of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e8f622d929981f93a7a8e111e562565" name="a0e8f622d929981f93a7a8e111e562565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8f622d929981f93a7a8e111e562565">&#9670;&#160;</a></span>RangeXD() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::RangeXD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a></td>          <td class="paramname"><span class="paramname"><em>minimum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a></td>          <td class="paramname"><span class="paramname"><em>maximum</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a range from a pair of single minimum and maximum values. </p>
<dl class="section note"><dt>Note</dt><dd>Only available for one-dimensional ranges </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimum</td><td>The minimum value of the range </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum value of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a638cb9e451363dbbe8ff00f818334d84" name="a638cb9e451363dbbe8ff00f818334d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638cb9e451363dbbe8ff00f818334d84">&#9670;&#160;</a></span>RangeXD() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::RangeXD </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a range from a pair of minimum and maximum values. </p>
<dl class="section note"><dt>Note</dt><dd>Only available for one-dimensional ranges </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pair of minimum and maximum values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="ad29c7d8ea95e4df489438f397bdc444a" name="ad29c7d8ea95e4df489438f397bdc444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29c7d8ea95e4df489438f397bdc444a">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename, std::size_t &gt; typename coordinate_t = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const coordinate_t&lt; <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Dims &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the range contains a certain point. </p>
<p>This is true if and only if the range contains the point in all of its dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The coordinate to check for membership in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The coordinate is inside the range </dd>
<dd>
false The coordinate is outside the range </dd></dl>

</div>
</div>
<a id="a6e8d952cca24ae8f310c576685ee7214" name="a6e8d952cca24ae8f310c576685ee7214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8d952cca24ae8f310c576685ee7214">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the range contains a given value. </p>
<p>A value is inside a range if and only if it is greater than the minimum and smaller than the maximum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The value is inside the range </dd>
<dd>
false The value is not inside the range </dd></dl>

</div>
</div>
<a id="a76e2b0582e2080497364fcb4423381ee" name="a76e2b0582e2080497364fcb4423381ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e2b0582e2080497364fcb4423381ee">&#9670;&#160;</a></span>degenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::degenerate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this range is degenerate. </p>
<p>A degenerate multi-dimensional range has no volume and cannot contain any values. This is the case if any of its dimensions are degenerate.</p>
<dl class="section return"><dt>Returns</dt><dd>true The range is degenerate </dd>
<dd>
false The range is not degenerate </dd></dl>

</div>
</div>
<a id="a62a74c19dc71934d6a1e39fd759b70a8" name="a62a74c19dc71934d6a1e39fd759b70a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a74c19dc71934d6a1e39fd759b70a8">&#9670;&#160;</a></span>expand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a range on both ends. </p>
<p>Expand a range by decreasing the minimum value as well as increasing the maximum value. If either of the values are already larger or smaller (respectively) than the proposed values, then that particular boundary of the interval is not expanded.</p>
<dl class="section note"><dt>Note</dt><dd>After this operation, the range is always equal to or larger than [min, max].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The proposed new minimum for the range </td></tr>
    <tr><td class="paramname">max</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e5d353c3d2196ebe3ec2a9f55bf26b6" name="a4e5d353c3d2196ebe3ec2a9f55bf26b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5d353c3d2196ebe3ec2a9f55bf26b6">&#9670;&#160;</a></span>expand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::expand </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a range on both ends. </p>
<p>Expand a range by decreasing the minimum value as well as increasing the maximum value. If either of the values are already larger or smaller (respectively) than the proposed values, then that particular boundary of the interval is not expanded.</p>
<dl class="section note"><dt>Note</dt><dd>After this operation, the range is always equal to or larger than [min, max].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to expand </td></tr>
    <tr><td class="paramname">min</td><td>The proposed new minimum for the range </td></tr>
    <tr><td class="paramname">max</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2de31b80e6bdc4c80b4d38f782bdaf3e" name="a2de31b80e6bdc4c80b4d38f782bdaf3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de31b80e6bdc4c80b4d38f782bdaf3e">&#9670;&#160;</a></span>expandMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::expandMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a range by increasing the maximum value. </p>
<p>Expand the range by increasing the maximum value. If the given value is smaller than the current maximum (in other words, if the proposed new range would be smaller than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d191f30c404545286b22e4ef1934c81" name="a8d191f30c404545286b22e4ef1934c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d191f30c404545286b22e4ef1934c81">&#9670;&#160;</a></span>expandMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::expandMax </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a range by increasing the maximum value. </p>
<p>Expand the range by increasing the maximum value. If the given value is smaller than the current maximum (in other words, if the proposed new range would be smaller than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to expand </td></tr>
    <tr><td class="paramname">v</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a571cf93c227de6a65683756a0feb5792" name="a571cf93c227de6a65683756a0feb5792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571cf93c227de6a65683756a0feb5792">&#9670;&#160;</a></span>expandMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::expandMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methods for manipulating a range of dimension 1. </p>
<p>Expand a range by decreasing the minimum value</p>
<p>Expand the range by decreasing the minimum value. If the given value is larger than the current minimum (in other words, if the proposed new range would be smaller than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The proposed new minimum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5df879f3df4a752759c3e94136c2c031" name="a5df879f3df4a752759c3e94136c2c031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df879f3df4a752759c3e94136c2c031">&#9670;&#160;</a></span>expandMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::expandMin </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a range by decreasing the minimum value. </p>
<p>Expand the range by decreasing the minimum value. If the given value is larger than the current minimum (in other words, if the proposed new range would be smaller than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to expand </td></tr>
    <tr><td class="paramname">v</td><td>The proposed new minimum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92b3810e5c7843d2d93fae6c1433ccf1" name="a92b3810e5c7843d2d93fae6c1433ccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b3810e5c7843d2d93fae6c1433ccf1">&#9670;&#160;</a></span>max() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::max </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum value of the range (inclusive). </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the maximum value for modification </dd></dl>

</div>
</div>
<a id="ac8963f192a7aa58c111f022c71bf11b0" name="ac8963f192a7aa58c111f022c71bf11b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8963f192a7aa58c111f022c71bf11b0">&#9670;&#160;</a></span>max() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::max </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum value of the range (inclusive). </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of the one-dimensional range </dd></dl>

</div>
</div>
<a id="a635805d8c598f59e5c4a30b3c93fa2a1" name="a635805d8c598f59e5c4a30b3c93fa2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635805d8c598f59e5c4a30b3c93fa2a1">&#9670;&#160;</a></span>max() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::max </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum value of the range <code class="param">i</code> (inclusive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the maximum value for modification </dd></dl>

</div>
</div>
<a id="af2d6631036f001a5be834e4b1e93ca4e" name="af2d6631036f001a5be834e4b1e93ca4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d6631036f001a5be834e4b1e93ca4e">&#9670;&#160;</a></span>max() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::max </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum value of the range <code class="param">i</code> (inclusive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum value of the specified dimension </dd></dl>

</div>
</div>
<a id="a56cc5ab025326b82e7a05cf0b7f7bc39" name="a56cc5ab025326b82e7a05cf0b7f7bc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cc5ab025326b82e7a05cf0b7f7bc39">&#9670;&#160;</a></span>min() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::min </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum value of the range (inclusive). </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the minimum value for modification </dd></dl>

</div>
</div>
<a id="ae5459dfbd483cf2980cc9017fdedbf44" name="ae5459dfbd483cf2980cc9017fdedbf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5459dfbd483cf2980cc9017fdedbf44">&#9670;&#160;</a></span>min() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::min </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum value of the range (inclusive). </p>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of the one-dimensional range </dd></dl>

</div>
</div>
<a id="a706009f7f3ecaadb1acdbfd4f25b0950" name="a706009f7f3ecaadb1acdbfd4f25b0950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706009f7f3ecaadb1acdbfd4f25b0950">&#9670;&#160;</a></span>min() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::min </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum value of the range <code class="param">i</code> (inclusive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the minimum value for modification </dd></dl>

</div>
</div>
<a id="a9cb7df2f26d79a8fb538b9445e30427e" name="a9cb7df2f26d79a8fb538b9445e30427e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb7df2f26d79a8fb538b9445e30427e">&#9670;&#160;</a></span>min() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::min </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the minimum value of the range <code class="param">i</code> (inclusive). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum value of the specified dimension </dd></dl>

</div>
</div>
<a id="af35555a11f8c6c19b711092a0d38d8d3" name="af35555a11f8c6c19b711092a0d38d8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35555a11f8c6c19b711092a0d38d8d3">&#9670;&#160;</a></span>operator&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection of this range with another range. </p>
<p>The intersection of one orthogonal range with another orthogonal range is in itself an orthogonal range. This operation is commutative. This intersection between two n-dimensional ranges is defined simply as the intersection in each dimension of the two ranges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The orthogonal range to compute the intersection with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The intersection between the ranges </dd></dl>

</div>
</div>
<a id="ad1852a418fb2c6ba209bbf54a91941e0" name="ad1852a418fb2c6ba209bbf54a91941e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1852a418fb2c6ba209bbf54a91941e0">&#9670;&#160;</a></span>operator&amp;&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether this range intersects another. </p>
<p>Two n-dimensional ranges intersect if and only if they intersect in every one of their n dimensions. Otherwise, they are disjoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The other range to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The ranges intersect </dd>
<dd>
false The ranges do not intersect </dd></dl>

</div>
</div>
<a id="a826bbc556c8c949e7367ca89482ca901" name="a826bbc556c8c949e7367ca89482ca901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826bbc556c8c949e7367ca89482ca901">&#9670;&#160;</a></span>operator&amp;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the range to the intersection with another range. </p>
<p>This is the assignment version of the operator&amp; method, meaning that it updates the object on which it is called rather than producing a new range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The range to compute the intersection with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This object </dd></dl>

</div>
</div>
<a id="a1f3a7f4fa96404fec2da3de3e7bb75d8" name="a1f3a7f4fa96404fec2da3de3e7bb75d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f3a7f4fa96404fec2da3de3e7bb75d8">&#9670;&#160;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether one range is a subset of another range. </p>
<p>One range is a subset of another range if and only if all points contained within the first set are also contained within the second set. Alternatively, this is equivalent to each of the first range's one-dimensional ranges being a subset of the second range's equivalent one-dimensional range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The other range to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The first range is a subset of the second range </dd>
<dd>
false The first range is not a subset of the second range </dd></dl>

</div>
</div>
<a id="abc4f1093f53aca01984eec8ae5c1ec4f" name="abc4f1093f53aca01984eec8ae5c1ec4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f1093f53aca01984eec8ae5c1ec4f">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
<div class="memtemplate">
template&lt;template&lt; typename, std::size_t &gt; typename V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a> &amp; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Copy the right-hand range into the left-hand range, which means setting the minimum and maximum to equal the minimum and maximum of the right-hand side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The range of values to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This range </dd></dl>

</div>
</div>
<a id="a328d85ac345f9f87d8248ef86176a24f" name="a328d85ac345f9f87d8248ef86176a24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328d85ac345f9f87d8248ef86176a24f">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether two ranges are equal. </p>
<p>Two n-dimensional ranges are equal if and only if they are equal in each of their n dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The other range to check for equality</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The ranges are equal </dd>
<dd>
false The ranges are not equal </dd></dl>

</div>
</div>
<a id="aa49cf0d6080874c2ca714fa48d762d90" name="aa49cf0d6080874c2ca714fa48d762d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49cf0d6080874c2ca714fa48d762d90">&#9670;&#160;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>o</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether one range is a superset of another range. </p>
<p>One range is a superset of another range if and only if all points contained within the second range are also contained within the first range. Alternatively, this is equivalent to each of the one-dimensional ranges in the first range being a superset of the corresponding one-dimensional range in the second range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">o</td><td>The other range to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true The left-hand range is a superset of the right-hand range </dd>
<dd>
false The left-hand range is not a superset of the right-hand range </dd></dl>

</div>
</div>
<a id="abf3e9a2f75444319686469bf05e56262" name="abf3e9a2f75444319686469bf05e56262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3e9a2f75444319686469bf05e56262">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; 1, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, SingleElementContainer &gt; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access one of the dimensional ranges of the volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the dimension contained in this range </dd></dl>

</div>
</div>
<a id="a6caa03a651f57841207e425e1e70d781" name="a6caa03a651f57841207e425e1e70d781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caa03a651f57841207e425e1e70d781">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeec3aae321f39c59debe6164fd8a581b">RangeXD</a>&lt; 1, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &gt; <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>i</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access one of the dimensional ranges of the volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the dimension contained in this range </dd></dl>

</div>
</div>
<a id="a82a8fd5234fed4b3352d76e2a59ad609" name="a82a8fd5234fed4b3352d76e2a59ad609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a8fd5234fed4b3352d76e2a59ad609">&#9670;&#160;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum and maximum value. </p>
<p>Override both the minimum and maximum value of the range, regardless of what they were set to.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to shrink or expand the range, use the shrink and expand methods.</dd>
<dd>
After this operation, the range should be exactly equal to [min, max]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The new minimum value of the range </td></tr>
    <tr><td class="paramname">max</td><td>The new maximum value of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46ac7130dcf84061b62cf2d0a50c4edb" name="a46ac7130dcf84061b62cf2d0a50c4edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ac7130dcf84061b62cf2d0a50c4edb">&#9670;&#160;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum and maximum value. </p>
<p>Override both the minimum and maximum value of the range, regardless of what they were set to.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to shrink or expand the range, use the shrink and expand methods.</dd>
<dd>
After this operation, the range should be exactly equal to [min, max]</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to set </td></tr>
    <tr><td class="paramname">min</td><td>The new minimum value of the range </td></tr>
    <tr><td class="paramname">max</td><td>The new maximum value of the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada55a084918c1c5c9cb56653a9a40107" name="ada55a084918c1c5c9cb56653a9a40107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada55a084918c1c5c9cb56653a9a40107">&#9670;&#160;</a></span>setMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::setMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum value. </p>
<p>Override the maximum value of the range, regardless of what was already set.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to shrink or expand the range, use the shrink and expand methods.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to use as the new maximum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af265f8059ae14ee51e36311c60f6c473" name="af265f8059ae14ee51e36311c60f6c473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af265f8059ae14ee51e36311c60f6c473">&#9670;&#160;</a></span>setMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::setMax </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum value. </p>
<p>Override the maximum value of the range, regardless of what was already set.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to shrink or expand the range, use the shrink and expand methods.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to set </td></tr>
    <tr><td class="paramname">v</td><td>The value to use as the new maximum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2eced262a330adbfc6d3c6b79ab19b2" name="ac2eced262a330adbfc6d3c6b79ab19b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eced262a330adbfc6d3c6b79ab19b2">&#9670;&#160;</a></span>setMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::setMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum value. </p>
<p>Override the minimum value of the range, regardless of what was already set.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to shrink or expand the range, use the shrink and expand methods.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The value to use as the new minimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e2988377da4a4cc7cb23059899096e1" name="a1e2988377da4a4cc7cb23059899096e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2988377da4a4cc7cb23059899096e1">&#9670;&#160;</a></span>setMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::setMin </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the minimum value. </p>
<p>Override the minimum value of the range, regardless of what was already set.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to shrink or expand the range, use the shrink and expand methods.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to set </td></tr>
    <tr><td class="paramname">v</td><td>The value to use as the new minimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7d9d5d5f43705ba6c3b91c6a535c0ef" name="ab7d9d5d5f43705ba6c3b91c6a535c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d9d5d5f43705ba6c3b91c6a535c0ef">&#9670;&#160;</a></span>shrink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::shrink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a range on both ends. </p>
<p>Shrink a range by increasing the minimum value as well as decreasing the maximum value. If either of the values are already smaller or larger (respectively) than the proposed values, then that particular boundary of the interval is not shrunk.</p>
<dl class="section note"><dt>Note</dt><dd>After this operation, the range is always equal to or smaller than [min, max].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>The proposed new minimum for the range </td></tr>
    <tr><td class="paramname">max</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a223fe129e17ccde5425b4ad642ee02cc" name="a223fe129e17ccde5425b4ad642ee02cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223fe129e17ccde5425b4ad642ee02cc">&#9670;&#160;</a></span>shrink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::shrink </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a range on both ends. </p>
<p>Shrink a range by increasing the minimum value as well as decreasing the maximum value. If either of the values are already smaller or larger (respectively) than the proposed values, then that particular boundary of the interval is not shrunk.</p>
<dl class="section note"><dt>Note</dt><dd>After this operation, the range is always equal to or smaller than [min, max].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to shrink </td></tr>
    <tr><td class="paramname">min</td><td>The proposed new minimum for the range </td></tr>
    <tr><td class="paramname">max</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac17f265b111e23903c25bb0103207b81" name="ac17f265b111e23903c25bb0103207b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17f265b111e23903c25bb0103207b81">&#9670;&#160;</a></span>shrinkMax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::shrinkMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a range by decreasing the maximum value. </p>
<p>Shrink the range by decreasing the maximum value. If the given value is larger than the current maximum (in other words, if the proposed new range would be larger than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6e515d38fb1802a972264645b8978c4" name="ae6e515d38fb1802a972264645b8978c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e515d38fb1802a972264645b8978c4">&#9670;&#160;</a></span>shrinkMax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::shrinkMax </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a range by decreasing the maximum value. </p>
<p>Shrink the range by decreasing the maximum value. If the given value is larger than the current maximum (in other words, if the proposed new range would be larger than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to shrink </td></tr>
    <tr><td class="paramname">v</td><td>The proposed new maximum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ffb8110a98325ba67c922d5e39a66f3" name="a6ffb8110a98325ba67c922d5e39a66f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffb8110a98325ba67c922d5e39a66f3">&#9670;&#160;</a></span>shrinkMin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::shrinkMin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a range by increasing the minimum value. </p>
<p>Shrink the range by increasing the minimum value. If the given value is smaller than the current minimum (in other words, if the proposed new range would be larger than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The proposed new minimum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecbcbe0adfd03e9181c0ec800b5d01af" name="aecbcbe0adfd03e9181c0ec800b5d01af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbcbe0adfd03e9181c0ec800b5d01af">&#9670;&#160;</a></span>shrinkMin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::shrinkMin </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrink a range by increasing the minimum value. </p>
<p>Shrink the range by increasing the minimum value. If the given value is smaller than the current minimum (in other words, if the proposed new range would be larger than the current range), this is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the dimension to shrink </td></tr>
    <tr><td class="paramname">v</td><td>The proposed new minimum for the range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fbd8bbc808cf2596871890f6bfa7b69" name="a8fbd8bbc808cf2596871890f6bfa7b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbd8bbc808cf2596871890f6bfa7b69">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a> <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the range. </p>
<p>The size of a range is defined as the difference between the minimum and the maximum. For degenerate ranges, this is zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>Due to the nature of numbers, the result of this function can be somewhat ambiguous. For natural numbers, you could argue that the range [n, n] has size 0 or size 1. In this case we say it has size 0. The uncountable nature of the reals means this doesn't matter for them, but this can be awkward when working with integers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the range </dd></dl>

</div>
</div>
<a id="a9aaa46109fd363f32390f21182f3929d" name="a9aaa46109fd363f32390f21182f3929d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aaa46109fd363f32390f21182f3929d">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Dims, typename <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, template&lt; typename, std::size_t &gt; typename Vector = std::array&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_acts_1_1_range_x_d.html">Acts::RangeXD</a>&lt; Dims, <a class="el" href="namespace_acts.html#a7fc11ee35d17cdf6bb12607b24ef9e7d">Type</a>, Vector &gt;::toString </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represent the range as a string. </p>
<p>This method produces a helpful string that can be used to debug the range if needed. Not really designed to be used in production code.</p>
<dl class="section return"><dt>Returns</dt><dd>A string representing the range </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="class_acts_1_1_range_x_d.html">RangeXD</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
