<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: DD4hep Plugin</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__dd4hep__plugin.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">DD4hep Plugin <div class="ingroups"><a class="el" href="group__plugins.html">Plugins</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepBinningHelpers" id="r_ActsPlugins_3A_3ADD4hepBinningHelpers"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_acts_plugins_1_1_d_d4hep_binning_helpers.html">ActsPlugins::DD4hepBinningHelpers</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepDetectorElement" id="r_ActsPlugins_3A_3ADD4hepDetectorElement"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_plugins_1_1_d_d4hep_detector_element.html">ActsPlugins::DD4hepDetectorElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DetectorElement class implementation for DD4hep geometry.  <a href="class_acts_plugins_1_1_d_d4hep_detector_element.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepDetectorElementExtension" id="r_ActsPlugins_3A_3ADD4hepDetectorElementExtension"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_plugins_1_1_d_d4hep_detector_element_extension.html">ActsPlugins::DD4hepDetectorElementExtension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This extension holds an ACTS detector element belonging to a DD4hep detector element, and synchronizes ownership.  <a href="struct_acts_plugins_1_1_d_d4hep_detector_element_extension.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepDetectorSurfaceFactory" id="r_ActsPlugins_3A_3ADD4hepDetectorSurfaceFactory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_plugins_1_1_d_d4hep_detector_surface_factory.html">ActsPlugins::DD4hepDetectorSurfaceFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory to convert DD4hep DetectorElements into sensitive of passive surfaces which are filled into a Cache object, also the create DD4hepDetector elements are provided.  <a href="class_acts_plugins_1_1_d_d4hep_detector_surface_factory.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepFieldAdapter" id="r_ActsPlugins_3A_3ADD4hepFieldAdapter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_plugins_1_1_d_d4hep_field_adapter.html">ActsPlugins::DD4hepFieldAdapter</a></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepLayerBuilder" id="r_ActsPlugins_3A_3ADD4hepLayerBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html">ActsPlugins::DD4hepLayerBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">build layers of one cylinder-endcap setup from DD4hep input  <a href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepVolumeBuilder" id="r_ActsPlugins_3A_3ADD4hepVolumeBuilder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_plugins_1_1_d_d4hep_volume_builder.html">ActsPlugins::DD4hepVolumeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">build confined TrackingVolumes of one cylinder setup from DD4hep input.  <a href="class_acts_plugins_1_1_d_d4hep_volume_builder.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4fb2db06f0ad15d273ca56a5a909c7d2" id="r_ga4fb2db06f0ad15d273ca56a5a909c7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4fb2db06f0ad15d273ca56a5a909c7d2">ActsPlugins::addCylinderLayerProtoMaterial</a> (dd4hep::DetElement detElement, <a class="el" href="class_acts_1_1_layer.html">Acts::Layer</a> &amp;cylinderLayer, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())</td></tr>
<tr class="memdesc:ga4fb2db06f0ad15d273ca56a5a909c7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to translate DD4hep material to Acts::ISurfaceMaterial.  <br /></td></tr>
<tr class="memitem:gafe331283f4d3c1e7f759bd44896051fa" id="r_gafe331283f4d3c1e7f759bd44896051fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe331283f4d3c1e7f759bd44896051fa">ActsPlugins::addDiscLayerProtoMaterial</a> (dd4hep::DetElement detElement, <a class="el" href="class_acts_1_1_layer.html">Acts::Layer</a> &amp;discLayer, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())</td></tr>
<tr class="memdesc:gafe331283f4d3c1e7f759bd44896051fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to translate DD4hep material to Acts::ISurfaceMaterial.  <br /></td></tr>
<tr class="memitem:gafde2e0859cd41cdc5c8c5b88f302c7c4" id="r_gafde2e0859cd41cdc5c8c5b88f302c7c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafde2e0859cd41cdc5c8c5b88f302c7c4">ActsPlugins::addLayerProtoMaterial</a> (const dd4hep::rec::VariantParameters &amp;params, <a class="el" href="class_acts_1_1_layer.html">Acts::Layer</a> &amp;layer, const std::vector&lt; std::pair&lt; const std::string, <a class="el" href="namespace_acts.html#a3aaee285dd8963f35f05db5e6bf23769">Acts::BinningOption</a> &gt; &gt; &amp;binning, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())</td></tr>
<tr class="memdesc:gafde2e0859cd41cdc5c8c5b88f302c7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to be called for Cylinder and Disc Proto material.  <br /></td></tr>
<tr class="memitem:ga178c8eb6030272e74937c7a337ef45d8" id="r_ga178c8eb6030272e74937c7a337ef45d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga178c8eb6030272e74937c7a337ef45d8">ActsPlugins::collectCompounds_dd4hep</a> (dd4hep::DetElement &amp;detElement, std::vector&lt; dd4hep::DetElement &gt; &amp;compounds)</td></tr>
<tr class="memdesc:ga178c8eb6030272e74937c7a337ef45d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method internally used by convertDD4hepDetector to collect all volumes of a compound detector.  <br /></td></tr>
<tr class="memitem:ga3c99f54853dcba858260d3f1674478cd" id="r_ga3c99f54853dcba858260d3f1674478cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c99f54853dcba858260d3f1674478cd">ActsPlugins::collectLayers_dd4hep</a> (dd4hep::DetElement &amp;detElement, std::vector&lt; dd4hep::DetElement &gt; &amp;layers, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger)</td></tr>
<tr class="memdesc:ga3c99f54853dcba858260d3f1674478cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method internally used by convertDD4hepDetector.  <br /></td></tr>
<tr class="memitem:gad21595c06a72a8d15a45e0bd1210c2bd" id="r_gad21595c06a72a8d15a45e0bd1210c2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad21595c06a72a8d15a45e0bd1210c2bd">ActsPlugins::collectSubDetectors_dd4hep</a> (dd4hep::DetElement &amp;detElement, std::vector&lt; dd4hep::DetElement &gt; &amp;subdetectors, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger)</td></tr>
<tr class="memdesc:gad21595c06a72a8d15a45e0bd1210c2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method internally used by convertDD4hepDetector to collect all sub detectors Sub detector means each 'compound' DetElement or DetElements which are declared as 'isBarrel' or 'isBeampipe' by their extension.  <br /></td></tr>
<tr class="memitem:ga49cc5c92e1a7323a8832f103aba2f002" id="r_ga49cc5c92e1a7323a8832f103aba2f002"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::tuple&lt; <a class="el" href="struct_acts_1_1_directed_proto_axis.html">Acts::DirectedProtoAxis</a>, std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga49cc5c92e1a7323a8832f103aba2f002">ActsPlugins::DD4hepBinningHelpers::convertBinning</a> (const dd4hep::DetElement &amp;dd4hepElement, const std::string &amp;bname)</td></tr>
<tr class="memdesc:ga49cc5c92e1a7323a8832f103aba2f002"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the DD4hep binning into the Acts ProtoAxis.  <br /></td></tr>
<tr class="memitem:gae9a145a4764367377e2b4dda20db5d54" id="r_gae9a145a4764367377e2b4dda20db5d54"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_tracking_geometry.html">Acts::TrackingGeometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9a145a4764367377e2b4dda20db5d54">ActsPlugins::convertDD4hepDetector</a> (dd4hep::DetElement worldDetElement, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger, <a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a> bTypePhi=<a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a>, <a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a> bTypeR=<a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a>, <a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a> bTypeZ=<a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a>, double layerEnvelopeR=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a>, double layerEnvelopeZ=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a>, double defaultLayerThickness=<a class="el" href="namespace_acts_1_1_unit_constants.html#a7c3f2a3f53d19935e2967361613908ba">Acts::UnitConstants::fm</a>, const std::function&lt; void(std::vector&lt; dd4hep::DetElement &gt; &amp;detectors)&gt; &amp;sortSubDetectors=<a class="el" href="#ga50507e288756f412c9c07e600ca63e70">sortDetElementsByID</a>, const <a class="el" href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a> &amp;gctx=<a class="el" href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a>(), std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_material_decorator.html">Acts::IMaterialDecorator</a> &gt; matDecorator=nullptr, std::shared_ptr&lt; const <a class="el" href="struct_acts_1_1_geometry_identifier_hook.html">Acts::GeometryIdentifierHook</a> &gt; geometryIdentifierHook=std::make_shared&lt; <a class="el" href="struct_acts_1_1_geometry_identifier_hook.html">Acts::GeometryIdentifierHook</a> &gt;(), const <a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a9633a63a1d4651058cc56a53b243d747">DD4hepLayerBuilder::ElementFactory</a> &amp;detectorElementFactory=<a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a8c6e7aa914a9dbe361916c5dc8dbf994">DD4hepLayerBuilder::defaultDetectorElementFactory</a>)</td></tr>
<tr class="memdesc:gae9a145a4764367377e2b4dda20db5d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global method which creates the TrackingGeometry from DD4hep input.  <br /></td></tr>
<tr class="memitem:ga4272c37f6492ae4029a34ab24d0723c5" id="r_ga4272c37f6492ae4029a34ab24d0723c5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="group__material.html#gabad517c3d330be68557175bbe3e71402">Acts::ProtoSurfaceMaterial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4272c37f6492ae4029a34ab24d0723c5">ActsPlugins::createProtoMaterial</a> (const dd4hep::rec::VariantParameters &amp;params, const std::string &amp;valueTag, const std::vector&lt; std::pair&lt; const std::string, <a class="el" href="namespace_acts.html#a3aaee285dd8963f35f05db5e6bf23769">Acts::BinningOption</a> &gt; &gt; &amp;binning, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())</td></tr>
<tr class="memdesc:ga4272c37f6492ae4029a34ab24d0723c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to create proto material - to be called from the addProto(...) methods.  <br /></td></tr>
<tr class="memitem:gae2894e2fe6f50d26a5b53721dcbb93c8" id="r_gae2894e2fe6f50d26a5b53721dcbb93c8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_cylinder_volume_helper.html">Acts::CylinderVolumeHelper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2894e2fe6f50d26a5b53721dcbb93c8">ActsPlugins::cylinderVolumeHelper_dd4hep</a> (const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger)</td></tr>
<tr class="memdesc:gae2894e2fe6f50d26a5b53721dcbb93c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method internally used to create a default Acts::CylinderVolumeBuilder.  <br /></td></tr>
<tr class="memitem:ga7a21513ede0d0c5eddded3080b845776" id="r_ga7a21513ede0d0c5eddded3080b845776"><td class="memTemplParams" colspan="2">template&lt;typename value_type&gt; </td></tr>
<tr class="memitem:ga7a21513ede0d0c5eddded3080b845776 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a21513ede0d0c5eddded3080b845776">ActsPlugins::extractSeries</a> (const dd4hep::DetElement &amp;dd4hepElement, const std::string &amp;bname, const value_type &amp;unitConversion=1)</td></tr>
<tr class="memdesc:ga7a21513ede0d0c5eddded3080b845776"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper function to extract a series.  <br /></td></tr>
<tr class="memitem:ga1bed30a08ceff30dcd1c4e306713b9fe" id="r_ga1bed30a08ceff30dcd1c4e306713b9fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Acts::Transform3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1bed30a08ceff30dcd1c4e306713b9fe">ActsPlugins::extractTransform</a> (const dd4hep::DetElement &amp;dd4hepElement, const std::string &amp;bname, const double unitConversion=1.)</td></tr>
<tr class="memdesc:ga1bed30a08ceff30dcd1c4e306713b9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple helper function to extract a transform.  <br /></td></tr>
<tr class="memitem:ga48955c5e01f13d69458605e095d01689" id="r_ga48955c5e01f13d69458605e095d01689"><td class="memTemplParams" colspan="2">template&lt;typename value_type&gt; </td></tr>
<tr class="memitem:ga48955c5e01f13d69458605e095d01689 template"><td class="memItemLeft" align="right" valign="top">value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga48955c5e01f13d69458605e095d01689">ActsPlugins::getAttrValueOr</a> (const dd4hep::xml::Component &amp;node, const std::string &amp;attrName, const value_type &amp;fallbackValue)</td></tr>
<tr class="memdesc:ga48955c5e01f13d69458605e095d01689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to get an attribute with fallback.  <br /></td></tr>
<tr class="memitem:ga597bb2f116d8b7a4461715822706454b" id="r_ga597bb2f116d8b7a4461715822706454b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_plugins_1_1_d_d4hep_layer_builder_1_1_config.html">Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga597bb2f116d8b7a4461715822706454b">ActsPlugins::DD4hepLayerBuilder::getConfiguration</a> () const</td></tr>
<tr class="memdesc:ga597bb2f116d8b7a4461715822706454b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the configuration object  <br /></td></tr>
<tr class="memitem:gad6da5dbdf350e5823cdd3631f821a841" id="r_gad6da5dbdf350e5823cdd3631f821a841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_plugins_1_1_d_d4hep_volume_builder_1_1_config.html">Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad6da5dbdf350e5823cdd3631f821a841">ActsPlugins::DD4hepVolumeBuilder::getConfiguration</a> () const</td></tr>
<tr class="memdesc:gad6da5dbdf350e5823cdd3631f821a841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configuration object.  <br /></td></tr>
<tr class="memitem:ga67f9b56f4d2999ea6c8577c77eeafe2b" id="r_ga67f9b56f4d2999ea6c8577c77eeafe2b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga67f9b56f4d2999ea6c8577c77eeafe2b template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga67f9b56f4d2999ea6c8577c77eeafe2b">ActsPlugins::getParam</a> (const std::string &amp;key, dd4hep::DetElement &amp;elt)</td></tr>
<tr class="memdesc:ga67f9b56f4d2999ea6c8577c77eeafe2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract a parameter value from a dd4hep detector element from VariantParameters.  <br /></td></tr>
<tr class="memitem:gad4f6e5ad9ecf62743a2fe2dbc61b4fc9" id="r_gad4f6e5ad9ecf62743a2fe2dbc61b4fc9"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:gad4f6e5ad9ecf62743a2fe2dbc61b4fc9 template"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4f6e5ad9ecf62743a2fe2dbc61b4fc9">ActsPlugins::getParamOr</a> (const std::string &amp;key, const dd4hep::DetElement &amp;elt, T alternative)</td></tr>
<tr class="memdesc:gad4f6e5ad9ecf62743a2fe2dbc61b4fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a parameter value or an alternative value if either the VariantParameters extension isn't set, or it doesn't contain the demanded key.  <br /></td></tr>
<tr class="memitem:gae3592dd1902fc3df80dc11d936ebcaea" id="r_gae3592dd1902fc3df80dc11d936ebcaea"><td class="memItemLeft" align="right" valign="top">const dd4hep::rec::VariantParameters &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae3592dd1902fc3df80dc11d936ebcaea">ActsPlugins::getParams</a> (const dd4hep::DetElement &amp;elt)</td></tr>
<tr class="memdesc:gae3592dd1902fc3df80dc11d936ebcaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract a VariantParameters instance, const version.  <br /></td></tr>
<tr class="memitem:gaa117bf0249f08dc9c6db548e3752d73b" id="r_gaa117bf0249f08dc9c6db548e3752d73b"><td class="memItemLeft" align="right" valign="top">dd4hep::rec::VariantParameters &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa117bf0249f08dc9c6db548e3752d73b">ActsPlugins::getParams</a> (dd4hep::DetElement &amp;elt)</td></tr>
<tr class="memdesc:gaa117bf0249f08dc9c6db548e3752d73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to extract a VariantParameters instance.  <br /></td></tr>
<tr class="memitem:ga2306eec410eb731b9608df7f40c004b3" id="r_ga2306eec410eb731b9608df7f40c004b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2306eec410eb731b9608df7f40c004b3">ActsPlugins::hasParam</a> (const std::string &amp;key, dd4hep::DetElement &amp;elt)</td></tr>
<tr class="memdesc:ga2306eec410eb731b9608df7f40c004b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a detector element has a key set in its VariantParameters.  <br /></td></tr>
<tr class="memitem:ga8c3a686ae6d25dbf550c9110f880d2b0" id="r_ga8c3a686ae6d25dbf550c9110f880d2b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c3a686ae6d25dbf550c9110f880d2b0">ActsPlugins::hasParams</a> (dd4hep::DetElement &amp;elt)</td></tr>
<tr class="memdesc:ga8c3a686ae6d25dbf550c9110f880d2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a detector element has VariantParameters set.  <br /></td></tr>
<tr class="memitem:gabe16da7b25f0306dbabda811735f3a1f" id="r_gabe16da7b25f0306dbabda811735f3a1f"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe16da7b25f0306dbabda811735f3a1f">ActsPlugins::DD4hepLayerBuilder::identification</a> () const final</td></tr>
<tr class="memdesc:gabe16da7b25f0306dbabda811735f3a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name identification.  <br /></td></tr>
<tr class="memitem:ga3620a08e0965530f23751e306719cd24" id="r_ga3620a08e0965530f23751e306719cd24"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3620a08e0965530f23751e306719cd24">ActsPlugins::DD4hepVolumeBuilder::identification</a> () const final</td></tr>
<tr class="memdesc:ga3620a08e0965530f23751e306719cd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name identification.  <br /></td></tr>
<tr class="memitem:ga50507e288756f412c9c07e600ca63e70" id="r_ga50507e288756f412c9c07e600ca63e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50507e288756f412c9c07e600ca63e70">ActsPlugins::sortDetElementsByID</a> (std::vector&lt; dd4hep::DetElement &gt; &amp;det)</td></tr>
<tr class="memdesc:ga50507e288756f412c9c07e600ca63e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort function which sorts dd4hep::DetElement by their ID.  <br /></td></tr>
<tr class="memitem:ga64cb99b8e5651412983806dc65ec396c" id="r_ga64cb99b8e5651412983806dc65ec396c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga64cb99b8e5651412983806dc65ec396c">ActsPlugins::stringToAxisDirection</a> (const std::string &amp;binningString)</td></tr>
<tr class="memdesc:ga64cb99b8e5651412983806dc65ec396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to convert the string to binning value.  <br /></td></tr>
<tr class="memitem:ga3079ad3a90242ce1bbf9c4d76c091dbc" id="r_ga3079ad3a90242ce1bbf9c4d76c091dbc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3079ad3a90242ce1bbf9c4d76c091dbc">ActsPlugins::stringToAxisDirections</a> (const std::string &amp;binningString, const char &amp;del=',')</td></tr>
<tr class="memdesc:ga3079ad3a90242ce1bbf9c4d76c091dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method to cenvert a binning list string to a vector of binning values e.g.  <br /></td></tr>
<tr class="memitem:gab5ff22deaf2206ac743a1d6d1ebef441" id="r_gab5ff22deaf2206ac743a1d6d1ebef441"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_cylinder_volume_builder.html">Acts::CylinderVolumeBuilder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5ff22deaf2206ac743a1d6d1ebef441">ActsPlugins::volumeBuilder_dd4hep</a> (dd4hep::DetElement subDetector, const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;logger, <a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a> bTypePhi=<a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a>, <a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a> bTypeR=<a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a>, <a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a> bTypeZ=<a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a>, double layerEnvelopeR=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a>, double layerEnvelopeZ=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a>, double defaultLayerThickness=<a class="el" href="namespace_acts_1_1_unit_constants.html#a7c3f2a3f53d19935e2967361613908ba">Acts::UnitConstants::fm</a>, const <a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a9633a63a1d4651058cc56a53b243d747">DD4hepLayerBuilder::ElementFactory</a> &amp;detectorElementFactory=<a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a8c6e7aa914a9dbe361916c5dc8dbf994">DD4hepLayerBuilder::defaultDetectorElementFactory</a>)</td></tr>
<tr class="memdesc:gab5ff22deaf2206ac743a1d6d1ebef441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method internally used to create an Acts::CylinderVolumeBuilder.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaaf696f8070f1f3990ead852282a1b33e" id="r_gaaf696f8070f1f3990ead852282a1b33e"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; std::tuple&lt; std::string, <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf696f8070f1f3990ead852282a1b33e">ActsPlugins::allowedBinnings</a></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga4fb2db06f0ad15d273ca56a5a909c7d2" name="ga4fb2db06f0ad15d273ca56a5a909c7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb2db06f0ad15d273ca56a5a909c7d2">&#9670;&#160;</a></span>addCylinderLayerProtoMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::addCylinderLayerProtoMaterial </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement</td>          <td class="paramname"><span class="paramname"><em>detElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_layer.html">Acts::Layer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cylinderLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to translate DD4hep material to Acts::ISurfaceMaterial. </p>
<p>This is used to assign proto material to Cylinder Layers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detElement</td><td>the DD4hep detector element for which this material is assigned </td></tr>
    <tr><td class="paramname">cylinderLayer</td><td>is the target layer </td></tr>
    <tr><td class="paramname">logger</td><td>a <code>Logger</code> for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe331283f4d3c1e7f759bd44896051fa" name="gafe331283f4d3c1e7f759bd44896051fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe331283f4d3c1e7f759bd44896051fa">&#9670;&#160;</a></span>addDiscLayerProtoMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::addDiscLayerProtoMaterial </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement</td>          <td class="paramname"><span class="paramname"><em>detElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_layer.html">Acts::Layer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>discLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to translate DD4hep material to Acts::ISurfaceMaterial. </p>
<p>Thisis used to assign proto material to Disc Layers</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detElement</td><td>the DD4hep detector element for which this material is assigned </td></tr>
    <tr><td class="paramname">discLayer</td><td>is the target layer </td></tr>
    <tr><td class="paramname">logger</td><td>a <code>Logger</code> for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafde2e0859cd41cdc5c8c5b88f302c7c4" name="gafde2e0859cd41cdc5c8c5b88f302c7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafde2e0859cd41cdc5c8c5b88f302c7c4">&#9670;&#160;</a></span>addLayerProtoMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::addLayerProtoMaterial </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::rec::VariantParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_layer.html">Acts::Layer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; const std::string, <a class="el" href="namespace_acts.html#a3aaee285dd8963f35f05db5e6bf23769">Acts::BinningOption</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binning</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to be called for Cylinder and Disc Proto material. </p>
<p>For both, cylinder and disc, the closed binning value is "binPhi"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An instance of <code>DD4hep::VariantParameters</code> </td></tr>
    <tr><td class="paramname">layer</td><td>the Layer to assign the proto material </td></tr>
    <tr><td class="paramname">binning</td><td>the Binning prescription for the ActsExtension </td></tr>
    <tr><td class="paramname">logger</td><td>a <code>Logger</code> for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga178c8eb6030272e74937c7a337ef45d8" name="ga178c8eb6030272e74937c7a337ef45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga178c8eb6030272e74937c7a337ef45d8">&#9670;&#160;</a></span>collectCompounds_dd4hep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::collectCompounds_dd4hep </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>detElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; dd4hep::DetElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>compounds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method internally used by convertDD4hepDetector to collect all volumes of a compound detector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">detElement</td><td>the dd4hep::DetElement of the volume of which the compounds should be collected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">compounds</td><td>the DD4hep::DetElements of the compounds contained by detElement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c99f54853dcba858260d3f1674478cd" name="ga3c99f54853dcba858260d3f1674478cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c99f54853dcba858260d3f1674478cd">&#9670;&#160;</a></span>collectLayers_dd4hep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::collectLayers_dd4hep </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>detElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; dd4hep::DetElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>layers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method internally used by convertDD4hepDetector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">detElement</td><td>the dd4hep::DetElement of the volume of which the layers should be collected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layers</td><td>the DD4hep::DetElements of the layers contained by detElement </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logger</td><td>a <code>Logger</code> for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad21595c06a72a8d15a45e0bd1210c2bd" name="gad21595c06a72a8d15a45e0bd1210c2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad21595c06a72a8d15a45e0bd1210c2bd">&#9670;&#160;</a></span>collectSubDetectors_dd4hep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::collectSubDetectors_dd4hep </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>detElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; dd4hep::DetElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>subdetectors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method internally used by convertDD4hepDetector to collect all sub detectors Sub detector means each 'compound' DetElement or DetElements which are declared as 'isBarrel' or 'isBeampipe' by their extension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">detElement</td><td>the dd4hep::DetElement of the volume of which the sub detectors should be collected </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subdetectors</td><td>the DD4hep::DetElements of the sub detectors contained by detElement </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">logger</td><td>a <code>Logger</code> for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49cc5c92e1a7323a8832f103aba2f002" name="ga49cc5c92e1a7323a8832f103aba2f002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49cc5c92e1a7323a8832f103aba2f002">&#9670;&#160;</a></span>convertBinning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::tuple&lt; <a class="el" href="struct_acts_1_1_directed_proto_axis.html">Acts::DirectedProtoAxis</a>, std::size_t &gt; &gt; ActsPlugins::DD4hepBinningHelpers::convertBinning </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>dd4hepElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>bname</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the DD4hep binning into the Acts ProtoAxis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd4hepElement</td><td>the element which has a binning description attached </td></tr>
    <tr><td class="paramname">bname</td><td>the binning base name, e.g. surface_binning, material_binning</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of proto binning descriptions </dd></dl>

</div>
</div>
<a id="gae9a145a4764367377e2b4dda20db5d54" name="gae9a145a4764367377e2b4dda20db5d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a145a4764367377e2b4dda20db5d54">&#9670;&#160;</a></span>convertDD4hepDetector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; const <a class="el" href="class_acts_1_1_tracking_geometry.html">Acts::TrackingGeometry</a> &gt; ActsPlugins::convertDD4hepDetector </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement</td>          <td class="paramname"><span class="paramname"><em>worldDetElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>          <td class="paramname"><span class="paramname"><em>bTypePhi</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>          <td class="paramname"><span class="paramname"><em>bTypeR</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>          <td class="paramname"><span class="paramname"><em>bTypeZ</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>layerEnvelopeR</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>layerEnvelopeZ</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>defaultLayerThickness</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a7c3f2a3f53d19935e2967361613908ba">Acts::UnitConstants::fm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(std::vector&lt; dd4hep::DetElement &gt; &amp;detectors)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sortSubDetectors</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ga50507e288756f412c9c07e600ca63e70">sortDetElementsByID</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_1_1_geometry_context.html">Acts::GeometryContext</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_material_decorator.html">Acts::IMaterialDecorator</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>matDecorator</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="struct_acts_1_1_geometry_identifier_hook.html">Acts::GeometryIdentifierHook</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>geometryIdentifierHook</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::make_shared&lt;&#160;<a class="el" href="struct_acts_1_1_geometry_identifier_hook.html">Acts::GeometryIdentifierHook</a>&#160;&gt;()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a9633a63a1d4651058cc56a53b243d747">DD4hepLayerBuilder::ElementFactory</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>detectorElementFactory</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a8c6e7aa914a9dbe361916c5dc8dbf994">DD4hepLayerBuilder::defaultDetectorElementFactory</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global method which creates the TrackingGeometry from DD4hep input. </p>
<p>This method returns a std::unique_ptr of the TrackingGeometry from the World DD4hep <em class="arg">DetElement</em>. </p><dl class="section pre"><dt>Precondition</dt><dd>Before using this method make sure, that the preconditions described in DD4hepPlugins are met.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worldDetElement</td><td>the DD4hep DetElement of the world </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logger</td><td>A logger instance geometry building </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bTypePhi</td><td>is how the sensitive surfaces (modules) should be binned in a layer in phi direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Possible binningtypes:<ul>
<li>arbitrary - of the sizes if the surfaces and the distance in between vary. This mode finds out the bin boundaries by scanning through the surfaces.</li>
<li>equidistant - if the sensitive surfaces are placed equidistantly </li>
</ul>
</dd>
<dd>
equidistant binningtype is recommended because it is faster not only while building the geometry but also for look up during the extrapolation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bTypeR</td><td>is how the sensitive surfaces (modules) should be binned in a layer in r direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bTypeZ</td><td>is how the sensitive surfaces (modules) should be binned in a layer in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerEnvelopeR</td><td>the tolerance added to the geometrical extension in r of the layers contained to build the volume envelope around </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerEnvelopeZ</td><td>the tolerance added to the geometrical extension in z of the layers contained to build the volume envelope around </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultLayerThickness</td><td>In case no surfaces (to be contained by the layer) are handed over, the layer thickness will be set to this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Layers containing surfaces per default are not allowed to be attached to each other (navigation will fail at this point). However, to allow material layers (not containing surfaces) to be attached to each other, this default thickness is needed. In this way, the layer will be thin (with space to the next layer), but the material will have the 'real' thickness. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>The default thickness should be set thin enough that no touching or overlapping with the next layer can happen. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sortSubDetectors</td><td><code>std::function</code> which should be used in order to sort all sub detectors (=all Detelements collected by the method <code>collectSubDetectors()</code> ) from bottom to top to ensure correct wrapping of the volumes, which is needed for navigation. Therefore the different hierarchies need to be sorted ascending. The default is sorting by ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">gctx</td><td>The geometry context to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">matDecorator</td><td>is the material decorator that loads material maps </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">geometryIdentifierHook</td><td>Hook to apply to surfaces during geometry closure. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">detectorElementFactory</td><td>Factory function to create ActsPlugins::DD4hepDetectorElement or derived classes</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if an error in the translation occurs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::unique_ptr to the full TrackingGeometry<ul>
<li>The Tracking geometry needs to be built from bottom to top to ensure Navigation. Therefore the different hierarchies need to be sorted ascending. Per default the sub detectors are sorted by the id of their dd4hep::DetElement. In case another sorting needs to be applied, the users can provide their own function </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4272c37f6492ae4029a34ab24d0723c5" name="ga4272c37f6492ae4029a34ab24d0723c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4272c37f6492ae4029a34ab24d0723c5">&#9670;&#160;</a></span>createProtoMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="group__material.html#gabad517c3d330be68557175bbe3e71402">Acts::ProtoSurfaceMaterial</a> &gt; ActsPlugins::createProtoMaterial </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::rec::VariantParameters &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>valueTag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; const std::string, <a class="el" href="namespace_acts.html#a3aaee285dd8963f35f05db5e6bf23769">Acts::BinningOption</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>binning</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to create proto material - to be called from the addProto(...) methods. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An instance of <code>DD4hep::VariantParameters</code> </td></tr>
    <tr><td class="paramname">valueTag</td><td>the xml tag for to ActsExtension to be parsed </td></tr>
    <tr><td class="paramname">binning</td><td>the Binning prescription for the ActsExtension </td></tr>
    <tr><td class="paramname">logger</td><td>a <code>Logger</code> for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to ProtoSurfaceMaterial created from DD4hep parameters </dd></dl>

</div>
</div>
<a id="gae2894e2fe6f50d26a5b53721dcbb93c8" name="gae2894e2fe6f50d26a5b53721dcbb93c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2894e2fe6f50d26a5b53721dcbb93c8">&#9670;&#160;</a></span>cylinderVolumeHelper_dd4hep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_cylinder_volume_helper.html">Acts::CylinderVolumeHelper</a> &gt; ActsPlugins::cylinderVolumeHelper_dd4hep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method internally used to create a default Acts::CylinderVolumeBuilder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>Logging instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to CylinderVolumeHelper </dd></dl>

</div>
</div>
<a id="ga7a21513ede0d0c5eddded3080b845776" name="ga7a21513ede0d0c5eddded3080b845776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a21513ede0d0c5eddded3080b845776">&#9670;&#160;</a></span>extractSeries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; value_type &gt; ActsPlugins::extractSeries </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>dd4hepElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>bname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>unitConversion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple helper function to extract a series. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>the primitive type allowed by variant parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd4hepElement</td><td>the detector element with associated variant parameters </td></tr>
    <tr><td class="paramname">bname</td><td>The base name attribute of the variant parameter pack </td></tr>
    <tr><td class="paramname">unitConversion</td><td>is a conversion factor DD4hep -&gt; ACTS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the extracted series as a vector </dd></dl>

</div>
</div>
<a id="ga1bed30a08ceff30dcd1c4e306713b9fe" name="ga1bed30a08ceff30dcd1c4e306713b9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bed30a08ceff30dcd1c4e306713b9fe">&#9670;&#160;</a></span>extractTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Acts::Transform3</a> ActsPlugins::extractTransform </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>dd4hepElement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>bname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>unitConversion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple helper function to extract a transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dd4hepElement</td><td>the detector element with associated variant parameters </td></tr>
    <tr><td class="paramname">bname</td><td>The base name attribute of the variant parameter pack </td></tr>
    <tr><td class="paramname">unitConversion</td><td>is a conversion factor DD4hep -&gt; ACTS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a transform extracted from parameters </dd></dl>

</div>
</div>
<a id="ga48955c5e01f13d69458605e095d01689" name="ga48955c5e01f13d69458605e095d01689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48955c5e01f13d69458605e095d01689">&#9670;&#160;</a></span>getAttrValueOr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_type ActsPlugins::getAttrValueOr </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::xml::Component &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>attrName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;</td>          <td class="paramname"><span class="paramname"><em>fallbackValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to get an attribute with fallback. </p>
<dl class="section note"><dt>Note</dt><dd>the fallback value has to be provided</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td>the primitive type allowed by variant parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node object from DD4hep </td></tr>
    <tr><td class="paramname">attrName</td><td>the name of the attribute that is checked </td></tr>
    <tr><td class="paramname">fallbackValue</td><td>the fallbackValue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>either the gathered attribute or the fallback </dd></dl>

</div>
</div>
<a id="ga597bb2f116d8b7a4461715822706454b" name="ga597bb2f116d8b7a4461715822706454b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga597bb2f116d8b7a4461715822706454b">&#9670;&#160;</a></span>getConfiguration() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_plugins_1_1_d_d4hep_layer_builder_1_1_config.html">DD4hepLayerBuilder::Config</a> ActsPlugins::DD4hepLayerBuilder::getConfiguration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the configuration object </p>
<dl class="section return"><dt>Returns</dt><dd>Copy of the current configuration </dd></dl>

</div>
</div>
<a id="gad6da5dbdf350e5823cdd3631f821a841" name="gad6da5dbdf350e5823cdd3631f821a841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6da5dbdf350e5823cdd3631f821a841">&#9670;&#160;</a></span>getConfiguration() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_plugins_1_1_d_d4hep_volume_builder_1_1_config.html">DD4hepVolumeBuilder::Config</a> ActsPlugins::DD4hepVolumeBuilder::getConfiguration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the configuration object. </p>
<dl class="section return"><dt>Returns</dt><dd>The used configuration struct </dd></dl>

</div>
</div>
<a id="ga67f9b56f4d2999ea6c8577c77eeafe2b" name="ga67f9b56f4d2999ea6c8577c77eeafe2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67f9b56f4d2999ea6c8577c77eeafe2b">&#9670;&#160;</a></span>getParam()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ActsPlugins::getParam </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>elt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to extract a parameter value from a dd4hep detector element from VariantParameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the value to extract </td></tr>
    <tr><td class="paramname">elt</td><td>The detector element instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the value contained in the params instance </dd></dl>

</div>
</div>
<a id="gad4f6e5ad9ecf62743a2fe2dbc61b4fc9" name="gad4f6e5ad9ecf62743a2fe2dbc61b4fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f6e5ad9ecf62743a2fe2dbc61b4fc9">&#9670;&#160;</a></span>getParamOr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T ActsPlugins::getParamOr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>elt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>alternative</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a parameter value or an alternative value if either the VariantParameters extension isn't set, or it doesn't contain the demanded key. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the value to extract </td></tr>
    <tr><td class="paramname">elt</td><td>The detector element instance </td></tr>
    <tr><td class="paramname">alternative</td><td>The value to return if no params are set of the key doesn't exist </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value behind key, or <code class="param">alternative</code> </dd></dl>

</div>
</div>
<a id="gae3592dd1902fc3df80dc11d936ebcaea" name="gae3592dd1902fc3df80dc11d936ebcaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3592dd1902fc3df80dc11d936ebcaea">&#9670;&#160;</a></span>getParams() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const dd4hep::rec::VariantParameters &amp; ActsPlugins::getParams </td>
          <td>(</td>
          <td class="paramtype">const dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>elt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to extract a VariantParameters instance, const version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>The detector element instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The VariantParameters instance </dd></dl>

</div>
</div>
<a id="gaa117bf0249f08dc9c6db548e3752d73b" name="gaa117bf0249f08dc9c6db548e3752d73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa117bf0249f08dc9c6db548e3752d73b">&#9670;&#160;</a></span>getParams() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dd4hep::rec::VariantParameters &amp; ActsPlugins::getParams </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>elt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to extract a VariantParameters instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>The detector element instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The VariantParameters instance </dd></dl>

</div>
</div>
<a id="ga2306eec410eb731b9608df7f40c004b3" name="ga2306eec410eb731b9608df7f40c004b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2306eec410eb731b9608df7f40c004b3">&#9670;&#160;</a></span>hasParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActsPlugins::hasParam </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>elt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a detector element has a key set in its VariantParameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to check existence for </td></tr>
    <tr><td class="paramname">elt</td><td>The detector element instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element has VariantParameters and the key exists, false if either of these is not true </dd></dl>

</div>
</div>
<a id="ga8c3a686ae6d25dbf550c9110f880d2b0" name="ga8c3a686ae6d25dbf550c9110f880d2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c3a686ae6d25dbf550c9110f880d2b0">&#9670;&#160;</a></span>hasParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ActsPlugins::hasParams </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement &amp;</td>          <td class="paramname"><span class="paramname"><em>elt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a detector element has VariantParameters set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt</td><td>The detector element instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the VariantParameters exist, false if not </dd></dl>

</div>
</div>
<a id="gabe16da7b25f0306dbabda811735f3a1f" name="gabe16da7b25f0306dbabda811735f3a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe16da7b25f0306dbabda811735f3a1f">&#9670;&#160;</a></span>identification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ActsPlugins::DD4hepLayerBuilder::identification </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel final">final</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name identification. </p>
<dl class="section return"><dt>Returns</dt><dd>the string based identification of this configuration </dd></dl>

<p>Implements <a class="el" href="class_acts_1_1_i_layer_builder.html#a4c8c3e7a615e13c3695bea611184d9bc">Acts::ILayerBuilder</a>.</p>

</div>
</div>
<a id="ga3620a08e0965530f23751e306719cd24" name="ga3620a08e0965530f23751e306719cd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3620a08e0965530f23751e306719cd24">&#9670;&#160;</a></span>identification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; ActsPlugins::DD4hepVolumeBuilder::identification </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel final">final</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name identification. </p>
<dl class="section return"><dt>Returns</dt><dd>The string based identification of this configuration </dd></dl>

<p>Implements <a class="el" href="class_acts_1_1_i_confined_tracking_volume_builder.html#a4a2d09204dd5ded1412303b6d70488e9">Acts::IConfinedTrackingVolumeBuilder</a>.</p>

</div>
</div>
<a id="ga50507e288756f412c9c07e600ca63e70" name="ga50507e288756f412c9c07e600ca63e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50507e288756f412c9c07e600ca63e70">&#9670;&#160;</a></span>sortDetElementsByID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ActsPlugins::sortDetElementsByID </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; dd4hep::DetElement &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>det</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort function which sorts dd4hep::DetElement by their ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">det</td><td>the dd4hep::DetElements to be sorted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64cb99b8e5651412983806dc65ec396c" name="ga64cb99b8e5651412983806dc65ec396c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64cb99b8e5651412983806dc65ec396c">&#9670;&#160;</a></span>stringToAxisDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> ActsPlugins::stringToAxisDirection </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>binningString</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to convert the string to binning value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binningString</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a binningValue </dd></dl>

</div>
</div>
<a id="ga3079ad3a90242ce1bbf9c4d76c091dbc" name="ga3079ad3a90242ce1bbf9c4d76c091dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3079ad3a90242ce1bbf9c4d76c091dbc">&#9670;&#160;</a></span>stringToAxisDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a> &gt; ActsPlugins::stringToAxisDirections </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>binningString</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;</td>          <td class="paramname"><span class="paramname"><em>del</em></span><span class="paramdefsep"> = </span><span class="paramdefval">','</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method to cenvert a binning list string to a vector of binning values e.g. </p>
<p>"r,z" -&gt; {AxisR, AxisZ}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binningString</td><td></td></tr>
    <tr><td class="paramname">del</td><td>the delimiter for the splitting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of binninng values </dd></dl>

</div>
</div>
<a id="gab5ff22deaf2206ac743a1d6d1ebef441" name="gab5ff22deaf2206ac743a1d6d1ebef441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ff22deaf2206ac743a1d6d1ebef441">&#9670;&#160;</a></span>volumeBuilder_dd4hep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_cylinder_volume_builder.html">Acts::CylinderVolumeBuilder</a> &gt; ActsPlugins::volumeBuilder_dd4hep </td>
          <td>(</td>
          <td class="paramtype">dd4hep::DetElement</td>          <td class="paramname"><span class="paramname"><em>subDetector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Acts::Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>          <td class="paramname"><span class="paramname"><em>bTypePhi</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>          <td class="paramname"><span class="paramname"><em>bTypeR</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81">Acts::BinningType</a></td>          <td class="paramname"><span class="paramname"><em>bTypeZ</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a137e6814b0021a40f572aeb4922a7b81a04ff25f891b11a721d2e600256a072fe">Acts::equidistant</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>layerEnvelopeR</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>layerEnvelopeZ</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">Acts::UnitConstants::mm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>defaultLayerThickness</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a7c3f2a3f53d19935e2967361613908ba">Acts::UnitConstants::fm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a9633a63a1d4651058cc56a53b243d747">DD4hepLayerBuilder::ElementFactory</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>detectorElementFactory</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_plugins_1_1_d_d4hep_layer_builder.html#a8c6e7aa914a9dbe361916c5dc8dbf994">DD4hepLayerBuilder::defaultDetectorElementFactory</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method internally used to create an Acts::CylinderVolumeBuilder. </p>
<p>This method creates an Acts::CylinderVolumeBuilder from a sub detector (= 'compound' DetElement or DetElements which are declared as 'isBarrel' or 'isBeampipe' by their extension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subDetector</td><td>the DD4hep DetElement of the subdetector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logger</td><td>A logger instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bTypePhi</td><td>is how the sensitive surfaces (modules) should be binned in a layer in phi direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Possible binningtypes:<ul>
<li>arbitrary - of the sizes if the surfaces and the distance in between vary. This mode finds out the bin boundaries by scanning through the surfaces.</li>
<li>equidistant - if the sensitive surfaces are placed equidistantly </li>
</ul>
</dd>
<dd>
equidistant binningtype is recommended because it is faster not only while building the geometry but also for look up during the extrapolation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bTypeR</td><td>is how the sensitive surfaces (modules) should be binned in a layer in r direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bTypeZ</td><td>is how the sensitive surfaces (modules) should be binned in a layer in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerEnvelopeR</td><td>the tolerance added to the geometrical extension in r of the layers contained to build the volume envelope around </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layerEnvelopeZ</td><td>the tolerance added to the geometrical extension in z of the layers contained to build the volume envelope around </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultLayerThickness</td><td>In case no surfaces (to be contained by the layer) are handed over, the layer thickness will be set to this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Layers containing surfaces per default are not allowed to be attached to each other (navigation will fail at this point). However, to allow material layers (not containing surfaces) to be attached to each other, this default thickness is needed. In this way, the layer will be thin (with space to the next layer), but the material will have the 'real' thickness. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detectorElementFactory</td><td>Factory function to create ActsPlugins::DD4hepDetectorElement or derived classes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>The default thickness should be set thin enough that no touching or overlapping with the next layer can happen. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr the Acts::CylinderVolumeBuilder which can be used to build the full tracking geometry </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="gaaf696f8070f1f3990ead852282a1b33e" name="gaaf696f8070f1f3990ead852282a1b33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf696f8070f1f3990ead852282a1b33e">&#9670;&#160;</a></span>allowedBinnings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::tuple&lt;std::string, <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">Acts::AxisDirection</a>&gt; &gt; ActsPlugins::allowedBinnings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {{<span class="stringliteral">&quot;x&quot;</span>, <a class="code hl_enumvalue" href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaa38b0844100a915cd3c87159b391161b9">Acts::AxisDirection::AxisX</a>},</div>
<div class="line">                       {<span class="stringliteral">&quot;y&quot;</span>, <a class="code hl_enumvalue" href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaab30a50c686982b3b209cf1234f4247cd">Acts::AxisDirection::AxisY</a>},</div>
<div class="line">                       {<span class="stringliteral">&quot;z&quot;</span>, <a class="code hl_enumvalue" href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaadd1071c1aa89157c2386d3303413218f">Acts::AxisDirection::AxisZ</a>},</div>
<div class="line">                       {<span class="stringliteral">&quot;phi&quot;</span>, <a class="code hl_enumvalue" href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaa767ac49408b49422cdfdfa90582e7c50">Acts::AxisDirection::AxisPhi</a>},</div>
<div class="line">                       {<span class="stringliteral">&quot;r&quot;</span>, <a class="code hl_enumvalue" href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaa66964a770b69520967ff845d6a141d7b">Acts::AxisDirection::AxisR</a>}}</div>
<div class="ttc" id="anamespace_acts_html_a1462738699cb376ae92c59811987f4eaa38b0844100a915cd3c87159b391161b9"><div class="ttname"><a href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaa38b0844100a915cd3c87159b391161b9">Acts::AxisDirection::AxisX</a></div><div class="ttdeci">@ AxisX</div><div class="ttdoc">AxisX, AxisY, AxisZ are the cartesian directions in the local frame.</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:20</div></div>
<div class="ttc" id="anamespace_acts_html_a1462738699cb376ae92c59811987f4eaa66964a770b69520967ff845d6a141d7b"><div class="ttname"><a href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaa66964a770b69520967ff845d6a141d7b">Acts::AxisDirection::AxisR</a></div><div class="ttdeci">@ AxisR</div><div class="ttdoc">AxisR is a radial direction.</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:24</div></div>
<div class="ttc" id="anamespace_acts_html_a1462738699cb376ae92c59811987f4eaa767ac49408b49422cdfdfa90582e7c50"><div class="ttname"><a href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaa767ac49408b49422cdfdfa90582e7c50">Acts::AxisDirection::AxisPhi</a></div><div class="ttdeci">@ AxisPhi</div><div class="ttdoc">AxisPhi is the azimuthal direction.</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:26</div></div>
<div class="ttc" id="anamespace_acts_html_a1462738699cb376ae92c59811987f4eaab30a50c686982b3b209cf1234f4247cd"><div class="ttname"><a href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaab30a50c686982b3b209cf1234f4247cd">Acts::AxisDirection::AxisY</a></div><div class="ttdeci">@ AxisY</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:21</div></div>
<div class="ttc" id="anamespace_acts_html_a1462738699cb376ae92c59811987f4eaadd1071c1aa89157c2386d3303413218f"><div class="ttname"><a href="namespace_acts.html#a1462738699cb376ae92c59811987f4eaadd1071c1aa89157c2386d3303413218f">Acts::AxisDirection::AxisZ</a></div><div class="ttdeci">@ AxisZ</div><div class="ttdef"><b>Definition</b> AxisDefinitions.hpp:22</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
