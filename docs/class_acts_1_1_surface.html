<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::Surface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_surface.html','','class_acts_1_1_surface-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::Surface Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Abstract Base Class for tracking surfaces.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_surface_8hpp_source.html">Acts/Surfaces/Surface.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::Surface:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_surface__inherit__graph.svg" width="100%" height="512"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Acts::Surface:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_surface__coll__graph.svg" width="100%" height="600"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a34fd1452f7603ef1f072d3c3233f9ba0" id="r_a34fd1452f7603ef1f072d3c3233f9ba0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0">SurfaceType</a> { <br />
&#160;&#160;<a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a9500807f494fea928b0c02c6831b1bc6">Cone</a> = 0
, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0aa997f5ccb5150365e8622161d610f575">Cylinder</a> = 1
, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a1ba44d6d20145ae45ddb87f1dfccf304">Disc</a> = 2
, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a362560c9d54c69a04d76d1858201bec4">Perigee</a> = 3
, <br />
&#160;&#160;<a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a0ef417dbcfa7c48e3fe8cbc6648e33a6">Plane</a> = 4
, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0aa9597db8c0f4c9506c4d01d7f42de005">Straw</a> = 5
, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a8cae7f38a5912d7b4e5399e6238d8b4f">Curvilinear</a> = 6
, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a5ce17ecad7b6bed89667ea05c9b618bc">Other</a> = 7
<br />
 }</td></tr>
<tr class="memdesc:a34fd1452f7603ef1f072d3c3233f9ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enumerator simplifies the persistency &amp; calculations, by saving a dynamic_cast, e.g.  <a href="#a34fd1452f7603ef1f072d3c3233f9ba0">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a730e3e090bbc441e4bd2891cbae84f15" id="r_a730e3e090bbc441e4bd2891cbae84f15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a730e3e090bbc441e4bd2891cbae84f15">~Surface</a> () noexcept override</td></tr>
<tr class="memitem:a26b77cdb1dedf4fb87e4702f562106e3" id="r_a26b77cdb1dedf4fb87e4702f562106e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#afb10c5cb981e8a26821fd8afafc6d10f">AlignmentToBoundMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26b77cdb1dedf4fb87e4702f562106e3">alignmentToBoundDerivative</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction, const <a class="el" href="namespace_acts.html#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;pathDerivative) const</td></tr>
<tr class="memdesc:a26b77cdb1dedf4fb87e4702f562106e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The derivative of bound track parameters w.r.t.  <br /></td></tr>
<tr class="memitem:ac94e8ed380531243a14c6de82bd11f9e" id="r_ac94e8ed380531243a14c6de82bd11f9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_acts.html#ab42a56895184458a0c2b4de6f112469b">AlignmentToPathMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac94e8ed380531243a14c6de82bd11f9e">alignmentToPathDerivative</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const</td></tr>
<tr class="memdesc:ac94e8ed380531243a14c6de82bd11f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the derivative of path length at the geometry constraint or point-of-closest-approach w.r.t.  <br /></td></tr>
<tr class="memitem:a44604fa05382ea7e7a6663a9a89a2bf1" id="r_a44604fa05382ea7e7a6663a9a89a2bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44604fa05382ea7e7a6663a9a89a2bf1">assignDetectorElement</a> (const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> &amp;detelement)</td></tr>
<tr class="memdesc:a44604fa05382ea7e7a6663a9a89a2bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a detector element.  <br /></td></tr>
<tr class="memitem:af524db996f2812448cc76b37e2f93dde" id="r_af524db996f2812448cc76b37e2f93dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af524db996f2812448cc76b37e2f93dde">assignSurfaceMaterial</a> (std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> &gt; material)</td></tr>
<tr class="memdesc:af524db996f2812448cc76b37e2f93dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the surface material description.  <br /></td></tr>
<tr class="memitem:a0bc21b77bca942e751f73e347968ec9d" id="r_a0bc21b77bca942e751f73e347968ec9d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc21b77bca942e751f73e347968ec9d">associatedDetectorElement</a> () const</td></tr>
<tr class="memdesc:a0bc21b77bca942e751f73e347968ec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the associated Detector Element.  <br /></td></tr>
<tr class="memitem:ac900594dda62ce72431c6db2143b7611" id="r_ac900594dda62ce72431c6db2143b7611"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac900594dda62ce72431c6db2143b7611">associatedLayer</a> () const</td></tr>
<tr class="memdesc:ac900594dda62ce72431c6db2143b7611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the associated Layer in which the surface is embedded.  <br /></td></tr>
<tr class="memitem:af63ca99fc18acd61dee8454d13940ed3" id="r_af63ca99fc18acd61dee8454d13940ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af63ca99fc18acd61dee8454d13940ed3">associateLayer</a> (const <a class="el" href="class_acts_1_1_layer.html">Layer</a> &amp;lay)</td></tr>
<tr class="memdesc:af63ca99fc18acd61dee8454d13940ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Associated Layer Many surfaces can be associated to a Layer, but it might not be known yet during construction of the layer, this can be set afterwards.  <br /></td></tr>
<tr class="memitem:ae229ee9770face305cc38703fa7409ff" id="r_ae229ee9770face305cc38703fa7409ff"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_acts_1_1_surface_bounds.html">SurfaceBounds</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae229ee9770face305cc38703fa7409ff">bounds</a> () const =0</td></tr>
<tr class="memdesc:ae229ee9770face305cc38703fa7409ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for SurfaceBounds.  <br /></td></tr>
<tr class="memitem:aa86e26e4537287cce40df221284ff77a" id="r_aa86e26e4537287cce40df221284ff77a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_acts.html#a528016d34d6df141f5cb73973d6edca0">BoundToFreeMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa86e26e4537287cce40df221284ff77a">boundToFreeJacobian</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const</td></tr>
<tr class="memdesc:aa86e26e4537287cce40df221284ff77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the jacobian from local to global which the surface knows best, hence the calculation is done here.  <br /></td></tr>
<tr class="memitem:a2891f4e1034be2ff0824ee5b153b44dd" id="r_a2891f4e1034be2ff0824ee5b153b44dd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2891f4e1034be2ff0824ee5b153b44dd">center</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx) const</td></tr>
<tr class="memdesc:a2891f4e1034be2ff0824ee5b153b44dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the surface center.  <br /></td></tr>
<tr class="memitem:a5a93dec09919e2cb30e4234da0fd0663" id="r_a5a93dec09919e2cb30e4234da0fd0663"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a93dec09919e2cb30e4234da0fd0663">closestPointOnBoundary</a> (const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;lposition, const <a class="el" href="group__algebra__types.html#ga57a9cb002daaf227c693f2992fa5540c">SquareMatrix2</a> &amp;metric) const</td></tr>
<tr class="memdesc:a5a93dec09919e2cb30e4234da0fd0663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the closest point on the boundary of the surface to a given point in local coordinates.  <br /></td></tr>
<tr class="memitem:a602e26828afb4e564c2ff06b6f068f73" id="r_a602e26828afb4e564c2ff06b6f068f73"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a602e26828afb4e564c2ff06b6f068f73">distanceToBoundary</a> (const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;lposition) const</td></tr>
<tr class="memdesc:a602e26828afb4e564c2ff06b6f068f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the distance to the boundary of the surface from a given point in local coordinates.  <br /></td></tr>
<tr class="memitem:a6ce9ed485ef7f19c8c99d28af4d05f13" id="r_a6ce9ed485ef7f19c8c99d28af4d05f13"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_acts.html#a8d9bd328a23a650ba4dbe1b1bedcb276">FreeToBoundMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ce9ed485ef7f19c8c99d28af4d05f13">freeToBoundJacobian</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const</td></tr>
<tr class="memdesc:a6ce9ed485ef7f19c8c99d28af4d05f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the jacobian from global to local which the surface knows best, hence the calculation is done here.  <br /></td></tr>
<tr class="memitem:a610651d5b1eb01ee5340ccfc6f500070" id="r_a610651d5b1eb01ee5340ccfc6f500070"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_acts.html#a9fba2b6f3c302ad14749697283c510bd">FreeToPathMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a610651d5b1eb01ee5340ccfc6f500070">freeToPathDerivative</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const</td></tr>
<tr class="memdesc:a610651d5b1eb01ee5340ccfc6f500070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the derivative of path length at the geometry constraint or point-of-closest-approach w.r.t.  <br /></td></tr>
<tr class="memitem:a5a9660305f3ad5c2e6731942206571a8" id="r_a5a9660305f3ad5c2e6731942206571a8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a9660305f3ad5c2e6731942206571a8">getSharedPtr</a> ()</td></tr>
<tr class="memdesc:a5a9660305f3ad5c2e6731942206571a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code>std::shared_ptr</code> for this surface (non-const version).  <br /></td></tr>
<tr class="memitem:a9785fd041382473c9516be99a18535c6" id="r_a9785fd041382473c9516be99a18535c6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9785fd041382473c9516be99a18535c6">getSharedPtr</a> () const</td></tr>
<tr class="memdesc:a9785fd041382473c9516be99a18535c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a <code>std::shared_ptr</code> for this surface (const version).  <br /></td></tr>
<tr class="memitem:a507a64559bd7cfa030805ae74b5a6dd9" id="r_a507a64559bd7cfa030805ae74b5a6dd9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a507a64559bd7cfa030805ae74b5a6dd9">globalToLocal</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction, double tolerance=<a class="el" href="namespace_acts.html#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a>) const =0</td></tr>
<tr class="memdesc:a507a64559bd7cfa030805ae74b5a6dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global to local transformation Generalized global to local transformation for the surface types.  <br /></td></tr>
<tr class="memitem:a8b2a73e04f09f076f719b5b91cde8a7c" id="r_a8b2a73e04f09f076f719b5b91cde8a7c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b2a73e04f09f076f719b5b91cde8a7c">insideBounds</a> (const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;lposition, const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;boundaryTolerance=<a class="el" href="class_acts_1_1_boundary_tolerance.html#a37f9fa35e522bffbdd6b7107443599cc">BoundaryTolerance::None</a>()) const</td></tr>
<tr class="memdesc:a8b2a73e04f09f076f719b5b91cde8a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The insideBounds method for local positions.  <br /></td></tr>
<tr class="memitem:a23b661e68fee3ab78ca59ccb98bf52b9" id="r_a23b661e68fee3ab78ca59ccb98bf52b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_acts.html#ae4e962ae4108b1150b697ebcc6132bff">MultiIntersection3D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23b661e68fee3ab78ca59ccb98bf52b9">intersect</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction, const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;boundaryTolerance=<a class="el" href="class_acts_1_1_boundary_tolerance.html#a8f2376046ddf8c108006502775cd1aef">BoundaryTolerance::Infinite</a>(), double tolerance=<a class="el" href="namespace_acts.html#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a>) const =0</td></tr>
<tr class="memdesc:a23b661e68fee3ab78ca59ccb98bf52b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Straight line intersection schema from position/direction.  <br /></td></tr>
<tr class="memitem:a737d6899bed07338996dadf34b912db0" id="r_a737d6899bed07338996dadf34b912db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a737d6899bed07338996dadf34b912db0">isOnSurface</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction, const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;boundaryTolerance=<a class="el" href="class_acts_1_1_boundary_tolerance.html#a37f9fa35e522bffbdd6b7107443599cc">BoundaryTolerance::None</a>(), double tolerance=<a class="el" href="namespace_acts.html#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a>) const</td></tr>
<tr class="memdesc:a737d6899bed07338996dadf34b912db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The geometric onSurface method.  <br /></td></tr>
<tr class="memitem:a9f697a247eae77a6eb1f65116ece3367" id="r_a9f697a247eae77a6eb1f65116ece3367"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; 2, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f697a247eae77a6eb1f65116ece3367">localCartesianToBoundLocalDerivative</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position) const =0</td></tr>
<tr class="memdesc:a9f697a247eae77a6eb1f65116ece3367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the derivative of bound track parameters local position w.r.t.  <br /></td></tr>
<tr class="memitem:a7b2cbad2c5f7f25915035cc0fa2c6e96" id="r_a7b2cbad2c5f7f25915035cc0fa2c6e96"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b2cbad2c5f7f25915035cc0fa2c6e96">localToGlobal</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;lposition, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const =0</td></tr>
<tr class="memdesc:a7b2cbad2c5f7f25915035cc0fa2c6e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local to global transformation Generalized local to global transformation for the surface types.  <br /></td></tr>
<tr class="memitem:abec410b88b35540550328ddc307284fc" id="r_abec410b88b35540550328ddc307284fc"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abec410b88b35540550328ddc307284fc">name</a> () const =0</td></tr>
<tr class="memdesc:abec410b88b35540550328ddc307284fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return properly formatted class name.  <br /></td></tr>
<tr class="memitem:a7aa938fa6385cb956d9b5da75235289a" id="r_a7aa938fa6385cb956d9b5da75235289a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aa938fa6385cb956d9b5da75235289a">normal</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;pos, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const =0</td></tr>
<tr class="memdesc:a7aa938fa6385cb956d9b5da75235289a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the surface normal at a given <code class="param">position</code> and <code class="param">direction</code>.  <br /></td></tr>
<tr class="memitem:a0fc461beeda802f110cbdd480da516f5" id="r_a0fc461beeda802f110cbdd480da516f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc461beeda802f110cbdd480da516f5">operator=</a> (const <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &amp;other)</td></tr>
<tr class="memdesc:a0fc461beeda802f110cbdd480da516f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="memitem:aa499eae940b107a7012a2875a100a4fc" id="r_aa499eae940b107a7012a2875a100a4fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa499eae940b107a7012a2875a100a4fc">operator==</a> (const <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &amp;other) const</td></tr>
<tr class="memdesc:aa499eae940b107a7012a2875a100a4fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison (equality) operator The strategy for comparison is (a) first pointer comparison (b) then type comparison (c) then bounds comparison (d) then transform comparison.  <br /></td></tr>
<tr class="memitem:abc1b37b98fdda34da35d19e65ab7c85c" id="r_abc1b37b98fdda34da35d19e65ab7c85c"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc1b37b98fdda34da35d19e65ab7c85c">pathCorrection</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const =0</td></tr>
<tr class="memdesc:abc1b37b98fdda34da35d19e65ab7c85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculation of the path correction for incident.  <br /></td></tr>
<tr class="memitem:a76074a485122173fe7d40ae607c6fe3c" id="r_a76074a485122173fe7d40ae607c6fe3c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_acts_1_1_polyhedron.html">Polyhedron</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76074a485122173fe7d40ae607c6fe3c">polyhedronRepresentation</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, unsigned int quarterSegments=2u) const =0</td></tr>
<tr class="memdesc:a76074a485122173fe7d40ae607c6fe3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Polyhedron for surface objects.  <br /></td></tr>
<tr class="memitem:a8d77b2de00164240967727e599d6d30d" id="r_a8d77b2de00164240967727e599d6d30d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#ga04f891882a45afadbe07df33ad1c181c">Acts::RotationMatrix3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d77b2de00164240967727e599d6d30d">referenceFrame</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;position, const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;direction) const</td></tr>
<tr class="memdesc:a8d77b2de00164240967727e599d6d30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the reference frame This is the frame in which the covariance matrix is defined (specialized by all surfaces).  <br /></td></tr>
<tr class="memitem:a058edb9c5523ecd63b6080886985d4ee" id="r_a058edb9c5523ecd63b6080886985d4ee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a058edb9c5523ecd63b6080886985d4ee">surfaceMaterial</a> () const</td></tr>
<tr class="memdesc:a058edb9c5523ecd63b6080886985d4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the associated Material to this surface.  <br /></td></tr>
<tr class="memitem:af56ea9a976f4172841579c43a6d8f2ce" id="r_af56ea9a976f4172841579c43a6d8f2ce"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af56ea9a976f4172841579c43a6d8f2ce">surfaceMaterialSharedPtr</a> () const</td></tr>
<tr class="memdesc:af56ea9a976f4172841579c43a6d8f2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the shared pointer to the associated Material.  <br /></td></tr>
<tr class="memitem:a1c36a82ca5ae9168fd5a63bf2a1f2686" id="r_a1c36a82ca5ae9168fd5a63bf2a1f2686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_geometry_context_ostream_wrapper.html">GeometryContextOstreamWrapper</a>&lt; <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c36a82ca5ae9168fd5a63bf2a1f2686">toStream</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx) const</td></tr>
<tr class="memdesc:a1c36a82ca5ae9168fd5a63bf2a1f2686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method for printing: the returned object captures the surface and the geometry context and will print the surface.  <br /></td></tr>
<tr class="memitem:a515ea8fa9c29a662c544c2a24c87aa0a" id="r_a515ea8fa9c29a662c544c2a24c87aa0a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515ea8fa9c29a662c544c2a24c87aa0a">toString</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx) const</td></tr>
<tr class="memdesc:a515ea8fa9c29a662c544c2a24c87aa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output into a std::string.  <br /></td></tr>
<tr class="memitem:a363ac85362ba9b62f3efc30ef5fc67f6" id="r_a363ac85362ba9b62f3efc30ef5fc67f6"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a363ac85362ba9b62f3efc30ef5fc67f6">transform</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx) const</td></tr>
<tr class="memdesc:a363ac85362ba9b62f3efc30ef5fc67f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the surface Transform3 by reference In case a detector element is associated the surface transform is just forwarded to the detector element in order to keep the (mis-)alignment cache cetrally handled.  <br /></td></tr>
<tr class="memitem:a0bc615a9e492d2b1771368b7bf297921" id="r_a0bc615a9e492d2b1771368b7bf297921"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0">SurfaceType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bc615a9e492d2b1771368b7bf297921">type</a> () const =0</td></tr>
<tr class="memdesc:a0bc615a9e492d2b1771368b7bf297921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return method for the Surface type to avoid dynamic casts.  <br /></td></tr>
<tr class="memitem:a3804756230f7ae5fa25064364c973789" id="r_a3804756230f7ae5fa25064364c973789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3804756230f7ae5fa25064364c973789">visualize</a> (<a class="el" href="class_acts_1_1_i_visualization3_d.html">IVisualization3D</a> &amp;helper, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> &amp;viewConfig=<a class="el" href="namespace_acts.html#a0e88165f9dc20c209a6761493b8eb986">s_viewSurface</a>) const</td></tr>
<tr class="memdesc:a3804756230f7ae5fa25064364c973789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visualize the surface for debugging and inspection.  <br /></td></tr>
<tr class="inherit_header pub_methods_class_acts_1_1_geometry_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_acts_1_1_geometry_object')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="class_acts_1_1_geometry_object.html">Acts::GeometryObject</a></td></tr>
<tr class="memitem:aa3649047621ffd92ebbc3dded63b0651 inherit pub_methods_class_acts_1_1_geometry_object" id="r_aa3649047621ffd92ebbc3dded63b0651"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#aa3649047621ffd92ebbc3dded63b0651">GeometryObject</a> ()=default</td></tr>
<tr class="memdesc:aa3649047621ffd92ebbc3dded63b0651 inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted constructor.  <br /></td></tr>
<tr class="memitem:a856a66acfeaebf0915d8df18d75b1ebf inherit pub_methods_class_acts_1_1_geometry_object" id="r_a856a66acfeaebf0915d8df18d75b1ebf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#a856a66acfeaebf0915d8df18d75b1ebf">GeometryObject</a> (const <a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a> &amp;<a class="el" href="class_acts_1_1_geometry_object.html#a798dd6a19dcc5cd79d9b55ed6e474f7a">geometryId</a>)</td></tr>
<tr class="memdesc:a856a66acfeaebf0915d8df18d75b1ebf inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from a value.  <br /></td></tr>
<tr class="memitem:a72f319258ef848e32b0ec8cdebc6acbb inherit pub_methods_class_acts_1_1_geometry_object" id="r_a72f319258ef848e32b0ec8cdebc6acbb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#a72f319258ef848e32b0ec8cdebc6acbb">GeometryObject</a> (const GeometryObject &amp;)=default</td></tr>
<tr class="memdesc:a72f319258ef848e32b0ec8cdebc6acbb inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defaulted copy constructor.  <br /></td></tr>
<tr class="memitem:af76698124ad0ee6abddb62caebcc2bf3 inherit pub_methods_class_acts_1_1_geometry_object" id="r_af76698124ad0ee6abddb62caebcc2bf3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#af76698124ad0ee6abddb62caebcc2bf3">~GeometryObject</a> () noexcept=default</td></tr>
<tr class="memitem:ab156ca1460c8174c20427e4832d32f89 inherit pub_methods_class_acts_1_1_geometry_object" id="r_ab156ca1460c8174c20427e4832d32f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#ab156ca1460c8174c20427e4832d32f89">assignGeometryId</a> (const <a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a> &amp;<a class="el" href="class_acts_1_1_geometry_object.html#a798dd6a19dcc5cd79d9b55ed6e474f7a">geometryId</a>)</td></tr>
<tr class="memdesc:ab156ca1460c8174c20427e4832d32f89 inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value.  <br /></td></tr>
<tr class="memitem:a798dd6a19dcc5cd79d9b55ed6e474f7a inherit pub_methods_class_acts_1_1_geometry_object" id="r_a798dd6a19dcc5cd79d9b55ed6e474f7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#a798dd6a19dcc5cd79d9b55ed6e474f7a">geometryId</a> () const</td></tr>
<tr class="memitem:aac06b9a406982ecb318d9fbbd3ece5c4 inherit pub_methods_class_acts_1_1_geometry_object" id="r_aac06b9a406982ecb318d9fbbd3ece5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_geometry_object.html#aa3649047621ffd92ebbc3dded63b0651">GeometryObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#aac06b9a406982ecb318d9fbbd3ece5c4">operator=</a> (const <a class="el" href="class_acts_1_1_geometry_object.html#aa3649047621ffd92ebbc3dded63b0651">GeometryObject</a> &amp;<a class="el" href="class_acts_1_1_geometry_object.html#a798dd6a19dcc5cd79d9b55ed6e474f7a">geometryId</a>)</td></tr>
<tr class="memdesc:aac06b9a406982ecb318d9fbbd3ece5c4 inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <br /></td></tr>
<tr class="memitem:a05681cc42af51a5ac87b269ecb8c3b26 inherit pub_methods_class_acts_1_1_geometry_object" id="r_a05681cc42af51a5ac87b269ecb8c3b26"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#a05681cc42af51a5ac87b269ecb8c3b26">referencePosition</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> aDir) const =0</td></tr>
<tr class="memdesc:a05681cc42af51a5ac87b269ecb8c3b26 inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a binning position method.  <br /></td></tr>
<tr class="memitem:a7676d0ddf36068967094fd4a2b069089 inherit pub_methods_class_acts_1_1_geometry_object" id="r_a7676d0ddf36068967094fd4a2b069089"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#a7676d0ddf36068967094fd4a2b069089">referencePositionValue</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> aDir) const</td></tr>
<tr class="memdesc:a7676d0ddf36068967094fd4a2b069089 inherit pub_methods_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the binningValue.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1b015430332289b80ecf57688e1b350c" id="r_a1b015430332289b80ecf57688e1b350c"><td class="memTemplParams" colspan="2">template&lt;class T, typename... Args&gt; </td></tr>
<tr class="memitem:a1b015430332289b80ecf57688e1b350c template"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b015430332289b80ecf57688e1b350c">makeShared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a1b015430332289b80ecf57688e1b350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for producing memory managed instances of Surface.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a599b254f27b5f548f8be5f3d899fee9a" id="r_a599b254f27b5f548f8be5f3d899fee9a"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; std::string_view, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a5ce17ecad7b6bed89667ea05c9b618bc">Surface::SurfaceType::Other</a>+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a599b254f27b5f548f8be5f3d899fee9a">s_surfaceTypeNames</a></td></tr>
<tr class="memdesc:a599b254f27b5f548f8be5f3d899fee9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper strings for screen output.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1516ea61a533ace89b823238c4605467" id="r_a1516ea61a533ace89b823238c4605467"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1516ea61a533ace89b823238c4605467">Surface</a> (const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> &amp;detelement)</td></tr>
<tr class="memdesc:a1516ea61a533ace89b823238c4605467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from DetectorElementBase: Element proxy.  <br /></td></tr>
<tr class="memitem:a9fb68f6cd1d953a649a7e44244d3f954" id="r_a9fb68f6cd1d953a649a7e44244d3f954"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fb68f6cd1d953a649a7e44244d3f954">Surface</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const Surface &amp;other, const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;shift)</td></tr>
<tr class="memdesc:a9fb68f6cd1d953a649a7e44244d3f954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with optional shift.  <br /></td></tr>
<tr class="memitem:a8390507a637410b2a7f46333198b1708" id="r_a8390507a637410b2a7f46333198b1708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8390507a637410b2a7f46333198b1708">Surface</a> (const Surface &amp;other)</td></tr>
<tr class="memdesc:a8390507a637410b2a7f46333198b1708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="memitem:a2ae67591c6ce6b42568881be16f29ddc" id="r_a2ae67591c6ce6b42568881be16f29ddc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> (const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;<a class="el" href="#a363ac85362ba9b62f3efc30ef5fc67f6">transform</a>=Transform3::Identity())</td></tr>
<tr class="memdesc:a2ae67591c6ce6b42568881be16f29ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor with Transform3 as a shared object.  <br /></td></tr>
<tr class="memitem:a10a856c74db9fae99306dd602e6c7e2b" id="r_a10a856c74db9fae99306dd602e6c7e2b"><td class="memItemLeft" align="right" valign="top">virtual std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a856c74db9fae99306dd602e6c7e2b">toStreamImpl</a> (const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, std::ostream &amp;sl) const</td></tr>
<tr class="memdesc:a10a856c74db9fae99306dd602e6c7e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output Method for std::ostream, to be overloaded by child classes.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7eda0c0d3b018eedb1e25709205535db" id="r_a7eda0c0d3b018eedb1e25709205535db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eda0c0d3b018eedb1e25709205535db">m_associatedDetElement</a> {nullptr}</td></tr>
<tr class="memdesc:a7eda0c0d3b018eedb1e25709205535db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the a DetectorElementBase.  <br /></td></tr>
<tr class="memitem:ad93d06dd89550599358d40fce528f9c7" id="r_ad93d06dd89550599358d40fce528f9c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_layer.html">Layer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad93d06dd89550599358d40fce528f9c7">m_associatedLayer</a> {nullptr}</td></tr>
<tr class="memdesc:ad93d06dd89550599358d40fce528f9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The associated layer Layer - layer in which the Surface is be embedded, nullptr if not associated.  <br /></td></tr>
<tr class="memitem:aee29c91f9347fe7b9080679dc20164b8" id="r_aee29c91f9347fe7b9080679dc20164b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee29c91f9347fe7b9080679dc20164b8">m_associatedTrackingVolume</a> {nullptr}</td></tr>
<tr class="memdesc:aee29c91f9347fe7b9080679dc20164b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The associated TrackingVolume - tracking volume in case the surface is a boundary surface, nullptr if not associated.  <br /></td></tr>
<tr class="memitem:a14688579dc8bbd516c0a3f264afc17fe" id="r_a14688579dc8bbd516c0a3f264afc17fe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14688579dc8bbd516c0a3f264afc17fe">m_surfaceMaterial</a></td></tr>
<tr class="memdesc:a14688579dc8bbd516c0a3f264afc17fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possibility to attach a material description.  <br /></td></tr>
<tr class="memitem:acc5413d1678ec7d5b2f67498b0b38cfa" id="r_acc5413d1678ec7d5b2f67498b0b38cfa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc5413d1678ec7d5b2f67498b0b38cfa">m_transform</a> {}</td></tr>
<tr class="memdesc:acc5413d1678ec7d5b2f67498b0b38cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform3 definition that positions (translation, rotation) the surface in global space.  <br /></td></tr>
<tr class="inherit_header pro_attribs_class_acts_1_1_geometry_object"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_acts_1_1_geometry_object')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Attributes inherited from <a class="el" href="class_acts_1_1_geometry_object.html">Acts::GeometryObject</a></td></tr>
<tr class="memitem:a8670edf1ae6be633b07a2e07f370e1e4 inherit pro_attribs_class_acts_1_1_geometry_object" id="r_a8670edf1ae6be633b07a2e07f370e1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_geometry_identifier.html">GeometryIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_geometry_object.html#a8670edf1ae6be633b07a2e07f370e1e4">m_geometryId</a></td></tr>
<tr class="memdesc:a8670edf1ae6be633b07a2e07f370e1e4 inherit pro_attribs_class_acts_1_1_geometry_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique geometry identifier for this object.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract Base Class for tracking surfaces. </p>
<p>The Surface class builds the core of the Acts Tracking Geometry. All other geometrical objects are either extending the surface or are built from it.</p>
<p>Surfaces are either owned by Detector elements or the Tracking Geometry, in which case they are not copied within the data model objects. </p>
</div><a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a34fd1452f7603ef1f072d3c3233f9ba0" name="a34fd1452f7603ef1f072d3c3233f9ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fd1452f7603ef1f072d3c3233f9ba0">&#9670;&#160;</a></span>SurfaceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0">Acts::Surface::SurfaceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enumerator simplifies the persistency &amp; calculations, by saving a dynamic_cast, e.g. </p>
<p>for persistency </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0a9500807f494fea928b0c02c6831b1bc6" name="a34fd1452f7603ef1f072d3c3233f9ba0a9500807f494fea928b0c02c6831b1bc6"></a>Cone&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0aa997f5ccb5150365e8622161d610f575" name="a34fd1452f7603ef1f072d3c3233f9ba0aa997f5ccb5150365e8622161d610f575"></a>Cylinder&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0a1ba44d6d20145ae45ddb87f1dfccf304" name="a34fd1452f7603ef1f072d3c3233f9ba0a1ba44d6d20145ae45ddb87f1dfccf304"></a>Disc&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0a362560c9d54c69a04d76d1858201bec4" name="a34fd1452f7603ef1f072d3c3233f9ba0a362560c9d54c69a04d76d1858201bec4"></a>Perigee&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0a0ef417dbcfa7c48e3fe8cbc6648e33a6" name="a34fd1452f7603ef1f072d3c3233f9ba0a0ef417dbcfa7c48e3fe8cbc6648e33a6"></a>Plane&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0aa9597db8c0f4c9506c4d01d7f42de005" name="a34fd1452f7603ef1f072d3c3233f9ba0aa9597db8c0f4c9506c4d01d7f42de005"></a>Straw&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0a8cae7f38a5912d7b4e5399e6238d8b4f" name="a34fd1452f7603ef1f072d3c3233f9ba0a8cae7f38a5912d7b4e5399e6238d8b4f"></a>Curvilinear&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a34fd1452f7603ef1f072d3c3233f9ba0a5ce17ecad7b6bed89667ea05c9b618bc" name="a34fd1452f7603ef1f072d3c3233f9ba0a5ce17ecad7b6bed89667ea05c9b618bc"></a>Other&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ae67591c6ce6b42568881be16f29ddc" name="a2ae67591c6ce6b42568881be16f29ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae67591c6ce6b42568881be16f29ddc">&#9670;&#160;</a></span>Surface() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Transform3::Identity()</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor with Transform3 as a shared object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>Transform3 positions the surface in 3D global space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>also acts as default constructor </dd></dl>

</div>
</div>
<a id="a8390507a637410b2a7f46333198b1708" name="a8390507a637410b2a7f46333198b1708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8390507a637410b2a7f46333198b1708">&#9670;&#160;</a></span>Surface() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">const Surface &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>copy construction invalidates the association to detector element and layer</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source surface for copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1516ea61a533ace89b823238c4605467" name="a1516ea61a533ace89b823238c4605467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1516ea61a533ace89b823238c4605467">&#9670;&#160;</a></span>Surface() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>detelement</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from DetectorElementBase: Element proxy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detelement</td><td>Detector element which is represented by this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fb68f6cd1d953a649a7e44244d3f954" name="a9fb68f6cd1d953a649a7e44244d3f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb68f6cd1d953a649a7e44244d3f954">&#9670;&#160;</a></span>Surface() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Surface::Surface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Surface &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor with optional shift. </p>
<dl class="section note"><dt>Note</dt><dd>copy construction invalidates the association to detector element and layer</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">other</td><td>Source surface for copy </td></tr>
    <tr><td class="paramname">shift</td><td>Additional transform applied as: shift * transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a730e3e090bbc441e4bd2891cbae84f15" name="a730e3e090bbc441e4bd2891cbae84f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730e3e090bbc441e4bd2891cbae84f15">&#9670;&#160;</a></span>~Surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Acts::Surface::~Surface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel noexcept">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a26b77cdb1dedf4fb87e4702f562106e3" name="a26b77cdb1dedf4fb87e4702f562106e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b77cdb1dedf4fb87e4702f562106e3">&#9670;&#160;</a></span>alignmentToBoundDerivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#afb10c5cb981e8a26821fd8afafc6d10f">AlignmentToBoundMatrix</a> Acts::Surface::alignmentToBoundDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_acts.html#a34a846c2589150628ba6e05624221307">FreeVector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pathDerivative</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The derivative of bound track parameters w.r.t. </p>
<p>alignment parameters of its reference surface (i.e. local frame origin in global 3D Cartesian coordinates and its rotation represented with extrinsic Euler angles)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment change of alignment parameters </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction </td></tr>
    <tr><td class="paramname">pathDerivative</td><td>is the derivative of free parameters w.r.t. path length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of bound track parameters w.r.t. local frame alignment parameters </dd></dl>

</div>
</div>
<a id="ac94e8ed380531243a14c6de82bd11f9e" name="ac94e8ed380531243a14c6de82bd11f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94e8ed380531243a14c6de82bd11f9e">&#9670;&#160;</a></span>alignmentToPathDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_acts.html#ab42a56895184458a0c2b4de6f112469b">AlignmentToPathMatrix</a> Acts::Surface::alignmentToPathDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the derivative of path length at the geometry constraint or point-of-closest-approach w.r.t. </p>
<p>alignment parameters of the surface (i.e. local frame origin in global 3D Cartesian coordinates and its rotation represented with extrinsic Euler angles)</p>
<dl class="section note"><dt>Note</dt><dd>Re-implementation is needed for surface whose intersection with track is not its local xy plane, e.g. LineSurface, CylinderSurface and ConeSurface</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of path length w.r.t. the alignment parameters </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_cone_surface.html#a103653cbb994832f9b3697bf7966b66b">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a99954474b13843d26bba1c3786d38ef4">Acts::CylinderSurface</a>, and <a class="el" href="class_acts_1_1_line_surface.html#ac0effe5f6e0865a2b1f8b66fc19012f1">Acts::LineSurface</a>.</p>

</div>
</div>
<a id="a44604fa05382ea7e7a6663a9a89a2bf1" name="a44604fa05382ea7e7a6663a9a89a2bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44604fa05382ea7e7a6663a9a89a2bf1">&#9670;&#160;</a></span>assignDetectorElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Surface::assignDetectorElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>detelement</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a detector element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detelement</td><td>Detector element which is represented by this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af524db996f2812448cc76b37e2f93dde" name="af524db996f2812448cc76b37e2f93dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af524db996f2812448cc76b37e2f93dde">&#9670;&#160;</a></span>assignSurfaceMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Surface::assignSurfaceMaterial </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>material</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the surface material description. </p>
<p>The material is usually derived in a complicated way and loaded from a framework given source. As various surfaces may share the same source this is provided by a shared pointer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>Material description associated to this surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bc21b77bca942e751f73e347968ec9d" name="a0bc21b77bca942e751f73e347968ec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc21b77bca942e751f73e347968ec9d">&#9670;&#160;</a></span>associatedDetectorElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a> * Acts::Surface::associatedDetectorElement </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return method for the associated Detector Element. </p>
<dl class="section return"><dt>Returns</dt><dd>plain pointer to the DetectorElement, can be nullptr </dd></dl>

</div>
</div>
<a id="ac900594dda62ce72431c6db2143b7611" name="ac900594dda62ce72431c6db2143b7611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac900594dda62ce72431c6db2143b7611">&#9670;&#160;</a></span>associatedLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_layer.html">Layer</a> * Acts::Surface::associatedLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return method for the associated Layer in which the surface is embedded. </p>
<dl class="section return"><dt>Returns</dt><dd>Layer by plain pointer, can be nullptr </dd></dl>

</div>
</div>
<a id="af63ca99fc18acd61dee8454d13940ed3" name="af63ca99fc18acd61dee8454d13940ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63ca99fc18acd61dee8454d13940ed3">&#9670;&#160;</a></span>associateLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Surface::associateLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_layer.html">Layer</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lay</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Associated Layer Many surfaces can be associated to a Layer, but it might not be known yet during construction of the layer, this can be set afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lay</td><td>the assignment Layer by reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae229ee9770face305cc38703fa7409ff" name="ae229ee9770face305cc38703fa7409ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae229ee9770face305cc38703fa7409ff">&#9670;&#160;</a></span>bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_acts_1_1_surface_bounds.html">SurfaceBounds</a> &amp; Acts::Surface::bounds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return method for SurfaceBounds. </p>
<dl class="section return"><dt>Returns</dt><dd>SurfaceBounds by reference </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#a645746a72efcc9ff57494c6d113df9f2">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a5f9628e80cfb54bc960ba5d3ce6e7870">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a7f806e65cb66960f4b89665750694768">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#a96c3b796518c856aec14504a76dfea8a">Acts::LineSurface</a>, and <a class="el" href="class_acts_1_1_plane_surface.html#a8f261b0849edb201bc51cd25c6e530a6">Acts::PlaneSurface</a>.</p>

</div>
</div>
<a id="aa86e26e4537287cce40df221284ff77a" name="aa86e26e4537287cce40df221284ff77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86e26e4537287cce40df221284ff77a">&#9670;&#160;</a></span>boundToFreeJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_acts.html#a528016d34d6df141f5cb73973d6edca0">BoundToFreeMatrix</a> Acts::Surface::boundToFreeJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the jacobian from local to global which the surface knows best, hence the calculation is done here. </p>
<dl class="section note"><dt>Note</dt><dd>In principle, the input could also be a free parameters vector as it could be transformed to a bound parameters. But the transform might fail in case the parameters is not on surface. To avoid the check inside this function, it takes directly the bound parameters as input (then the check might be done where this function is called).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo</a></b></dt><dd>this mixes track parameterisation and geometry should move to : "Acts/EventData/detail/coordinate_transformations.hpp"</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobian from local to global </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_disc_surface.html#a734a2510a2303b0268a3c214f8b7f7f0">Acts::DiscSurface</a>, and <a class="el" href="class_acts_1_1_line_surface.html#a9df8f0dad82879a0b1bbe1d054146860">Acts::LineSurface</a>.</p>

</div>
</div>
<a id="a2891f4e1034be2ff0824ee5b153b44dd" name="a2891f4e1034be2ff0824ee5b153b44dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2891f4e1034be2ff0824ee5b153b44dd">&#9670;&#160;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> Acts::Surface::center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return method for the surface center. </p>
<dl class="section note"><dt>Note</dt><dd>the center is always recalculated in order to not keep a cache</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>center position by value </dd></dl>

</div>
</div>
<a id="a5a93dec09919e2cb30e4234da0fd0663" name="a5a93dec09919e2cb30e4234da0fd0663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a93dec09919e2cb30e4234da0fd0663">&#9670;&#160;</a></span>closestPointOnBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> Acts::Surface::closestPointOnBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lposition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga57a9cb002daaf227c693f2992fa5540c">SquareMatrix2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>metric</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the closest point on the boundary of the surface to a given point in local coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lposition</td><td>The local position to check </td></tr>
    <tr><td class="paramname">metric</td><td>The metric to use for the calculation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The closest point on the boundary of the surface </dd></dl>

</div>
</div>
<a id="a602e26828afb4e564c2ff06b6f068f73" name="a602e26828afb4e564c2ff06b6f068f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602e26828afb4e564c2ff06b6f068f73">&#9670;&#160;</a></span>distanceToBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Acts::Surface::distanceToBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lposition</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the distance to the boundary of the surface from a given point in local coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lposition</td><td>The local position to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance to the boundary of the surface </dd></dl>

</div>
</div>
<a id="a6ce9ed485ef7f19c8c99d28af4d05f13" name="a6ce9ed485ef7f19c8c99d28af4d05f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9ed485ef7f19c8c99d28af4d05f13">&#9670;&#160;</a></span>freeToBoundJacobian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_acts.html#a8d9bd328a23a650ba4dbe1b1bedcb276">FreeToBoundMatrix</a> Acts::Surface::freeToBoundJacobian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the jacobian from global to local which the surface knows best, hence the calculation is done here. </p>
<dl class="section note"><dt>Note</dt><dd>It assumes the input free parameters is on surface, hence no onSurface check is done inside this function.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo</a></b></dt><dd>this mixes track parameterisation and geometry should move to : "Acts/EventData/detail/coordinate_transformations.hpp"</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Jacobian from global to local </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_disc_surface.html#af66e99dfe7d3d38708a0255326cb34bf">Acts::DiscSurface</a>.</p>

</div>
</div>
<a id="a610651d5b1eb01ee5340ccfc6f500070" name="a610651d5b1eb01ee5340ccfc6f500070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610651d5b1eb01ee5340ccfc6f500070">&#9670;&#160;</a></span>freeToPathDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_acts.html#a9fba2b6f3c302ad14749697283c510bd">FreeToPathMatrix</a> Acts::Surface::freeToPathDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the derivative of path length at the geometry constraint or point-of-closest-approach w.r.t. </p>
<p>free parameters. The calculation is identical for all surfaces where the reference frame does not depend on the direction</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo</a></b></dt><dd>this mixes track parameterisation and geometry should move to : "Acts/EventData/detail/coordinate_transformations.hpp"</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of path length w.r.t. free parameters </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_line_surface.html#a43716349f4772843cec04a1c4de97168">Acts::LineSurface</a>.</p>

</div>
</div>
<a id="a5a9660305f3ad5c2e6731942206571a8" name="a5a9660305f3ad5c2e6731942206571a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9660305f3ad5c2e6731942206571a8">&#9670;&#160;</a></span>getSharedPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &gt; Acts::Surface::getSharedPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a <code>std::shared_ptr</code> for this surface (non-const version). </p>
<dl class="section note"><dt>Note</dt><dd>Will error if this was not created through the <code>makeShared</code> factory since it needs access to the original reference. In C++14 this is undefined behavior (but most likely implemented as a <code>bad_weak_ptr</code> exception), in C++17 it is defined as that exception. </dd>
<dd>
Only call this if you need shared ownership of this object.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The shared pointer </dd></dl>

</div>
</div>
<a id="a9785fd041382473c9516be99a18535c6" name="a9785fd041382473c9516be99a18535c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9785fd041382473c9516be99a18535c6">&#9670;&#160;</a></span>getSharedPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &gt; Acts::Surface::getSharedPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a <code>std::shared_ptr</code> for this surface (const version). </p>
<dl class="section note"><dt>Note</dt><dd>Will error if this was not created through the <code>makeShared</code> factory since it needs access to the original reference. In C++14 this is undefined behavior, but most likely implemented as a <code>bad_weak_ptr</code> exception, in C++17 it is defined as that exception. </dd>
<dd>
Only call this if you need shared ownership of this object.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The shared pointer </dd></dl>

</div>
</div>
<a id="a507a64559bd7cfa030805ae74b5a6dd9" name="a507a64559bd7cfa030805ae74b5a6dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507a64559bd7cfa030805ae74b5a6dd9">&#9670;&#160;</a></span>globalToLocal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_acts_1_1_result.html">Result</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &gt; Acts::Surface::globalToLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global to local transformation Generalized global to local transformation for the surface types. </p>
<p>Since some surface types need the global momentum/direction to resolve sign ambiguity this is also provided</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position - considered to be on surface but not inside bounds (check is done) </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction </td></tr>
    <tr><td class="paramname">tolerance</td><td>optional tolerance within which a point is considered valid on surface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Result&lt;Vector2&gt; which can be !ok() if the operation fails </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#a3082370f6db11d7bedddbb5fb642792b">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a3082370f6db11d7bedddbb5fb642792b">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a3082370f6db11d7bedddbb5fb642792b">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#ada5c1353b61b76ca4ac82a2d4abed7e1">Acts::LineSurface</a>, <a class="el" href="class_acts_1_1_plane_surface.html#a3082370f6db11d7bedddbb5fb642792b">Acts::PlaneSurface</a>, and <a class="el" href="class_acts_1_1_regular_surface.html#a3082370f6db11d7bedddbb5fb642792b">Acts::RegularSurface</a>.</p>

</div>
</div>
<a id="a8b2a73e04f09f076f719b5b91cde8a7c" name="a8b2a73e04f09f076f719b5b91cde8a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2a73e04f09f076f719b5b91cde8a7c">&#9670;&#160;</a></span>insideBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Acts::Surface::insideBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lposition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundaryTolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_1_1_boundary_tolerance.html#a37f9fa35e522bffbdd6b7107443599cc">BoundaryTolerance::None</a>()</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The insideBounds method for local positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lposition</td><td>The local position to check </td></tr>
    <tr><td class="paramname">boundaryTolerance</td><td>BoundaryTolerance directive for this onSurface check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean indication if operation was successful </dd></dl>

</div>
</div>
<a id="a23b661e68fee3ab78ca59ccb98bf52b9" name="a23b661e68fee3ab78ca59ccb98bf52b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b661e68fee3ab78ca59ccb98bf52b9">&#9670;&#160;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_acts.html#ae4e962ae4108b1150b697ebcc6132bff">MultiIntersection3D</a> Acts::Surface::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundaryTolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_1_1_boundary_tolerance.html#a8f2376046ddf8c108006502775cd1aef">BoundaryTolerance::Infinite</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Straight line intersection schema from position/direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>The position to start from </td></tr>
    <tr><td class="paramname">direction</td><td>The direction at start </td></tr>
    <tr><td class="paramname">boundaryTolerance</td><td>the BoundaryTolerance </td></tr>
    <tr><td class="paramname">tolerance</td><td>the tolerance used for the intersection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>MultiIntersection3D</code> intersection object </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#ac63273b38cda1b798eb420c2e24a11b2">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#aa8e78f321fa27863bbb84e966253a3bd">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a7ddbbdf24c18569999f2af1531f07585">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#a686b1ee92cdfb9f2cc2ff887597677fb">Acts::LineSurface</a>, and <a class="el" href="class_acts_1_1_plane_surface.html#a56dd3d2a9809920051361629e7ba6c49">Acts::PlaneSurface</a>.</p>

</div>
</div>
<a id="a737d6899bed07338996dadf34b912db0" name="a737d6899bed07338996dadf34b912db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737d6899bed07338996dadf34b912db0">&#9670;&#160;</a></span>isOnSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::Surface::isOnSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_boundary_tolerance.html">BoundaryTolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundaryTolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_acts_1_1_boundary_tolerance.html#a37f9fa35e522bffbdd6b7107443599cc">BoundaryTolerance::None</a>()</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a062150b6d58b9acb88af2feaf8d3aa2b">s_onSurfaceTolerance</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The geometric onSurface method. </p>
<p>Geometrical check whether position is on Surface</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global position to be evaludated </td></tr>
    <tr><td class="paramname">direction</td><td>global momentum direction (required for line-type surfaces) </td></tr>
    <tr><td class="paramname">boundaryTolerance</td><td>BoundaryTolerance directive for this onSurface check </td></tr>
    <tr><td class="paramname">tolerance</td><td>optional tolerance within which a point is considered on surface</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>boolean indication if operation was successful </dd></dl>

</div>
</div>
<a id="a9f697a247eae77a6eb1f65116ece3367" name="a9f697a247eae77a6eb1f65116ece3367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f697a247eae77a6eb1f65116ece3367">&#9670;&#160;</a></span>localCartesianToBoundLocalDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__algebra__types.html#ga99cd1a5ee6b7c5cf8a3aca54526ab67d">ActsMatrix</a>&lt; 2, 3 &gt; Acts::Surface::localCartesianToBoundLocalDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the derivative of bound track parameters local position w.r.t. </p>
<p>position in local 3D Cartesian coordinates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>The position of the parameters in global</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Derivative of bound local position w.r.t. position in local 3D cartesian coordinates </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#ae590c73a74fcb64fd27b41bae41b5dd9">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a2a3e10861b0b2acb2a9c1b65cb857040">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a6ff6f60444bb00b46dfbd976b3960f2c">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#ab89376699d1e1929e048a517d85541fc">Acts::LineSurface</a>, and <a class="el" href="class_acts_1_1_plane_surface.html#a7df97328de86861175ae65a1aa42ea0d">Acts::PlaneSurface</a>.</p>

</div>
</div>
<a id="a7b2cbad2c5f7f25915035cc0fa2c6e96" name="a7b2cbad2c5f7f25915035cc0fa2c6e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2cbad2c5f7f25915035cc0fa2c6e96">&#9670;&#160;</a></span>localToGlobal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> Acts::Surface::localToGlobal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lposition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Local to global transformation Generalized local to global transformation for the surface types. </p>
<p>Since some surface types need the global momentum/direction to resolve sign ambiguity this is also provided</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">lposition</td><td>local 2D position in specialized surface frame </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global position by value </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#adfcdc971f3fd4de8049476a3866f88ca">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#adfcdc971f3fd4de8049476a3866f88ca">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#adfcdc971f3fd4de8049476a3866f88ca">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#a13518b3f2924e5c014556aab19b0ad42">Acts::LineSurface</a>, <a class="el" href="class_acts_1_1_plane_surface.html#adfcdc971f3fd4de8049476a3866f88ca">Acts::PlaneSurface</a>, and <a class="el" href="class_acts_1_1_regular_surface.html#adfcdc971f3fd4de8049476a3866f88ca">Acts::RegularSurface</a>.</p>

</div>
</div>
<a id="a1b015430332289b80ecf57688e1b350c" name="a1b015430332289b80ecf57688e1b350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b015430332289b80ecf57688e1b350c">&#9670;&#160;</a></span>makeShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; T &gt; Acts::Surface::makeShared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory for producing memory managed instances of Surface. </p>
<p>Will forward all parameters and will attempt to find a suitable constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments to forward to surface creation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the created surface instance </dd></dl>

</div>
</div>
<a id="abec410b88b35540550328ddc307284fc" name="abec410b88b35540550328ddc307284fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec410b88b35540550328ddc307284fc">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string Acts::Surface::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return properly formatted class name. </p>
<dl class="section return"><dt>Returns</dt><dd>The surface class name as a string </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#a1c98d54a58800df8704c668158ae1348">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a76892e69141f305b8d33c46b6636e970">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#ade74f870ce20a99c3776b48f227b8eb9">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#aff81d6fdb7eba9c7700a6e18b9cf612b">Acts::LineSurface</a>, <a class="el" href="class_acts_1_1_perigee_surface.html#a656551edc6b30275213a736e37ca064b">Acts::PerigeeSurface</a>, <a class="el" href="class_acts_1_1_plane_surface.html#a54c368934aebf553364d79d143872665">Acts::PlaneSurface</a>, and <a class="el" href="class_acts_1_1_straw_surface.html#a0c07cd840a38df0832757a6d9931793e">Acts::StrawSurface</a>.</p>

</div>
</div>
<a id="a7aa938fa6385cb956d9b5da75235289a" name="a7aa938fa6385cb956d9b5da75235289a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa938fa6385cb956d9b5da75235289a">&#9670;&#160;</a></span>normal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> Acts::Surface::normal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the surface normal at a given <code class="param">position</code> and <code class="param">direction</code>. </p>
<p>This method is fully generic, and valid for all surface types. </p><dl class="section note"><dt>Note</dt><dd>For some surface types, the <code class="param">direction</code> is ignored, but it is <b>not safe</b> to pass in a zero vector! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">pos</td><td>The position at which to calculate the normal </td></tr>
    <tr><td class="paramname">direction</td><td>The direction at which to calculate the normal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normal vector at the given position and direction </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#a39168b59025ca29a0f7d8b8ff51d830a">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a39168b59025ca29a0f7d8b8ff51d830a">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a39168b59025ca29a0f7d8b8ff51d830a">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#a7c50f6f6a00cec299a24624b577000e1">Acts::LineSurface</a>, <a class="el" href="class_acts_1_1_plane_surface.html#a39168b59025ca29a0f7d8b8ff51d830a">Acts::PlaneSurface</a>, and <a class="el" href="class_acts_1_1_regular_surface.html#a39168b59025ca29a0f7d8b8ff51d830a">Acts::RegularSurface</a>.</p>

</div>
</div>
<a id="a0fc461beeda802f110cbdd480da516f5" name="a0fc461beeda802f110cbdd480da516f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc461beeda802f110cbdd480da516f5">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &amp; Acts::Surface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="section note"><dt>Note</dt><dd>copy construction invalidates the association to detector element and layer</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Source surface for the assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this surface after assignment </dd></dl>

</div>
</div>
<a id="aa499eae940b107a7012a2875a100a4fc" name="aa499eae940b107a7012a2875a100a4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa499eae940b107a7012a2875a100a4fc">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Acts::Surface::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison (equality) operator The strategy for comparison is (a) first pointer comparison (b) then type comparison (c) then bounds comparison (d) then transform comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source surface for the comparison </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if surfaces are equal, false otherwise </dd></dl>

</div>
</div>
<a id="abc1b37b98fdda34da35d19e65ab7c85c" name="abc1b37b98fdda34da35d19e65ab7c85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1b37b98fdda34da35d19e65ab7c85c">&#9670;&#160;</a></span>pathCorrection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double Acts::Surface::pathCorrection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculation of the path correction for incident. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The <code class="param">position</code> is either ignored, or it is coerced to be on the surface, depending on the surface type. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>global 3D momentum direction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Path correction with respect to the nominal incident. </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#aa23a5bbe68a89fb2712370385924c1ea">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a57f2c22f7ba667b1b6816a6953b2bc97">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a7260c2ffaea477e6ffd185054135160a">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_line_surface.html#adf1f5aa831abd06b67758f2f72d4d1bd">Acts::LineSurface</a>, and <a class="el" href="class_acts_1_1_plane_surface.html#a4a3a5a9341b898f037f5cb9b7d6d9707">Acts::PlaneSurface</a>.</p>

</div>
</div>
<a id="a76074a485122173fe7d40ae607c6fe3c" name="a76074a485122173fe7d40ae607c6fe3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76074a485122173fe7d40ae607c6fe3c">&#9670;&#160;</a></span>polyhedronRepresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_acts_1_1_polyhedron.html">Polyhedron</a> Acts::Surface::polyhedronRepresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>quarterSegments</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2u</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a Polyhedron for surface objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">quarterSegments</td><td>The number of segemtns to approximate a 0.5*pi sector, which represents a quarter of the full circle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In order to symmetrize the code between sectoral and closed cylinders in case of closed cylinders, both (-pi, pi) are given as separate vertices</dd>
<dd>
An internal surface transform can invalidate the extrema in the transformed space</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A list of vertices and a face/facett description of it </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#a31471ccc240b3c29b42bf9a6e85a16e1">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a5d5d51236b3c2961de59cc57409b20d5">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a5973f77c821be4098153fb7678a29657">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_perigee_surface.html#a2c27587f2d637a46b51e217fe24a99c2">Acts::PerigeeSurface</a>, <a class="el" href="class_acts_1_1_plane_surface.html#aa887d69ef70685c7d9bac18422fb4d42">Acts::PlaneSurface</a>, and <a class="el" href="class_acts_1_1_straw_surface.html#a190844689dece10baad7127486af4c8e">Acts::StrawSurface</a>.</p>

</div>
</div>
<a id="a8d77b2de00164240967727e599d6d30d" name="a8d77b2de00164240967727e599d6d30d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d77b2de00164240967727e599d6d30d">&#9670;&#160;</a></span>referenceFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__algebra__types.html#ga04f891882a45afadbe07df33ad1c181c">Acts::RotationMatrix3</a> Acts::Surface::referenceFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return method for the reference frame This is the frame in which the covariance matrix is defined (specialized by all surfaces). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">position</td><td>global 3D position - considered to be on surface but not inside bounds (check is done) </td></tr>
    <tr><td class="paramname">direction</td><td>global 3D momentum direction (optionally ignored)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RotationMatrix3 which defines the three axes of the measurement frame </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_cone_surface.html#aec88655bd71c0e66bd45301284c9aa84">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#a5ec6cae4b0dc3d8bd86d648110036d22">Acts::CylinderSurface</a>, and <a class="el" href="class_acts_1_1_line_surface.html#a76c0e8a2ebef582e8dde471be15fec18">Acts::LineSurface</a>.</p>

</div>
</div>
<a id="a058edb9c5523ecd63b6080886985d4ee" name="a058edb9c5523ecd63b6080886985d4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058edb9c5523ecd63b6080886985d4ee">&#9670;&#160;</a></span>surfaceMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> * Acts::Surface::surfaceMaterial </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return method for the associated Material to this surface. </p>
<dl class="section return"><dt>Returns</dt><dd>SurfaceMaterial as plain pointer, can be nullptr </dd></dl>

</div>
</div>
<a id="af56ea9a976f4172841579c43a6d8f2ce" name="af56ea9a976f4172841579c43a6d8f2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56ea9a976f4172841579c43a6d8f2ce">&#9670;&#160;</a></span>surfaceMaterialSharedPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> &gt; &amp; Acts::Surface::surfaceMaterialSharedPtr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return method for the shared pointer to the associated Material. </p>
<dl class="section return"><dt>Returns</dt><dd>SurfaceMaterial as shared_pointer, can be nullptr </dd></dl>

</div>
</div>
<a id="a1c36a82ca5ae9168fd5a63bf2a1f2686" name="a1c36a82ca5ae9168fd5a63bf2a1f2686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c36a82ca5ae9168fd5a63bf2a1f2686">&#9670;&#160;</a></span>toStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_geometry_context_ostream_wrapper.html">GeometryContextOstreamWrapper</a>&lt; <a class="el" href="#a2ae67591c6ce6b42568881be16f29ddc">Surface</a> &gt; Acts::Surface::toStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper method for printing: the returned object captures the surface and the geometry context and will print the surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapper object for printing </dd></dl>

</div>
</div>
<a id="a10a856c74db9fae99306dd602e6c7e2b" name="a10a856c74db9fae99306dd602e6c7e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a856c74db9fae99306dd602e6c7e2b">&#9670;&#160;</a></span>toStreamImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::ostream &amp; Acts::Surface::toStreamImpl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>sl</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output Method for std::ostream, to be overloaded by child classes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
    <tr><td class="paramname">sl</td><td>is the ostream to be dumped into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the output stream for chaining </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_perigee_surface.html#ad683910f8e9bb1c5adc77811a8467250">Acts::PerigeeSurface</a>.</p>

</div>
</div>
<a id="a515ea8fa9c29a662c544c2a24c87aa0a" name="a515ea8fa9c29a662c544c2a24c87aa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515ea8fa9c29a662c544c2a24c87aa0a">&#9670;&#160;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::Surface::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output into a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String representation of the surface </dd></dl>

</div>
</div>
<a id="a363ac85362ba9b62f3efc30ef5fc67f6" name="a363ac85362ba9b62f3efc30ef5fc67f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363ac85362ba9b62f3efc30ef5fc67f6">&#9670;&#160;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp; Acts::Surface::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return method for the surface Transform3 by reference In case a detector element is associated the surface transform is just forwarded to the detector element in order to keep the (mis-)alignment cache cetrally handled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gctx</td><td>The current geometry context object, e.g. alignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the contextual transform </dd></dl>

</div>
</div>
<a id="a0bc615a9e492d2b1771368b7bf297921" name="a0bc615a9e492d2b1771368b7bf297921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc615a9e492d2b1771368b7bf297921">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0">SurfaceType</a> Acts::Surface::type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return method for the Surface type to avoid dynamic casts. </p>
<dl class="section return"><dt>Returns</dt><dd>The surface type enumeration value </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_cone_surface.html#a1615c6196ef1195776e744ad674e9a8c">Acts::ConeSurface</a>, <a class="el" href="class_acts_1_1_cylinder_surface.html#ab8367176d30e1fb4bf496f64f8b3b59e">Acts::CylinderSurface</a>, <a class="el" href="class_acts_1_1_disc_surface.html#a1ef89d27db93ac548d79b718340b780c">Acts::DiscSurface</a>, <a class="el" href="class_acts_1_1_perigee_surface.html#a2c55b049f9b6c6b39e60117bda7ca38d">Acts::PerigeeSurface</a>, <a class="el" href="class_acts_1_1_plane_surface.html#a377d8c83034163242b7a900e4347824c">Acts::PlaneSurface</a>, and <a class="el" href="class_acts_1_1_straw_surface.html#ae0ac05c8992b5af1ea4208c17b98badc">Acts::StrawSurface</a>.</p>

</div>
</div>
<a id="a3804756230f7ae5fa25064364c973789" name="a3804756230f7ae5fa25064364c973789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3804756230f7ae5fa25064364c973789">&#9670;&#160;</a></span>visualize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Surface::visualize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_i_visualization3_d.html">IVisualization3D</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>helper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_view_config.html">ViewConfig</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>viewConfig</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#a0e88165f9dc20c209a6761493b8eb986">s_viewSurface</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visualize the surface for debugging and inspection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">helper</td><td>Visualization helper for 3D rendering </td></tr>
    <tr><td class="paramname">gctx</td><td>Geometry context for coordinate transformations </td></tr>
    <tr><td class="paramname">viewConfig</td><td>Visual configuration (color, style, etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a7eda0c0d3b018eedb1e25709205535db" name="a7eda0c0d3b018eedb1e25709205535db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eda0c0d3b018eedb1e25709205535db">&#9670;&#160;</a></span>m_associatedDetElement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_detector_element_base.html">DetectorElementBase</a>* Acts::Surface::m_associatedDetElement {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the a DetectorElementBase. </p>

</div>
</div>
<a id="ad93d06dd89550599358d40fce528f9c7" name="ad93d06dd89550599358d40fce528f9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93d06dd89550599358d40fce528f9c7">&#9670;&#160;</a></span>m_associatedLayer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_layer.html">Layer</a>* Acts::Surface::m_associatedLayer {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The associated layer Layer - layer in which the Surface is be embedded, nullptr if not associated. </p>

</div>
</div>
<a id="aee29c91f9347fe7b9080679dc20164b8" name="aee29c91f9347fe7b9080679dc20164b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee29c91f9347fe7b9080679dc20164b8">&#9670;&#160;</a></span>m_associatedTrackingVolume</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a>* Acts::Surface::m_associatedTrackingVolume {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The associated TrackingVolume - tracking volume in case the surface is a boundary surface, nullptr if not associated. </p>

</div>
</div>
<a id="a14688579dc8bbd516c0a3f264afc17fe" name="a14688579dc8bbd516c0a3f264afc17fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14688579dc8bbd516c0a3f264afc17fe">&#9670;&#160;</a></span>m_surfaceMaterial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a>&gt; Acts::Surface::m_surfaceMaterial</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possibility to attach a material description. </p>

</div>
</div>
<a id="acc5413d1678ec7d5b2f67498b0b38cfa" name="acc5413d1678ec7d5b2f67498b0b38cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5413d1678ec7d5b2f67498b0b38cfa">&#9670;&#160;</a></span>m_transform</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a>&gt; Acts::Surface::m_transform {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform3 definition that positions (translation, rotation) the surface in global space. </p>

</div>
</div>
<a id="a599b254f27b5f548f8be5f3d899fee9a" name="a599b254f27b5f548f8be5f3d899fee9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599b254f27b5f548f8be5f3d899fee9a">&#9670;&#160;</a></span>s_surfaceTypeNames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::string_view, <a class="el" href="#a34fd1452f7603ef1f072d3c3233f9ba0a5ce17ecad7b6bed89667ea05c9b618bc">Surface::SurfaceType::Other</a> + 1&gt; Acts::Surface::s_surfaceTypeNames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {<span class="stringliteral">&quot;Cone&quot;</span>,  <span class="stringliteral">&quot;Cylinder&quot;</span>, <span class="stringliteral">&quot;Disc&quot;</span>,        <span class="stringliteral">&quot;Perigee&quot;</span>,</div>
<div class="line">                            <span class="stringliteral">&quot;Plane&quot;</span>, <span class="stringliteral">&quot;Straw&quot;</span>,    <span class="stringliteral">&quot;Curvilinear&quot;</span>, <span class="stringliteral">&quot;Other&quot;</span>}</div>
</div><!-- fragment -->
<p>Helper strings for screen output. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="class_acts_1_1_surface.html">Surface</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
