<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Track Event Data Model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__eventdata__tracks.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Track Event Data Model <div class="ingroups"><a class="el" href="group__eventdata.html">Event Data Model</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>High-level Track Event Data Model. </p>
<h1 class="doxsection"><a class="anchor" id="edm_Tracks"></a>
High-level Track Event Data Model</h1>
<p>Track information in ACTS can be divided into two parts: track-level information and track state-level information.</p>
<p>Track-level information are properties that relate to the full track. This includes the fitted track parameters with respect to some reference point, often the origin of the detector or the beamspot. It can also include summary information from the track finding stage, like the overall number of clusters that were used in the creation of the track, or the fit quality from the track fit.</p>
<p>Tracks are built-up from track states, where each track state corresponds to a discrete state determining the track properties. This mainly includes measurements states, expected intersections with sensors where no measurement was found (<em>holes</em>), and intersections with known passive material. The EDM allows building up a track from these track states iteratively. For example, the Kalman Filter will append track states to the sequence whenever it encounters a sensitive detector layer. The content of the track states is defined such that the fitter can store all relevant information, with as little need for extra information as possible. It is also designed to be flexible enough to support different fitters, which might require different information to be stored, as well as the Combinatorial Kalman Filter, which produces a tree of track states, instead of a fully linear sequence.</p>
<p>Ultimately, each output track is associated with a well-defined sequence of track states, allowing downstream consumers of the EDM to access the fully detailed information produced during track reconstruction.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="edm_track_conceptual"></a>
Conceptual</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Architecture</h3>
<p>The Track EDM is structured such that the memory-layout can be SoA, while presenting an object-oriented interface for convenient usage.</p>
<p>The image below shows this object-oriented access model for the example of the track container and track proxy object. The track container holds vectors of the various pieces of information, and has methods to add a track, and to allow iteration over all tracks. This iteration, or index based access, yields a track proxy object, which exposes the properties as methods returning references, while internally only holding a pointer to and an index into the track container. The types are built in a way that preserves const-correctness, i.e. even though a track proxy is a value type which can be copied, it will not allow modification of the underlying track container if it is immutable:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mutableTrackContainer = <span class="comment">/*...*/</span>;</div>
<div class="line"><span class="keyword">auto</span> trackProxy = mutableTrackContainer.getTrack(5); <span class="comment">// is mutable</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; constTrackProxy = trackProxy; <span class="comment">// is const</span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">auto</span> constTrackContainer = <span class="comment">/*...*/</span>;</div>
<div class="line"><span class="keyword">auto</span> trackProxy = trackContainer.getTrack(5); <span class="comment">// is const, even as an lvalue</span></div>
</div><!-- fragment --><p><img src="edm/proxy.png" alt="Illustration of the proxy pattern used in the track EDM. The track proxy logically represents a single track, and points to the data stored in the track container." class="inline"/></p>
<p>The track EDM is fully agnostic to the concrete persistency framework of an experiment. This avoids having to convert the data between different representations, if implemented correctly.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Implementation</h3>
<p>To make the EDM implementation independent of an experiment persistency framework, it is separated into a <em>frontend layer</em> and a <em>backend layer</em>. The frontend layer contains user-facing getters and setters, as well as convenience methods that can be helpful. These methods are located either in the proxy objects or in the containers, depending on whether they operate on a single element or the entire container.</p>
<p>Overall, there are four main classes that make up the frontend layer: <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>, <a class="el" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a>, <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a> and <a class="el" href="class_acts_1_1_multi_trajectory.html">Acts::MultiTrajectory</a>. The latter serves as the track state container, where the name indicates that it is able to handle a branching tree structure of track states. <span class="tt">TrackProxy</span> and <span class="tt">TrackStateProxy</span> expose methods to get the local track parameters and covariance, corresponding reference surface, and also includes global statistics like the total number of measurements, outliers or holes in case of <span class="tt">TrackProxy</span>. <span class="tt">TrackProxy</span> also has a method to conveniently iterate over the associated track states from the last track state to the first one yielding <span class="tt">TrackStateProxy</span> objects from the track state container. In the common case of a track from the center of a cylindrical detector going outward, the default iteration order is from the outside inwards.</p>
<p>In case of <span class="tt">TrackStateProxy</span>, functionality is exposed in the frontend layer to allocate optional components, with the goal of reduced memory footprint. There are two main use cases of this: track parameters and measurements. The track-state EDM supports storing up to three sets of local track parameters and covariance matrices, modeled after the information the Kalman Filter formalism needs to store:</p>
<ol type="1">
<li>predicted parameter vector and covariance matrix</li>
<li>filtered parameter vector and covariance matrix</li>
<li>smoothed parameter vector and covariance matrix</li>
</ol>
<p>In case of combinatorial track finding (see <a class="el" href="group__track__finding.html">Track Finding</a>), specifically <a class="el" href="class_acts_1_1_combinatorial_kalman_filter.html">Acts::CombinatorialKalmanFilter</a>, track hypothesis can start out with a common sequence of track states, and then branch out when multiple compatible measurements are encountered, as seen in the track state picture.</p>
<p>The track state EDM allows allocating only the track parameters that are needed, and also allows sharing the same track parameters between multiple track states, so that branching track states can share for example the same predicted parameters. How this is achieved exactly is left to the backend layer. Measurements are handled in a similar way, where the track finding decides how much storage is needed based on the number of dimensions of an incoming measurement. It then instructs the EDM through the frontend layer to ensure enough memory is available, where the specifics are again left up to the backend layer.</p>
<p>The backend layer exposes an interface that is used by the frontend layer to store and retrieve information. It uses dedicated methods where needed, such as for storing reference surfaces or source-link objects, which are lightweight container objects for experiment-specific measurements. For the majority of components, the frontend communicates with the backend through a single method to obtain references to the underlying data. Components are accessed via hashes of the component name, where the hashes are calculated at compile-time wherever possible. The backend can then use the hashed component name to retrieve the relevant memory. To allow directly manipulating the backing memory, the frontend expects the backend to return references into the backing storage.</p>
<p><span class="tt">TrackProxy</span> provides a method to copy a track between different track containers, and only uses the frontend layer to accomplish this. This means that copying tracks between different backend implementations is trivial.</p>
<div class="image">
<object type="image/svg+xml" data="edm_diagram.svg" style="pointer-events: none;"></object>
<div class="caption">
Diagram of the EDM architecture. The frontend layer is used by other ACTS components, and downstream clients. It is separated from the backend layer by an interface. Conversion to and from EDM4hep is possible. Examples of direct backend implementations are shown.</div></div>
<p>The picture above shows a diagram of the EDM architecture. At the center are the <span class="tt">TrackProxy</span> and <span class="tt">TrackContainer</span>. These classes are produced by the track finding and track fitting components, and are the main interface point with the clients of tracking. In ACTS itself, all of the performance monitoring and downstream reconstruction is either directly built on top of these objects, or converts them into an internal EDM on the use case. Behind the backend interface, the track container coordinates with both a track state and a track backend, where a few examples are shown, and will be discussed below.</p>
<h2 class="doxsection"><a class="anchor" id="edm_track_iteration"></a>
Track state iteration and forward linking</h2>
<p>By default, track states are connected as a one-directional linked list, where each track state knows its <em>previous</em> track state. The picture below shows an example of a track state tree, like it is constructed by the combinatorial track finding.</p>
<p>In the picture states \(S_7\) and \(S_6\) are the two tip states of the track state tree, while \(S_1\) is the single stem state. In the case of combinatorial track finding starting from e.g. a seed, it could be the location of the innermost space point.</p>
<div class="image">
<object type="image/svg+xml" data="ckf_tree.svg" width="400px" style="pointer-events: none;"></object>
<div class="caption">
Illustration of a branching multi-trajectory that is created during combinatorial track finding.</div></div>
<p>Each track object points at a single tip state to define its track state sequence. The <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a> class has various methods to access the track state sequence:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> track = getTrackFromSomewhere();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> trackState : track.trackStatesReversed()) {</div>
<div class="line">  <span class="comment">// do something with track state</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that <a class="el" href="class_acts_1_1_track_proxy.html#a21b592cb22e3005dd443518e14e65ca8">Acts::TrackProxy::trackStatesReversed</a> iterates from the tip state to the stem state, i.e. from the outside in.</p>
<dl class="section important"><dt>Important</dt><dd>By-default, it is not possible to iterate <em>forward</em> through the track states on a track! The track's track states need to be <em>forward-linked</em> for this to be possible.</dd></dl>
<p>The reason for this is: As the trajectory branches at the second sensor into \(S_2\)/ \(S_3\), it is not possible to connect the states forward, i.e. store in \(S_1\) what the <em>next</em> state is going to be: it is ambiguous!</p>
<p>However, when track finding has concluded, and the trajectories identified by tip states \(S_7\) and \(S_8\) have been discarded or are being copied into an output container, it is possible to <em>forward link</em> the track state sequences. This is possible <b>if</b> the trajectory does not branch anymore! <a class="el" href="class_acts_1_1_track_proxy.html#a793408c3dc8b7a8ad271ef0697c1d505">Acts::TrackProxy::copyFrom</a> will implicitly forward link the track states, as it is guaranteed to not branch after copying.</p>
<p>You can manually add forward-linking to a track by calling <a class="el" href="class_acts_1_1_track_proxy.html#a3fa764ebfee2c55a8c5b55f45703c218">Acts::TrackProxy::linkForward</a> or <a class="el" href="class_acts_1_1_track_proxy.html#a513c1a064775db25e7f6bdf8de92eac8">Acts::TrackProxy::reverseTrackStates</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Calling either <a class="el" href="class_acts_1_1_track_proxy.html#a3fa764ebfee2c55a8c5b55f45703c218">Acts::TrackProxy::linkForward</a> or <a class="el" href="class_acts_1_1_track_proxy.html#a513c1a064775db25e7f6bdf8de92eac8">Acts::TrackProxy::reverseTrackStates</a> on a track state sequence which has branching will break the branching! If you have other tracks pointing at a tip state that branches from the sequence you're trying to forward-link, it will be corrupted!</dd></dl>
<p>In this example, before any forward linking, the sequence looks like this:</p>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_1.svg" width="563" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>After a copy operation of \(S_6\) and \(S_7\) the resulting track state sequences will look like this:</p>
<div class="dotgraph">
<iframe scrolling="no" loading="lazy" frameborder="0" src="dot_inline_dotgraph_2.svg" width="515" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<p>This now includes both forward and backward links, which allows iteration from \(S_1\)/ \(S_2\) to \(S_6\)/ \(S_7\) and the other way around.</p>
<p>Forward iteration can then be achieved like this:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> track = getTrackFromSomewhere();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> trackState : track.trackStates()) {</div>
<div class="line">  <span class="comment">// iterate forward</span></div>
<div class="line">  <span class="comment">// do something with track state</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>and the innermost track state becomes directly accessible via <a class="el" href="class_acts_1_1_track_proxy.html#a65ac57a6f3a555c919c8e7d3decff957">Acts::TrackProxy::innermostTrackState</a>.</p>
<dl class="section important"><dt>Important</dt><dd>If the track container has branching track state sequences, running a smoothing step in-place on branching tracks is problematic: if tracks are smoothed one by one, the last track of each shared track state (i.e. the track state where branching occurs) will overwrite the smoothing result of all previous tracks. <br  />
<br  />
 Consider again the track states in the picture above. \(S_1\) is the common ancestor for \(S_2\) and \(S_3\), and has a single slot to store smoothed parameters. If smoothing happens for the track ending in \(S_6\), then smoothing the track ending in \(S_7\) only the values written by the final smoothing of \(S_3\) will survive in \(S_1\)'s storage. This can be unexpected!</dd></dl>
<h2 class="doxsection"><a class="anchor" id="track_edm_component_sharing"></a>
Component sharing</h2>
<p><a class="el" href="class_acts_1_1_multi_trajectory.html">Acts::MultiTrajectory</a> is designed so that components can be shared between track states. This can be achieved using the <a class="el" href="class_acts_1_1_track_state_proxy.html#a95304204468f54911b50a674f7ada1d6">Acts::TrackStateProxy::shareFrom</a> can be used to set this up.</p>
<p>Shareable components are</p>
<ul>
<li>predicted parameters and covariance</li>
<li>filtered parameters and covariance</li>
<li>smoothed parameters and covariance</li>
<li>jacobian</li>
</ul>
<p>To illustrate why this can be useful, consider again the track state picture, where \(S_2\) and \(S_3\) branch out from a shared \(S_1\). In this case, the predicted parameter vector and covariance, as well as the jacobian from \(S_1\to S_2\) and \(S_1 \to S_3\) will be identical. In this case, the combinatorial track finding will use the sharing functionality to share these components.</p>
<dl class="section important"><dt>Important</dt><dd>Sharing these components introduces <em>cross-talk</em> between track states, and this is intentional. If e.g. the predicted covariance is modified through either of the track states, the changes will be visible when accessed from the other track state as well.</dd></dl>
<h2 class="doxsection"><a class="anchor" id="track_edm_dynamic_columns"></a>
Dynamic columns</h2>
<p>Aside from the static properties that both the track states and the track have, the EDM supports adding almost arbitrary additional information as dynamic columns. The implementation of the dynamic column mechanism is given by the backend, where the interface layer classes <a class="el" href="class_acts_1_1_multi_trajectory.html">Acts::MultiTrajectory</a> and <a class="el" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> and associated proxies only coordinate the creation, access and copying of dynamic columns.</p>
<p>The following illustrates the usage of dynamic columns for <a class="el" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a>, but usage on <a class="el" href="class_acts_1_1_multi_trajectory.html">Acts::MultiTrajectory</a> is identical.</p>
<p>Assume you create a track container using some combination of backends (see <a class="el" href="#edm_track_backends">Track EDM backends</a> for information on the backends shipped with ACTS).</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> tc{<span class="comment">/*...*/</span>};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// add dynamic columns programmatically</span></div>
<div class="line"> </div>
<div class="line">tc.<a class="code hl_function" href="class_acts_1_1_track_container.html#ab4c3f89e93d7c7bd40ae3c36c66359d9">addColumn</a>&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;col_a&quot;</span>);</div>
<div class="line">tc.<a class="code hl_function" href="class_acts_1_1_track_container.html#ab4c3f89e93d7c7bd40ae3c36c66359d9">addColumn</a>&lt;uint8_t&gt;(<span class="stringliteral">&quot;col_b&quot;</span>);</div>
<div class="ttc" id="aclass_acts_1_1_track_container_html"><div class="ttname"><a href="class_acts_1_1_track_container.html">Acts::TrackContainer</a></div><div class="ttdoc">Track container interface class.</div><div class="ttdef"><b>Definition</b> TrackContainer.hpp:41</div></div>
<div class="ttc" id="aclass_acts_1_1_track_container_html_ab4c3f89e93d7c7bd40ae3c36c66359d9"><div class="ttname"><a href="class_acts_1_1_track_container.html#ab4c3f89e93d7c7bd40ae3c36c66359d9">Acts::TrackContainer::addColumn</a></div><div class="ttdeci">constexpr void addColumn(std::string_view key)</div><div class="ttdoc">Add a dynamic column to the track container.</div><div class="ttdef"><b>Definition</b> TrackContainer.hpp:258</div></div>
</div><!-- fragment --><p>Adding columns is only supported on <em>mutable</em> track containers, const track containers should contain the original dynamic columns from when they were created. It is up to the backend to implement recovering dynamic columns from e.g. input files.</p>
<dl class="section note"><dt>Note</dt><dd>Which types are supported depends on the backend being used. See <a class="el" href="#edm_track_backends">Track EDM backends</a> for information on the backends shipped with ACTS, and which types they support.</dd></dl>
<p>With these dynamic columns registered, it is now possible to set and get values for these columns on tracks.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>Acts::HashedStringLiterals;</div>
<div class="line"><span class="keyword">auto</span> track = tc.<a class="code hl_function" href="class_acts_1_1_track_container.html#ac25da78703f2ec2067986edf9a767370">makeTrack</a>();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// these two are equivalent</span></div>
<div class="line">track.<a class="code hl_function" href="class_acts_1_1_track_proxy.html#a47b29d9988c9b0c3b7b86e44a1f5525e">component</a>&lt;float, <span class="stringliteral">&quot;col_a&quot;</span>_hash&gt;() = 42.42;</div>
<div class="line">track.component&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;col_a&quot;</span>_hash) = 52.52;</div>
<div class="line">std::cout &lt;&lt; track.component&lt;float, <span class="stringliteral">&quot;col_a&quot;</span>_hash&gt;() &lt;&lt; std::endl; <span class="comment">// prints: 52.52</span></div>
<div class="ttc" id="aclass_acts_1_1_track_container_html_ac25da78703f2ec2067986edf9a767370"><div class="ttname"><a href="class_acts_1_1_track_container.html#ac25da78703f2ec2067986edf9a767370">Acts::TrackContainer::makeTrack</a></div><div class="ttdeci">TrackProxy makeTrack()</div><div class="ttdoc">Add a track to the container and return a track proxy to it This effectively calls addTrack and getTr...</div><div class="ttdef"><b>Definition</b> TrackContainer.hpp:202</div></div>
<div class="ttc" id="aclass_acts_1_1_track_proxy_html_a47b29d9988c9b0c3b7b86e44a1f5525e"><div class="ttname"><a href="class_acts_1_1_track_proxy.html#a47b29d9988c9b0c3b7b86e44a1f5525e">Acts::TrackProxy::component</a></div><div class="ttdeci">constexpr T &amp; component()</div><div class="ttdoc">Retrieve a mutable reference to a component.</div><div class="ttdef"><b>Definition</b> TrackProxy.hpp:664</div></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The expression <span class="tt">"col_a"_hash</span> is a user-defined literal that internally calls <br  />
<br  />
 <div class="fragment"><div class="line">Acts::hashedString(<span class="stringliteral">&quot;col_a&quot;</span>);</div>
</div><!-- fragment --> <br  />
<br  />
 This literal is only available after <br  />
<br  />
 <div class="fragment"><div class="line"><span class="keyword">using namespace </span>Acts::HashedStringLiterals;</div>
</div><!-- fragment --></dd></dl>
<p>The components are accessed by a hash of the name of the component. This hash can be calculated from a string at compile-time, if the string is known at compile time. The difference between the two component access signatures is that in the first case, the hash of the component is guaranteed to be evaluated at compile-time, since it is given to the <span class="tt">component</span> function as a template argument. A third option is available to access components: see <a class="el" href="#edm_track_accessors">Accessors</a>.</p>
<h2 class="doxsection"><a class="anchor" id="edm_track_accessors"></a>
Accessors</h2>
<p>It can be inconvenient to have to write the full component access signature, especially if you want to access the same components repeatedly. An alternative are <b>accessors</b>. They encapsulate the type of the component, and the component name hash into an object:</p>
<div class="fragment"><div class="line"><span class="comment">// definition of the accessor with a type and the name of the component</span></div>
<div class="line"><a class="code hl_typedef" href="namespace_acts.html#a79f3daeca2329cfd19dc3baa49e667d0">Acts::ProxyAccessor&lt;float&gt;</a> extra(<span class="stringliteral">&quot;extra&quot;</span>);</div>
<div class="line"><span class="comment">// component access by calling it on a proxy</span></div>
<div class="line">extra(track) = 42.2;</div>
<div class="line">std::cout &lt;&lt; extra(track) &lt;&lt; std::endl; <span class="comment">// prints 42.2</span></div>
<div class="ttc" id="anamespace_acts_html_a79f3daeca2329cfd19dc3baa49e667d0"><div class="ttname"><a href="namespace_acts.html#a79f3daeca2329cfd19dc3baa49e667d0">Acts::ProxyAccessor</a></div><div class="ttdeci">ProxyAccessorBase&lt; T, false &gt; ProxyAccessor</div><div class="ttdoc">Type alias for a mutable proxy accessor.</div><div class="ttdef"><b>Definition</b> ProxyAccessor.hpp:116</div></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>The same accessor also works for <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a> objects, as it shares the same component access mechanism with <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>.</dd></dl>
<p>The above accessor is a <b>mutable</b> accessor, meaning it can only be used with mutable proxy objects!</p>
<div class="fragment"><div class="line">ConstTrackProxy&lt;...&gt; constTrack = <span class="comment">/*...*/</span>;</div>
<div class="line">extra(constTrack); <span class="comment">// this will give a compile error!</span></div>
</div><!-- fragment --><p>To access properties on const proxy objects, you need to use a dedicated accessor type:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespace_acts.html#ae0e74469e9117c4b3731cf556cbf832a">Acts::ConstProxyAccessor&lt;float&gt;</a> extraConst(<span class="stringliteral">&quot;extra&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; extraConst(constTrack) &lt;&lt; std::endl; <span class="comment">// prints 42.2</span></div>
<div class="line"><span class="comment">// using the const accessor on a mutable proxy also works</span></div>
<div class="line">std::cout &lt;&lt; extraConst(track) &lt;&lt; std::endl; <span class="comment">// prints 42.2</span></div>
<div class="ttc" id="anamespace_acts_html_ae0e74469e9117c4b3731cf556cbf832a"><div class="ttname"><a href="namespace_acts.html#ae0e74469e9117c4b3731cf556cbf832a">Acts::ConstProxyAccessor</a></div><div class="ttdeci">ProxyAccessorBase&lt; T, true &gt; ConstProxyAccessor</div><div class="ttdoc">Type alias for a const proxy accessor.</div><div class="ttdef"><b>Definition</b> ProxyAccessor.hpp:121</div></div>
</div><!-- fragment --><p>For both const and mutable proxy accessors you do not actually need a mutable reference, as the internal accessor state is not mutated after construction. You can safely use a static instance of these accessors to avoid constructing them over and over again:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;TrackProxyConcept track_proxy_t&gt;</div>
<div class="line"><span class="keywordtype">void</span> doSomething(track_proxy_t track, <span class="keywordtype">float</span> value) {</div>
<div class="line">    <span class="comment">// only created once, never changed</span></div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_typedef" href="namespace_acts.html#a79f3daeca2329cfd19dc3baa49e667d0">Acts::ProxyAccessor&lt;float&gt;</a> extra(<span class="stringliteral">&quot;extra&quot;</span>);</div>
<div class="line">    extra(track) = value;</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Holders</h2>
<p>The <a class="el" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> implements a mechanism to optionally own the backends that it is constructed with. This is implemented using a <em>holder</em> type, which is passed either as a template parameter, or deduced automatically.</p>
<p>Available default holders are:</p>
<ul>
<li><span class="tt">Acts::detail::RefHolder</span> which does not own the backends</li>
<li><span class="tt">Acts::detail::ConstRefHolder</span> which does not own the backends and does not permit mutations.</li>
<li><span class="tt">Acts::detail::ValueHolder</span> which owns the backends by value. This is auto-deduced if the backends are given as values or rvalue-references.</li>
</ul>
<p>Other user-specified holders can also be used, for example, it is possible to use <span class="tt">std::shared_ptr</span> as a holder directly, like:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Acts::VectorTrackContainer&gt; vtc{</div>
<div class="line">    std::make_shared&lt;Acts::VectorTrackContainer&gt;()};</div>
<div class="line">std::shared_ptr&lt;Acts::VectorMultiTrajectory&gt; mtj{</div>
<div class="line">    std::make_shared&lt;Acts::VectorMultiTrajectory&gt;()};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="class_acts_1_1_track_container.html">Acts::TrackContainer&lt;Acts::VectorTrackContainer, Acts::VectorMultiTrajectory, std::shared_ptr&gt;</a></div>
<div class="line">tc{vtc, mtj};</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
How to create a track from scratch</h3>
<p>Tracks can be created directly from the EDM interface. You start by creating or obtaining a mutable track container:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> tc{<a class="code hl_class" href="class_acts_1_1_vector_track_container.html">Acts::VectorTrackContainer</a>{}, Acts::VectorMutiTrajectory{}};</div>
<div class="ttc" id="aclass_acts_1_1_vector_track_container_html"><div class="ttname"><a href="class_acts_1_1_vector_track_container.html">Acts::VectorTrackContainer</a></div><div class="ttdef"><b>Definition</b> VectorTrackContainer.hpp:211</div></div>
</div><!-- fragment --><p>A single track can be added like this:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> track = tc.<a class="code hl_function" href="class_acts_1_1_track_container.html#ac25da78703f2ec2067986edf9a767370">makeTrack</a>();</div>
<div class="line"><span class="comment">// set some properties</span></div>
<div class="line">track.<a class="code hl_function" href="class_acts_1_1_track_proxy.html#ad17d90489f76fa4e7340cdd219e2bd5e">parameters</a>() &lt;&lt; 0.1_mm, 3_mm, 1/20_GeV, 0.2, 0.4, 25_mm;</div>
<div class="line">track.setReferenceSurface(</div>
<div class="line">    Acts::Surface::makeSurface&lt;Acts::PerigeeSurface&gt;(Acts::Vector3::Zero()));</div>
<div class="ttc" id="aclass_acts_1_1_track_proxy_html_ad17d90489f76fa4e7340cdd219e2bd5e"><div class="ttname"><a href="class_acts_1_1_track_proxy.html#ad17d90489f76fa4e7340cdd219e2bd5e">Acts::TrackProxy::parameters</a></div><div class="ttdeci">ConstParameters parameters() const</div><div class="ttdoc">Get the parameters of the track at the reference surface (e.g.</div><div class="ttdef"><b>Definition</b> TrackProxy.hpp:207</div></div>
</div><!-- fragment --><p>The track is still lacking track states. You can <em>append</em> track states to the track, which means that a track state is attached behind the outermost track state currently assigned.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ts1 = track.appendTrackState();</div>
<div class="line">ts1.smoothed() &lt;&lt; 0.4_um, 1_mm, 1/19_GeV, 0.21, 0.37, 40_ns;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keyword">auto</span> ts2 = track.appendTrackState();</div>
<div class="line">ts2.smoothed() &lt;&lt; 0.4_um, 1_mm, 1/19_GeV, 0.21, 0.37, 40_ns;</div>
</div><!-- fragment --><p>Note that this means that you have to create track state from the inside out! If you have to add track states from the outside in, you can still append them and reverse the track at the very end.</p>
<div class="fragment"><div class="line">track.reverseTrackStates();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="edm_track_backends"></a>
Track EDM backends</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Backends shipped with ACTS</h3>
<h4 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Transient vector backend</h4>
<p>The transient vector backend implements the reference backend for the track EDM. It does not implement any persistency directly. The implementation of this backend for both track and track state containers uses separate classes for the mutable and const versions, in order to fully comply with const correctness. It also uses a common base class internally, which is however an implementation detail.</p>
<p>To build a track container with this backend, you can write</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_acts_1_1_vector_multi_trajectory.html">Acts::VectorMultiTrajectory</a> mtj{};</div>
<div class="line"><a class="code hl_class" href="class_acts_1_1_vector_track_container.html">Acts::VectorTrackContainer</a> vtc{};</div>
<div class="line"><a class="code hl_class" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> tc{vtc, mtj};</div>
<div class="ttc" id="aclass_acts_1_1_vector_multi_trajectory_html"><div class="ttname"><a href="class_acts_1_1_vector_multi_trajectory.html">Acts::VectorMultiTrajectory</a></div><div class="ttdoc">In-memory transient multi-trajectory implementation using std::vector as backend.</div><div class="ttdef"><b>Definition</b> VectorMultiTrajectory.hpp:387</div></div>
</div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_acts_1_1_const_vector_track_container.html">Acts::ConstVectorTrackContainer</a> vtc{<span class="comment">/* ... */</span>};</div>
<div class="line"><a class="code hl_class" href="class_acts_1_1_const_vector_multi_trajectory.html">Acts::ConstVectorMultiTrajectory</a> mtj{<span class="comment">/* ... */</span>};</div>
<div class="line"><a class="code hl_class" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> ctc{vtc, mtj};</div>
<div class="ttc" id="aclass_acts_1_1_const_vector_multi_trajectory_html"><div class="ttname"><a href="class_acts_1_1_const_vector_multi_trajectory.html">Acts::ConstVectorMultiTrajectory</a></div><div class="ttdoc">Const version of VectorMultiTrajectory.</div><div class="ttdef"><b>Definition</b> VectorMultiTrajectory.hpp:569</div></div>
<div class="ttc" id="aclass_acts_1_1_const_vector_track_container_html"><div class="ttname"><a href="class_acts_1_1_const_vector_track_container.html">Acts::ConstVectorTrackContainer</a></div><div class="ttdef"><b>Definition</b> VectorTrackContainer.hpp:290</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>There are currently no restrictions on types that can be used as dynamic columns. Any type can be stored and retrieved back from the backend. <br  />
<br  />
 Keep in mind that the transient vector backend does not support persistency, meaning that there is no mechanism to serialize dynamic columns (or static columns for that matter) to disk and read them back in.</dd></dl>
<h4 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
PODIO backend</h4>
<p>The PODIO track EDM backend shipped with the library uses a custom PODIO-EDM defined in <span class="tt">edm.yml</span> in the ACTS core repository.</p>
<p>The working model is this:</p>
<ol type="1">
<li><p class="startli">Mutable PODIO track and track state backends are created with a <a class="el" href="#podio_helper">helper</a></p>
<div class="fragment"><div class="line">Acts::MutablePodioTrackStateContainer tsc{helper};</div>
<div class="line">Acts::MutablePodioTrackContainer ptc{helper};</div>
</div><!-- fragment --></li>
<li><p class="startli">A track container is built using these PODIO backend instances</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="class_acts_1_1_track_container.html">Acts::TrackContainer</a> tc{ptc, tsc};</div>
</div><!-- fragment --></li>
<li><p class="startli">The track container is used by some algorithm</p>
<div class="fragment"><div class="line">tc.<a class="code hl_function" href="class_acts_1_1_track_container.html#ac25da78703f2ec2067986edf9a767370">makeTrack</a>();</div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --></li>
<li><p class="startli">The mutable backends <em>released into</em> a <span class="tt">podio::Frame</span> for writing.</p>
<div class="fragment"><div class="line">ptc.releaseInto(frame);</div>
<div class="line">tsc.releaseInto(frame);</div>
<div class="line"><span class="comment">// write frame</span></div>
</div><!-- fragment --></li>
<li><p class="startli">When reading, const track state and track PODIO backends are created from a <span class="tt">podio::Frame</span></p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> frame = <span class="comment">/* read frame */</span>;</div>
<div class="line">Acts::ConstPodioTrackStateContainer tsc{helper, frame};</div>
<div class="line">Acts::ConstPodioTrackContainer ptc{helper, frame};</div>
</div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The PODIO backend currently supports all types that can be written to a <span class="tt">podio::UserDataCollection</span> for dynamic columns. At the time of writing these are: <span class="tt">float</span>, <span class="tt">double</span>, <span class="tt">int8_t</span>, <span class="tt">int16_t</span>, <span class="tt">int32_t</span>, <span class="tt">int64_t</span>, <span class="tt">uint8_t</span>, <span class="tt">uint16_t</span>, <span class="tt">uint32_t</span>, <span class="tt">uint64_t</span>. <br  />
<br  />
 In particular, it is not possible to write <span class="tt">bool</span> values directly. A workaround is using <span class="tt">uint8_t</span> and making boolean expressions explicit.</dd></dl>
<h5 class="doxsection"><a class="anchor" id="podio_helper"></a>
Helper for <span class="tt">Surface</span>s and <span class="tt">SourceLink</span>s</h5>
<p>PODIO cannot directly store <a class="el" href="class_acts_1_1_surface.html">Acts::Surface</a> and <a class="el" href="class_acts_1_1_source_link.html">Acts::SourceLink</a> instances. The PODIO backends rely on a helper class that implements the following <a class="el" href="class_acts_plugins_1_1_podio_util_1_1_conversion_helper.html">ActsPlugins::PodioUtil::ConversionHelper</a> interface.</p>
<p>Specifically, the PODIO backends will, before persisting and after reading, consult the helper object to convert between an in-memory <a class="el" href="class_acts_1_1_surface.html">Acts::Surface</a> and an optional identifier. The identifier a 64-bit integer whose interpretation can depend on the experiment, it could be a sensor index (hash in ATLAS) for example.</p>
<p>If no identifier is returned, that means the surface is not expressible as an identifier, and it needs to be persisted directly, which is implemented centrally. In that case, the defining parameters of the surface are saved, and the object is rebuilt when reading. An example of this is in the case of a reference surface like a perigee surface that represents the beam axis, which is not commonly identified in the experiment geometry.</p>
<p>A similar mechanism is used for source links. Remember that <a class="el" href="class_acts_1_1_source_link.html">Acts::SourceLink</a> is type-erased proxy object that stands for an experiment-specific <em>uncalibrated</em> measurement. As such, the PODIO backend cannot directly store these. For use with the PODIO backends, source links need to be convertible to and from 64-bit integers, with the help of the helper object, that can communicate with the experiment infrastructure.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
How to build a backend</h3>
<p>Both track and track state backends need to conform to respective concepts. Effectively, the backend has to allow for collection functionality, like getting the current size etc.</p>
<p>Further, the backend needs to respond to queries for properties of the elements, where the element is identified by an index.</p>
<p>The backend needs to flag itself as mutable or const, by specializing</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>IsReadOnlyMultiTrajectory;</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>IsReadOnlyTrackContainer;</div>
</div><!-- fragment --><p>This informs the interface layer to permit or prevent mutable access.</p>
<p>Common between both track and track state backends is the component access. Here, the component is identified by a compile-time string hash of the component name, which the backend responds to by a type-erased mutable or const pointer. There is a hard requirement for the backend to return stable pointers here, as the interface layer expects this and exposes this in the API.</p>
<p>This can be accomplished like in the transient backend with a <span class="tt">switch</span>-statements like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span> (key) {</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;previous&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_previous[istate];</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;next&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_next[istate];</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;predicted&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].ipredicted;</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;filtered&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].ifiltered;</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;smoothed&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].ismoothed;</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;projector&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_projectors[instance.m_index[istate].iprojector];</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;measdim&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].measdim;</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;chi2&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].chi2;</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;pathLength&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].pathLength;</div>
<div class="line">  <span class="keywordflow">case</span> <span class="stringliteral">&quot;typeFlags&quot;</span>_hash:</div>
<div class="line">    <span class="keywordflow">return</span> &amp;m_index[istate].typeFlags;</div>
<div class="line">  <span class="keywordflow">default</span>:</div>
<div class="line">    <span class="comment">// handle dynamic columns</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <span class="tt">default</span> statement deals with <a class="el" href="#track_edm_dynamic_columns">Dynamic columns</a>. For support of dynamic columns, the backend needs to implement <span class="tt">hasColumn_impl</span> to return if a column exists, mutable backends need to implement <span class="tt">addColumn_impl</span> which adds a column with a type and a string name. <span class="tt">copyDynamicFrom_impl</span> and <span class="tt">ensureDynamicColumn_impl</span> on mutable backends allows copying dynamic content between container backends. <span class="tt">dynamicKeys_impl</span> returns an iterator pair that informs the caller of which dynamic keys are registered. This is also used in dynamic column copies.</p>
<p>Both backend types return parameter vectors and covariance matrices. This is always done as <span class="tt">Eigen</span> maps, which have reference semantics into the backing storage.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
TrackContainer backend</h4>
<ul>
<li>Mutable &amp; const<ul>
<li>Get size</li>
<li>Reference parameter vector and covariance matrix access</li>
<li>Get if column exists</li>
<li>Get reference surface (returns <span class="tt">const Surface*</span>)</li>
<li>Get particle hypothesis (returns by-value, so allows on-the-fly creation)</li>
<li>Get dynamic keys</li>
<li>Type-erased component access</li>
</ul>
</li>
<li>Mutable<ul>
<li>Add and remove a track</li>
<li>Add column</li>
<li>Ensure dynamic columns, copy dynamic columns</li>
<li>Reserve number of entries</li>
<li>Set reference surface</li>
<li>Set particle hypothesis</li>
<li>Clear the container</li>
</ul>
</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
MultiTrajectory (track state) backend</h4>
<p>The track state container can <a class="el" href="#track_edm_component_sharing">share components</a>. This is implemented for the shareable components by the interface layer looking up a <em>component</em> that stores an index into a separate shareable-component-container. Then, functions exists which return <span class="tt">Eigen</span> maps into the relevant backend storage based on the index looked up as a component before.</p>
<p>The track state container also handles <em>calibrated</em> measurement in a packed way. This is to say, that for $N$ dimensional measurement, the backend can store only the dimension $N$ and then $N$ numbers representing the measurement vector and \(N\times N\) numbers for the associated covariance matrix. To enable this, a mutable backend exposes <span class="tt">allocateCalibrated_impl</span> which accepts a track state index and the measurement size, and ensures storage is available to hand out a reference into associated backing storage. An example is the transient vector backend, which stores the offset into measurement and covariance matrix vector, and ensures its size is consistent.</p>
<p>In both cases above, the <em>absence</em> of the value can be indicated by setting the indices to the sentinel value <span class="tt">kInvalid</span>. The backend also has query methods that test if the index is invalid and return a boolean.</p>
<p>The track state container also stores <span class="tt">SourceLink</span>s, which are assigned by value and returned by value, which allows the backend to unpack assigned source links and repackage uncalibrated measurement references back into a source link when returning.</p>
<ul>
<li>Mutable &amp; const<ul>
<li>Get the calibrated measurement dimension (<em>size</em>)</li>
<li>Get uncalibrated source link</li>
<li>Get reference surface</li>
<li>Get parameter from <em>parameter</em> index</li>
<li>Get covariance from <em>covariance</em> index</li>
<li>Get jacobian from <em>jacobian</em> index</li>
<li>Get measurement vector given compile-time measurement dimension</li>
<li>Get measurement covariance matrix given compile-time measurement dimension</li>
<li>Check if an optional component is set</li>
<li>Get the container size</li>
<li>Type-erased component access</li>
<li>Get if column exists</li>
<li>Get dynamic keys</li>
</ul>
</li>
<li>Mutable<ul>
<li>Add a track state</li>
<li>Share track state components from another track state of the same container (otherwise no sharing is supported)</li>
<li>Unset an optional component</li>
<li>Clear the container</li>
<li>Add column</li>
<li>Ensure dynamic columns, copy dynamic columns</li>
<li>Set an uncalibrated source link that is passed by value</li>
<li>Set the reference surface </li>
</ul>
</li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Acts_3A_3AConstVectorMultiTrajectory" id="r_Acts_3A_3AConstVectorMultiTrajectory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_const_vector_multi_trajectory.html">Acts::ConstVectorMultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const version of <a class="el" href="class_acts_1_1_vector_multi_trajectory.html">VectorMultiTrajectory</a>.  <a href="class_acts_1_1_const_vector_multi_trajectory.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AVectorMultiTrajectory" id="r_Acts_3A_3AVectorMultiTrajectory"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_vector_multi_trajectory.html">Acts::VectorMultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-memory transient multi-trajectory implementation using <code>std::vector</code> as backend.  <a href="class_acts_1_1_vector_multi_trajectory.html#details">More...</a><br /></td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
