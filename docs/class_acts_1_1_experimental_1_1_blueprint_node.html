<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::Experimental::BlueprintNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_experimental_1_1_blueprint_node.html','','class_acts_1_1_experimental_1_1_blueprint_node-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::Experimental::BlueprintNode Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Base class for all nodes in the blueprint tree.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_blueprint_node_8hpp_source.html">Acts/Geometry/BlueprintNode.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::Experimental::BlueprintNode:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_experimental_1_1_blueprint_node__inherit__graph.svg" width="100%" height="530"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a501c1d101d1d16b7fbda97a69275c5db" id="r_a501c1d101d1d16b7fbda97a69275c5db"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a501c1d101d1d16b7fbda97a69275c5db">ChildRange</a></td></tr>
<tr class="memdesc:a501c1d101d1d16b7fbda97a69275c5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range-like object that allows range based for loops and index access.  <br /></td></tr>
<tr class="memitem:a994fb12006f54cb73cd1f5877af84e9a" id="r_a994fb12006f54cb73cd1f5877af84e9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a994fb12006f54cb73cd1f5877af84e9a">MutableChildRange</a></td></tr>
<tr class="memdesc:a994fb12006f54cb73cd1f5877af84e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range-like object that allows range based for loops and index access.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21404680be31c52acd7bc3928aae8d6c" id="r_a21404680be31c52acd7bc3928aae8d6c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21404680be31c52acd7bc3928aae8d6c">~BlueprintNode</a> ()=default</td></tr>
<tr class="memdesc:a21404680be31c52acd7bc3928aae8d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor to ensure correct cleanup.  <br /></td></tr>
<tr class="memitem:a9a43b266c627448fdf5f6d74175599ba" id="r_a9a43b266c627448fdf5f6d74175599ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_blueprint_node.html">BlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a43b266c627448fdf5f6d74175599ba">addChild</a> (std::shared_ptr&lt; <a class="el" href="class_acts_1_1_experimental_1_1_blueprint_node.html">BlueprintNode</a> &gt; child)</td></tr>
<tr class="memdesc:a9a43b266c627448fdf5f6d74175599ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <code class="param">child</code> to this node.  <br /></td></tr>
<tr class="memitem:a810366ba164a82461cc68654146c89f5" id="r_a810366ba164a82461cc68654146c89f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a810366ba164a82461cc68654146c89f5">addToGraphviz</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a810366ba164a82461cc68654146c89f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method that writes a representatiohn of <b>this node only</b> to graphviz.  <br /></td></tr>
<tr class="memitem:a68c731fc92bb0591a762291edfe26853" id="r_a68c731fc92bb0591a762291edfe26853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a994fb12006f54cb73cd1f5877af84e9a">MutableChildRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68c731fc92bb0591a762291edfe26853">children</a> ()</td></tr>
<tr class="memdesc:a68c731fc92bb0591a762291edfe26853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="#a994fb12006f54cb73cd1f5877af84e9a">MutableChildRange</a> to the children of this node.  <br /></td></tr>
<tr class="memitem:a22b0fa07bcffbaf88c5f1e2769e2c85b" id="r_a22b0fa07bcffbaf88c5f1e2769e2c85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a501c1d101d1d16b7fbda97a69275c5db">ChildRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22b0fa07bcffbaf88c5f1e2769e2c85b">children</a> () const</td></tr>
<tr class="memdesc:a22b0fa07bcffbaf88c5f1e2769e2c85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="#a501c1d101d1d16b7fbda97a69275c5db">ChildRange</a> to the children of this node.  <br /></td></tr>
<tr class="memitem:ab5059dc79aeb6191490b295fa3718cbc" id="r_ab5059dc79aeb6191490b295fa3718cbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5059dc79aeb6191490b295fa3718cbc">clearChildren</a> ()</td></tr>
<tr class="memdesc:ab5059dc79aeb6191490b295fa3718cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all children from this node.  <br /></td></tr>
<tr class="memitem:aad22d59cc879cf384d911ae3460436d9" id="r_aad22d59cc879cf384d911ae3460436d9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad22d59cc879cf384d911ae3460436d9">depth</a> () const</td></tr>
<tr class="memdesc:aad22d59cc879cf384d911ae3460436d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the depth of this node in the blueprint tree.  <br /></td></tr>
<tr class="memitem:af2a9e5c389279f756bc3060cd4cc7bd0" id="r_af2a9e5c389279f756bc3060cd4cc7bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2a9e5c389279f756bc3060cd4cc7bd0">graphviz</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:af2a9e5c389279f756bc3060cd4cc7bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the node tree starting from this node to graphviz format.  <br /></td></tr>
<tr class="memitem:a27c855b45607a85e12b9acd9f0d0d396" id="r_a27c855b45607a85e12b9acd9f0d0d396"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27c855b45607a85e12b9acd9f0d0d396">name</a> () const =0</td></tr>
<tr class="memdesc:a27c855b45607a85e12b9acd9f0d0d396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this node.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Construction methods</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="construction"></a> These methods constitute the primary interface of the node that participates in the geometry construction. </p>
</div></td></tr>
<tr class="memitem:af87b04cf82d61d54ce93be661fe54973" id="r_af87b04cf82d61d54ce93be661fe54973"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_acts_1_1_volume.html">Volume</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af87b04cf82d61d54ce93be661fe54973">build</a> (const <a class="el" href="struct_acts_1_1_experimental_1_1_blueprint_options.html">BlueprintOptions</a> &amp;options, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())=0</td></tr>
<tr class="memdesc:af87b04cf82d61d54ce93be661fe54973"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called during the <em>build</em> phase of the blueprint tree construction.  <br /></td></tr>
<tr class="memitem:a684e5d8040b99112fc0610470a4fdec2" id="r_a684e5d8040b99112fc0610470a4fdec2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_acts_1_1_portal_shell_base.html">PortalShellBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a684e5d8040b99112fc0610470a4fdec2">connect</a> (const <a class="el" href="struct_acts_1_1_experimental_1_1_blueprint_options.html">BlueprintOptions</a> &amp;options, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())=0</td></tr>
<tr class="memdesc:a684e5d8040b99112fc0610470a4fdec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called during the <em>connect</em> phase.  <br /></td></tr>
<tr class="memitem:abe01cc8091e12cf9c4b2d80096b228e5" id="r_abe01cc8091e12cf9c4b2d80096b228e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe01cc8091e12cf9c4b2d80096b228e5">finalize</a> (const <a class="el" href="struct_acts_1_1_experimental_1_1_blueprint_options.html">BlueprintOptions</a> &amp;options, const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;gctx, <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> &amp;parent, const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;logger=<a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>())=0</td></tr>
<tr class="memdesc:abe01cc8091e12cf9c4b2d80096b228e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called during the <em>finalize</em> phase.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Convenience methods</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="convenience"></a> These methods are meant to make the construction of a blueprint tree in code more ergonomic.</p>
<p>They usually take an optional <span class="tt">callback</span> parameter. The primary use for this parameter is structural, as it facilitates introducing scopes to indicate in code that objects are nested.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct_acts_1_1_experimental_1_1_blueprint_1_1_config.html">Blueprint::Config</a> cfg;</div>
<div class="line"><span class="keyword">auto</span> root = std::make_unique&lt;Blueprint&gt;(cfg);</div>
<div class="line">root-&gt;addStaticVolume(</div>
<div class="line">    base, std::make_shared&lt;CylinderVolumeBounds&gt;(50_mm, 400_mm, 1000_mm),</div>
<div class="line">    <span class="stringliteral">&quot;PixelWrapper&quot;</span>, [&amp;](<span class="keyword">auto</span>&amp; wrapper) {</div>
<div class="line">        <span class="comment">// This scope can be used to equip `wrapper`</span></div>
<div class="line">    });</div>
<div class="ttc" id="astruct_acts_1_1_experimental_1_1_blueprint_1_1_config_html"><div class="ttname"><a href="struct_acts_1_1_experimental_1_1_blueprint_1_1_config.html">Acts::Experimental::Blueprint::Config</a></div><div class="ttdef"><b>Definition</b> Blueprint.hpp:57</div></div>
</div><!-- fragment --><p>Alternatively, they can also be used without a callback, as the newly created node is also returned by reference:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>&amp; wrapper = root-&gt;addStaticVolume(</div>
<div class="line">    base, std::make_shared&lt;CylinderVolumeBounds&gt;(50_mm, 400_mm, 1000_mm),</div>
<div class="line">    <span class="stringliteral">&quot;PixelWrapper&quot;</span>);</div>
</div><!-- fragment --><p>In both cases, it's not necessary to register the newly created node with a parent node. </p>
</div></td></tr>
<tr class="memitem:a8196ac8d54cfc536e604ccd450db440e" id="r_a8196ac8d54cfc536e604ccd450db440e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8196ac8d54cfc536e604ccd450db440e">addStaticVolume</a> (std::unique_ptr&lt; <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> &gt; volume, const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp;cylinder)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:a8196ac8d54cfc536e604ccd450db440e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method creates a new <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">Acts::Experimental::StaticBlueprintNode</a> wrapping <code class="param">volume</code> and adds it to this node as a child.  <br /></td></tr>
<tr class="memitem:a4d465fa8e7c554371948f88676f5cafe" id="r_a4d465fa8e7c554371948f88676f5cafe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d465fa8e7c554371948f88676f5cafe">addStaticVolume</a> (const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;transform, std::shared_ptr&lt; <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &gt; volumeBounds, const std::string &amp;volumeName=&quot;undefined&quot;, const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp;cylinder)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:a4d465fa8e7c554371948f88676f5cafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative overload for creating a <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">Acts::Experimental::StaticBlueprintNode</a>.  <br /></td></tr>
<tr class="memitem:ab37e810457bda21e91496f878bbb6ae8" id="r_ab37e810457bda21e91496f878bbb6ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_cylinder_container_blueprint_node.html">CylinderContainerBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37e810457bda21e91496f878bbb6ae8">addCylinderContainer</a> (const std::string &amp;<a class="el" href="#a27c855b45607a85e12b9acd9f0d0d396">name</a>, <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> direction, const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_cylinder_container_blueprint_node.html">CylinderContainerBlueprintNode</a> &amp;cylinder)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:ab37e810457bda21e91496f878bbb6ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for creating a cylinder specialization of <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a>.  <br /></td></tr>
<tr class="memitem:ada21b76a1d0bcb9a2e603fb2158f9ff3" id="r_ada21b76a1d0bcb9a2e603fb2158f9ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_cuboid_container_blueprint_node.html">CuboidContainerBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada21b76a1d0bcb9a2e603fb2158f9ff3">addCuboidContainer</a> (const std::string &amp;<a class="el" href="#a27c855b45607a85e12b9acd9f0d0d396">name</a>, <a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">AxisDirection</a> direction, const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_cuboid_container_blueprint_node.html">CuboidContainerBlueprintNode</a> &amp;cylinder)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:ada21b76a1d0bcb9a2e603fb2158f9ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for creating a cuboid specialization of <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a>.  <br /></td></tr>
<tr class="memitem:a431c9aba7dbb886114c806daac14d685" id="r_a431c9aba7dbb886114c806daac14d685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">MaterialDesignatorBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a431c9aba7dbb886114c806daac14d685">addMaterial</a> (const std::string &amp;<a class="el" href="#a27c855b45607a85e12b9acd9f0d0d396">name</a>, const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">MaterialDesignatorBlueprintNode</a> &amp;material)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:a431c9aba7dbb886114c806daac14d685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for creating a <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">Acts::Experimental::MaterialDesignatorBlueprintNode</a>.  <br /></td></tr>
<tr class="memitem:a593584f2d0922457be11657bd7b4e875" id="r_a593584f2d0922457be11657bd7b4e875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html">LayerBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a593584f2d0922457be11657bd7b4e875">addLayer</a> (const std::string &amp;<a class="el" href="#a27c855b45607a85e12b9acd9f0d0d396">name</a>, const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html">LayerBlueprintNode</a> &amp;layer)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:a593584f2d0922457be11657bd7b4e875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for creating a <a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html">Acts::Experimental::LayerBlueprintNode</a>.  <br /></td></tr>
<tr class="memitem:a0713aa5610507915b006068628189f20" id="r_a0713aa5610507915b006068628189f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html">GeometryIdentifierBlueprintNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0713aa5610507915b006068628189f20">withGeometryIdentifier</a> (const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html">GeometryIdentifierBlueprintNode</a> &amp;geometryIdentifier)&gt; &amp;callback={})</td></tr>
<tr class="memdesc:a0713aa5610507915b006068628189f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for creating a <a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html">Acts::Experimental::GeometryIdentifierBlueprintNode</a>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0541ff1002e34a883939d99d391e3d93" id="r_a0541ff1002e34a883939d99d391e3d93"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0541ff1002e34a883939d99d391e3d93">indent</a> () const</td></tr>
<tr class="memdesc:a0541ff1002e34a883939d99d391e3d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">An indentation depending on the depth of this node.  <br /></td></tr>
<tr class="memitem:ad75331d0d8fc351edc7f4d2ad4c6112f" id="r_ad75331d0d8fc351edc7f4d2ad4c6112f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad75331d0d8fc351edc7f4d2ad4c6112f">prefix</a> () const</td></tr>
<tr class="memdesc:ad75331d0d8fc351edc7f4d2ad4c6112f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Printing helper returning a prefix including an indent depending on the depth.  <br /></td></tr>
<tr class="memitem:a73967eb21671e0288459d92cadedff08" id="r_a73967eb21671e0288459d92cadedff08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73967eb21671e0288459d92cadedff08">setDepth</a> (std::size_t <a class="el" href="#aad22d59cc879cf384d911ae3460436d9">depth</a>)</td></tr>
<tr class="memdesc:a73967eb21671e0288459d92cadedff08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the depth to <code class="param">depth</code> and update children recursively.  <br /></td></tr>
<tr class="memitem:a8bc53378fbe2b2034b3b73142de9ba48" id="r_a8bc53378fbe2b2034b3b73142de9ba48"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bc53378fbe2b2034b3b73142de9ba48">toStream</a> (std::ostream &amp;os) const</td></tr>
<tr class="memdesc:a8bc53378fbe2b2034b3b73142de9ba48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual method to determine stream representation.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for all nodes in the blueprint tree. </p>
<p>This class defines the three-phase construction process. The three phases are</p>
<ol type="1">
<li><b>Build</b>: Construct volume representation + compute final sizing</li>
<li><b>Connect</b>: Create and connect portals at volume boundaries</li>
<li><b>Finalize</b>: Register portals with volumes + create acceleration structures</li>
</ol>
<p>During the <em>build</em> phase, the <span class="tt">build</span> method of all nodes in the tree are called recursively. Some nodes, like <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a>, will take action on the volumes returns from its children, and perform sizing to connect them. See the <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a> and <a class="el" href="class_acts_1_1_cylinder_volume_stack.html">Acts::CylinderVolumeStack</a> documentation for details on how the sizing is carried out. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a501c1d101d1d16b7fbda97a69275c5db" name="a501c1d101d1d16b7fbda97a69275c5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501c1d101d1d16b7fbda97a69275c5db">&#9670;&#160;</a></span>ChildRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a501c1d101d1d16b7fbda97a69275c5db">Acts::Experimental::BlueprintNode::ChildRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> Acts::detail::TransformRange&lt;</div>
<div class="line">      Acts::detail::ConstDereference,</div>
<div class="line">      <span class="keyword">const</span> std::vector&lt;std::shared_ptr&lt;BlueprintNode&gt;&gt;&gt;</div>
</div><!-- fragment -->
<p>A range-like object that allows range based for loops and index access. </p>
<p>This type's iterators and accessors return const references when dereferenced. </p>

</div>
</div>
<a id="a994fb12006f54cb73cd1f5877af84e9a" name="a994fb12006f54cb73cd1f5877af84e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994fb12006f54cb73cd1f5877af84e9a">&#9670;&#160;</a></span>MutableChildRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a994fb12006f54cb73cd1f5877af84e9a">Acts::Experimental::BlueprintNode::MutableChildRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      Acts::detail::TransformRange&lt;Acts::detail::Dereference,</div>
<div class="line">                                   std::vector&lt;std::shared_ptr&lt;BlueprintNode&gt;&gt;&gt;</div>
</div><!-- fragment -->
<p>A range-like object that allows range based for loops and index access. </p>
<p>This type's iterators and accessors return mutable references when dereferenced. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a21404680be31c52acd7bc3928aae8d6c" name="a21404680be31c52acd7bc3928aae8d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21404680be31c52acd7bc3928aae8d6c">&#9670;&#160;</a></span>~BlueprintNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Acts::Experimental::BlueprintNode::~BlueprintNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor to ensure correct cleanup. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a9a43b266c627448fdf5f6d74175599ba" name="a9a43b266c627448fdf5f6d74175599ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a43b266c627448fdf5f6d74175599ba">&#9670;&#160;</a></span>addChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_blueprint_node.html">BlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addChild </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_acts_1_1_experimental_1_1_blueprint_node.html">BlueprintNode</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>child</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a <code class="param">child</code> to this node. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method throws if adding the child would create a cycle in the blueprint tree! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference this node (not the child!) </dd></dl>

</div>
</div>
<a id="ada21b76a1d0bcb9a2e603fb2158f9ff3" name="ada21b76a1d0bcb9a2e603fb2158f9ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada21b76a1d0bcb9a2e603fb2158f9ff3">&#9670;&#160;</a></span>addCuboidContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_cuboid_container_blueprint_node.html">CuboidContainerBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addCuboidContainer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">AxisDirection</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_cuboid_container_blueprint_node.html">CuboidContainerBlueprintNode</a> &amp;cylinder)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for creating a cuboid specialization of <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the container node. This name is only reflected in the node tree for debugging, as no extra volumes is created for the container. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction of the stack configuration. See <a class="el" href="class_acts_1_1_cuboid_volume_stack.html">Acts::CuboidVolumeStack</a> for details. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly created cuboid container blueprint node </dd></dl>

</div>
</div>
<a id="ab37e810457bda21e91496f878bbb6ae8" name="ab37e810457bda21e91496f878bbb6ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37e810457bda21e91496f878bbb6ae8">&#9670;&#160;</a></span>addCylinderContainer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_cylinder_container_blueprint_node.html">CylinderContainerBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addCylinderContainer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a1462738699cb376ae92c59811987f4ea">AxisDirection</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_cylinder_container_blueprint_node.html">CylinderContainerBlueprintNode</a> &amp;cylinder)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for creating a cylinder specialization of <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the container node. This name is only reflected in the node tree for debugging, as no extra volumes is created for the container. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction of the stack configuration. See <a class="el" href="class_acts_1_1_cylinder_volume_stack.html">Acts::CylinderVolumeStack</a> for details. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly created cylinder container blueprint node </dd></dl>

</div>
</div>
<a id="a593584f2d0922457be11657bd7b4e875" name="a593584f2d0922457be11657bd7b4e875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593584f2d0922457be11657bd7b4e875">&#9670;&#160;</a></span>addLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html">LayerBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html">LayerBlueprintNode</a> &amp;layer)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for creating a <a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html">Acts::Experimental::LayerBlueprintNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the layer node. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly created layer blueprint node </dd></dl>

</div>
</div>
<a id="a431c9aba7dbb886114c806daac14d685" name="a431c9aba7dbb886114c806daac14d685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431c9aba7dbb886114c806daac14d685">&#9670;&#160;</a></span>addMaterial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">MaterialDesignatorBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addMaterial </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">MaterialDesignatorBlueprintNode</a> &amp;material)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for creating a <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">Acts::Experimental::MaterialDesignatorBlueprintNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the material designator node. Used for debugging the node tree only. </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly created material designator blueprint node </dd></dl>

</div>
</div>
<a id="a4d465fa8e7c554371948f88676f5cafe" name="a4d465fa8e7c554371948f88676f5cafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d465fa8e7c554371948f88676f5cafe">&#9670;&#160;</a></span>addStaticVolume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addStaticVolume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__algebra__types.html#ga0b5cf144852112b0c7f251a493d8877e">Transform3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>transform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="class_acts_1_1_volume_bounds.html">VolumeBounds</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>volumeBounds</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>volumeName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;undefined&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp;cylinder)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternative overload for creating a <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">Acts::Experimental::StaticBlueprintNode</a>. </p>
<p>This overload will invoke the constructor of <a class="el" href="class_acts_1_1_tracking_volume.html">Acts::TrackingVolume</a> and use that volume to create the node. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform of the volume </td></tr>
    <tr><td class="paramname">volumeBounds</td><td>The bounds of the volume </td></tr>
    <tr><td class="paramname">volumeName</td><td>The name of the volume </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly created static blueprint node </dd></dl>

</div>
</div>
<a id="a8196ac8d54cfc536e604ccd450db440e" name="a8196ac8d54cfc536e604ccd450db440e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8196ac8d54cfc536e604ccd450db440e">&#9670;&#160;</a></span>addStaticVolume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::addStaticVolume </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">StaticBlueprintNode</a> &amp;cylinder)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method creates a new <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html">Acts::Experimental::StaticBlueprintNode</a> wrapping <code class="param">volume</code> and adds it to this node as a child. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume to add </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the created node </dd></dl>

</div>
</div>
<a id="a810366ba164a82461cc68654146c89f5" name="a810366ba164a82461cc68654146c89f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810366ba164a82461cc68654146c89f5">&#9670;&#160;</a></span>addToGraphviz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Acts::Experimental::BlueprintNode::addToGraphviz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method that writes a representatiohn of <b>this node only</b> to graphviz. </p>
<p>This should generally not be called on its own, but through the <a class="el" href="#af2a9e5c389279f756bc3060cd4cc7bd0">BlueprintNode::graphviz</a> method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream to print to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_experimental_1_1_blueprint.html#add0bbf0e1d96e8980854251f7e9ca4e1">Acts::Experimental::Blueprint</a>, <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html#abd7f186fe0c48a6069a64c94ae313c93">Acts::Experimental::ContainerBlueprintNode</a>, and <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html#a359fcd8b29c17433806c04b432f3749b">Acts::Experimental::StaticBlueprintNode</a>.</p>

</div>
</div>
<a id="af87b04cf82d61d54ce93be661fe54973" name="af87b04cf82d61d54ce93be661fe54973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87b04cf82d61d54ce93be661fe54973">&#9670;&#160;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_acts_1_1_volume.html">Volume</a> &amp; Acts::Experimental::BlueprintNode::build </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_experimental_1_1_blueprint_options.html">BlueprintOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called during the <em>build</em> phase of the blueprint tree construction. </p>
<p>It returns a single <a class="el" href="class_acts_1_1_volume.html">Acts::Volume</a> which represents transform and bounds of the entire subtree. This does not have to correspond to the final <a class="el" href="class_acts_1_1_tracking_volume.html">Acts::TrackingVolume</a>, some node types will produce temporary volume representations. Lifetime of the returned volume is managed by the source node! Nodes higher in the hierarchy will issue resizes down the tree hierarchy. This is not done through a direct hierarchy, but coordinated by the respective node type, by internally consulting its children.</p>
<dl class="section note"><dt>Note</dt><dd>Generally, you should not need to to call this method directly. The construction should usually be done through the special <a class="el" href="class_acts_1_1_experimental_1_1_blueprint.html">Acts::Experimental::Blueprint</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The global construction options </td></tr>
    <tr><td class="paramname">gctx</td><td>The geometry context for construction (usually nominal) </td></tr>
    <tr><td class="paramname">logger</td><td>The logger to use for output during construction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The volume used for communicating transform and size up the hierarchy </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_experimental_1_1_blueprint.html#a4362b093496c57ff81472dbf067721c6">Acts::Experimental::Blueprint</a>, <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html#a59dfe459210a7e15350683925a420fe6">Acts::Experimental::ContainerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html#a3e9f6cc226d0c21171c6493fcff56c6c">Acts::Experimental::GeometryIdentifierBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html#ab3164b57756a452d37e0d3083c47ef04">Acts::Experimental::LayerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html#aa5f49503206d5ed8c795183288d305af">Acts::Experimental::MaterialDesignatorBlueprintNode</a>, and <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html#a31d7c7031078df74a7d330ddba9f1a64">Acts::Experimental::StaticBlueprintNode</a>.</p>

</div>
</div>
<a id="a68c731fc92bb0591a762291edfe26853" name="a68c731fc92bb0591a762291edfe26853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c731fc92bb0591a762291edfe26853">&#9670;&#160;</a></span>children() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a994fb12006f54cb73cd1f5877af84e9a">MutableChildRange</a> Acts::Experimental::BlueprintNode::children </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="#a994fb12006f54cb73cd1f5877af84e9a">MutableChildRange</a> to the children of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A range-like object to the children </dd></dl>

</div>
</div>
<a id="a22b0fa07bcffbaf88c5f1e2769e2c85b" name="a22b0fa07bcffbaf88c5f1e2769e2c85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b0fa07bcffbaf88c5f1e2769e2c85b">&#9670;&#160;</a></span>children() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a501c1d101d1d16b7fbda97a69275c5db">ChildRange</a> Acts::Experimental::BlueprintNode::children </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="#a501c1d101d1d16b7fbda97a69275c5db">ChildRange</a> to the children of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>A range-like object to the children </dd></dl>

</div>
</div>
<a id="ab5059dc79aeb6191490b295fa3718cbc" name="ab5059dc79aeb6191490b295fa3718cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5059dc79aeb6191490b295fa3718cbc">&#9670;&#160;</a></span>clearChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Experimental::BlueprintNode::clearChildren </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all children from this node. </p>

</div>
</div>
<a id="a684e5d8040b99112fc0610470a4fdec2" name="a684e5d8040b99112fc0610470a4fdec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684e5d8040b99112fc0610470a4fdec2">&#9670;&#160;</a></span>connect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_acts_1_1_portal_shell_base.html">PortalShellBase</a> &amp; Acts::Experimental::BlueprintNode::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_experimental_1_1_blueprint_options.html">BlueprintOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called during the <em>connect</em> phase. </p>
<p>This phase handles the creation and connection of <em>portals</em> (instances of <a class="el" href="class_acts_1_1_portal_link_base.html">Acts::PortalLinkBase</a>). After the build-phase has completed, the volume sizes are <b>final</b>. Each node will consult its fully sized volume to produce <em>boundary surfaces</em>. Each boundary surface is then turned into a <a class="el" href="class_acts_1_1_trivial_portal_link.html">Acts::TrivialPortalLink</a>, which in turn produces a one-sided portal (see <a class="el" href="class_acts_1_1_portal.html">Acts::Portal</a> documentation)</p>
<p>Some nodes (like <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html">Acts::Experimental::ContainerBlueprintNode</a>) will take action on their children, and unify the connected portals.</p>
<p>After a node's processing has completed, it returns a reference to a <a class="el" href="class_acts_1_1_portal_shell_base.html">Acts::PortalShellBase</a>, which represents a set of portals in a specific geometry arrangement. The returned object lifetime is managed by the returning node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The global construction options </td></tr>
    <tr><td class="paramname">gctx</td><td>The geometry context for construction (usually nominal) </td></tr>
    <tr><td class="paramname">logger</td><td>The logger to use for output during construction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to portal shell containing connected portals for this node </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_experimental_1_1_blueprint.html#a40b0d6177b79a43364e48781b8a68ea5">Acts::Experimental::Blueprint</a>, <a class="el" href="class_acts_1_1_experimental_1_1_cuboid_container_blueprint_node.html#ad78c71b3d0a7c81a68d28f169b4025af">Acts::Experimental::CuboidContainerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_cylinder_container_blueprint_node.html#ad52d344bbf0243fd775841b133f00066">Acts::Experimental::CylinderContainerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html#a1ec9b14f92a90157e4fc3c36c40dfb56">Acts::Experimental::GeometryIdentifierBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html#a3e11728e8fc0edda54d89d94530f0b7a">Acts::Experimental::MaterialDesignatorBlueprintNode</a>, and <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html#a66cf7a4cb7b00c71bc6d6b3836b37970">Acts::Experimental::StaticBlueprintNode</a>.</p>

</div>
</div>
<a id="aad22d59cc879cf384d911ae3460436d9" name="aad22d59cc879cf384d911ae3460436d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad22d59cc879cf384d911ae3460436d9">&#9670;&#160;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Acts::Experimental::BlueprintNode::depth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the depth of this node in the blueprint tree. </p>
<p>A depth of zero means this node does not have a parent. </p><dl class="section return"><dt>Returns</dt><dd>The depth of this node </dd></dl>

</div>
</div>
<a id="abe01cc8091e12cf9c4b2d80096b228e5" name="abe01cc8091e12cf9c4b2d80096b228e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe01cc8091e12cf9c4b2d80096b228e5">&#9670;&#160;</a></span>finalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Acts::Experimental::BlueprintNode::finalize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_acts_1_1_experimental_1_1_blueprint_options.html">BlueprintOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_geometry_context.html">GeometryContext</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_tracking_volume.html">TrackingVolume</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac3958b2d3af64792cac019893486c394">Acts::getDummyLogger</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called during the <em>finalize</em> phase. </p>
<p>This phase handles:</p>
<ul>
<li>Registering portals into their final volumes</li>
<li>Registering volumes into their parents</li>
<li>Creating navigation policies</li>
<li>(In future) Handle geometry identification assignment</li>
</ul>
<p>At the end of this phase, each node will have transferred any temporary resources created during the build, that need to be retained, into the final <a class="el" href="class_acts_1_1_tracking_geometry.html">Acts::TrackingGeometry</a>, and can be safely destroyed.</p>
<dl class="section note"><dt>Note</dt><dd>The <code class="param">parent</code> for volumes, portals, etc to be registered in is passed in <b>as an argument</b>, rather than being implicitly determined from the <b>parent node</b>. This is done so that nodes can remove themselves from the final volume hierarchy, like container nodes or the <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html">Acts::Experimental::MaterialDesignatorBlueprintNode</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>The global construction options </td></tr>
    <tr><td class="paramname">gctx</td><td>The geometry context for construction (usually nominal) </td></tr>
    <tr><td class="paramname">parent</td><td>The parent volume to register in </td></tr>
    <tr><td class="paramname">logger</td><td>The logger to use for output during construction </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="class_acts_1_1_experimental_1_1_blueprint.html#a6f53930f44f8440fe065374eb253c946">Acts::Experimental::Blueprint</a>, <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html#a767d325d09991945ef89ffc0e2b7fecf">Acts::Experimental::ContainerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html#a2fb552c74c0f72fdac7900d3bb219488">Acts::Experimental::GeometryIdentifierBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html#ab74e445c558c7e9ff17ea9b397a1282b">Acts::Experimental::MaterialDesignatorBlueprintNode</a>, and <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html#ad6aaad12d8b6d9cc04896b54f6dd32e9">Acts::Experimental::StaticBlueprintNode</a>.</p>

</div>
</div>
<a id="af2a9e5c389279f756bc3060cd4cc7bd0" name="af2a9e5c389279f756bc3060cd4cc7bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a9e5c389279f756bc3060cd4cc7bd0">&#9670;&#160;</a></span>graphviz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Experimental::BlueprintNode::graphviz </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the node tree starting from this node to graphviz format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The stream to print to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0541ff1002e34a883939d99d391e3d93" name="a0541ff1002e34a883939d99d391e3d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0541ff1002e34a883939d99d391e3d93">&#9670;&#160;</a></span>indent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::Experimental::BlueprintNode::indent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An indentation depending on the depth of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The indentation string </dd></dl>

</div>
</div>
<a id="a27c855b45607a85e12b9acd9f0d0d396" name="a27c855b45607a85e12b9acd9f0d0d396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c855b45607a85e12b9acd9f0d0d396">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string &amp; Acts::Experimental::BlueprintNode::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the node name string </dd></dl>

<p>Implemented in <a class="el" href="class_acts_1_1_experimental_1_1_blueprint.html#a595dc0dd2b06d788411abe13231f2238">Acts::Experimental::Blueprint</a>, <a class="el" href="class_acts_1_1_experimental_1_1_container_blueprint_node.html#aed390daa5a7bc8b76966b358f53cb355">Acts::Experimental::ContainerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html#a380eaa4ea80a314f9baa7bcfc8a34322">Acts::Experimental::GeometryIdentifierBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_layer_blueprint_node.html#a4dfd6a8e5598e3379469e37d6c633762">Acts::Experimental::LayerBlueprintNode</a>, <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html#a9888f21ff711da2d5c32bc2c3ef8b17b">Acts::Experimental::MaterialDesignatorBlueprintNode</a>, and <a class="el" href="class_acts_1_1_experimental_1_1_static_blueprint_node.html#a7d6bef7188c98f5458bf99b8868dda46">Acts::Experimental::StaticBlueprintNode</a>.</p>

</div>
</div>
<a id="ad75331d0d8fc351edc7f4d2ad4c6112f" name="ad75331d0d8fc351edc7f4d2ad4c6112f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75331d0d8fc351edc7f4d2ad4c6112f">&#9670;&#160;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Acts::Experimental::BlueprintNode::prefix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Printing helper returning a prefix including an indent depending on the depth. </p>
<dl class="section return"><dt>Returns</dt><dd>The prefix string </dd></dl>

</div>
</div>
<a id="a73967eb21671e0288459d92cadedff08" name="a73967eb21671e0288459d92cadedff08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73967eb21671e0288459d92cadedff08">&#9670;&#160;</a></span>setDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Acts::Experimental::BlueprintNode::setDepth </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>depth</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the depth to <code class="param">depth</code> and update children recursively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>New depth value to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc53378fbe2b2034b3b73142de9ba48" name="a8bc53378fbe2b2034b3b73142de9ba48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc53378fbe2b2034b3b73142de9ba48">&#9670;&#160;</a></span>toStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Acts::Experimental::BlueprintNode::toStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual method to determine stream representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream to write to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method is called by the stream operator. </dd></dl>

<p>Reimplemented in <a class="el" href="class_acts_1_1_experimental_1_1_material_designator_blueprint_node.html#aa3817ba942ef384246cb6efde49a8ea3">Acts::Experimental::MaterialDesignatorBlueprintNode</a>.</p>

</div>
</div>
<a id="a0713aa5610507915b006068628189f20" name="a0713aa5610507915b006068628189f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0713aa5610507915b006068628189f20">&#9670;&#160;</a></span>withGeometryIdentifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html">GeometryIdentifierBlueprintNode</a> &amp; Acts::Experimental::BlueprintNode::withGeometryIdentifier </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(<a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html">GeometryIdentifierBlueprintNode</a> &amp;geometryIdentifier)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience method for creating a <a class="el" href="class_acts_1_1_experimental_1_1_geometry_identifier_blueprint_node.html">Acts::Experimental::GeometryIdentifierBlueprintNode</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>An optional callback that receives the node as an argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newly created geometry identifier blueprint node </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="namespace_acts_1_1_experimental.html">Experimental</a></li><li class="navelem"><a href="class_acts_1_1_experimental_1_1_blueprint_node.html">BlueprintNode</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
