<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_track_state_proxy.html','','class_acts_1_1_track_state_proxy-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Proxy object to access a single point on the trajectory.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_track_state_proxy_8hpp_source.html">Acts/EventData/TrackStateProxy.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt;:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_track_state_proxy__inherit__graph.svg" width="100%" height="522"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_track_state_proxy__coll__graph.svg" width="272" height="320"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1e895ddc7749c062ea1343f4ad891608" id="r_a1e895ddc7749c062ea1343f4ad891608"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a1e895ddc7749c062ea1343f4ad891608 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">Calibrated</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, false&gt;::Calibrated</td></tr>
<tr class="memdesc:a1e895ddc7749c062ea1343f4ad891608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a calibrated measurement vector, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:abe078d39a530a75ce5e36dd39cec3492" id="r_abe078d39a530a75ce5e36dd39cec3492"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:abe078d39a530a75ce5e36dd39cec3492 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">CalibratedCovariance</a></td></tr>
<tr class="memdesc:abe078d39a530a75ce5e36dd39cec3492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a calibrated measurement covariance matrix, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:a6bc7781170388e6a5efc5dbfba2e369b" id="r_a6bc7781170388e6a5efc5dbfba2e369b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a6bc7781170388e6a5efc5dbfba2e369b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bc7781170388e6a5efc5dbfba2e369b">ConstCalibrated</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, true&gt;<a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">::Calibrated</a></td></tr>
<tr class="memdesc:a6bc7781170388e6a5efc5dbfba2e369b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>Calibrated</code>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a105d545b90be92b01c15163e89b8c763" id="r_a105d545b90be92b01c15163e89b8c763"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a105d545b90be92b01c15163e89b8c763 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a105d545b90be92b01c15163e89b8c763">ConstCalibratedCovariance</a></td></tr>
<tr class="memdesc:a105d545b90be92b01c15163e89b8c763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">CalibratedCovariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a04aa68f896e3a74cfc505a953867aa70" id="r_a04aa68f896e3a74cfc505a953867aa70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">::Covariance</a></td></tr>
<tr class="memdesc:a04aa68f896e3a74cfc505a953867aa70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a7fbdcef77447c959db9a629ce2a1a50a" id="r_a7fbdcef77447c959db9a629ce2a1a50a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fbdcef77447c959db9a629ce2a1a50a">ConstEffectiveCalibrated</a></td></tr>
<tr class="memdesc:a7fbdcef77447c959db9a629ce2a1a50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>EffectiveCalibrated</code>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a1ef98ae9574bf01c97c83eb7ab023257" id="r_a1ef98ae9574bf01c97c83eb7ab023257"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef98ae9574bf01c97c83eb7ab023257">ConstEffectiveCalibratedCovariance</a></td></tr>
<tr class="memdesc:a1ef98ae9574bf01c97c83eb7ab023257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a70ad68bbb136d1a602fbec002d79aa65">EffectiveCalibratedCovariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a3b1a94121abb954a002a593bd61ef840" id="r_a3b1a94121abb954a002a593bd61ef840"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b1a94121abb954a002a593bd61ef840">ConstJacobian</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">::Covariance</a></td></tr>
<tr class="memdesc:a3b1a94121abb954a002a593bd61ef840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobian shape is identical to <a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>.  <br /></td></tr>
<tr class="memitem:aeccd8d3a35af248c909696973307e1e8" id="r_aeccd8d3a35af248c909696973307e1e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">::Parameters</a></td></tr>
<tr class="memdesc:aeccd8d3a35af248c909696973307e1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">Parameters</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:ae2d3dcceec1ddf3457f1bc3b18462a3c" id="r_ae2d3dcceec1ddf3457f1bc3b18462a3c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d3dcceec1ddf3457f1bc3b18462a3c">ConstProxyType</a> = <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt;trajectory_t, M, true&gt;</td></tr>
<tr class="memdesc:ae2d3dcceec1ddf3457f1bc3b18462a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an associated const track state proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:a0fb668c32599042bdb52cfa0db146ddb" id="r_a0fb668c32599042bdb52cfa0db146ddb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, false&gt;::Covariance</td></tr>
<tr class="memdesc:a0fb668c32599042bdb52cfa0db146ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a bound covariance.  <br /></td></tr>
<tr class="memitem:abb5a22a568840d5db0b57015c3cdf96a" id="r_abb5a22a568840d5db0b57015c3cdf96a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5a22a568840d5db0b57015c3cdf96a">EffectiveCalibrated</a></td></tr>
<tr class="memdesc:abb5a22a568840d5db0b57015c3cdf96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a measurement vector, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:a70ad68bbb136d1a602fbec002d79aa65" id="r_a70ad68bbb136d1a602fbec002d79aa65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70ad68bbb136d1a602fbec002d79aa65">EffectiveCalibratedCovariance</a></td></tr>
<tr class="memdesc:a70ad68bbb136d1a602fbec002d79aa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a measurement covariance matrix, where the local measurement dimension is variable.  <br /></td></tr>
<tr class="memitem:a88faa591bbaae408e41c6db7fb39e0e5" id="r_a88faa591bbaae408e41c6db7fb39e0e5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> = <a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a></td></tr>
<tr class="memdesc:a88faa591bbaae408e41c6db7fb39e0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type of the track state container.  <br /></td></tr>
<tr class="memitem:aaff8087426b7d32fdb08af4c0fd38381" id="r_aaff8087426b7d32fdb08af4c0fd38381"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaff8087426b7d32fdb08af4c0fd38381">Jacobian</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, false&gt;<a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">::Covariance</a></td></tr>
<tr class="memdesc:aaff8087426b7d32fdb08af4c0fd38381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobian shape is identical to <a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>.  <br /></td></tr>
<tr class="memitem:ac11c999ddcc05da568b3a67de7f9dfe3" id="r_ac11c999ddcc05da568b3a67de7f9dfe3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">Parameters</a> = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, false&gt;::Parameters</td></tr>
<tr class="memdesc:ac11c999ddcc05da568b3a67de7f9dfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a bound parameter vector.  <br /></td></tr>
<tr class="memitem:ab5e5ad251ac9d342e90dfe255b698896" id="r_ab5e5ad251ac9d342e90dfe255b698896"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> = trajectory_t</td></tr>
<tr class="memdesc:ab5e5ad251ac9d342e90dfe255b698896"><td class="mdescLeft">&#160;</td><td class="mdescRight">The track state container backend given as a template parameter.  <br /></td></tr>
<tr class="inherit_header pub_types_class_acts_1_1_track_state_proxy_common"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_class_acts_1_1_track_state_proxy_common')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Types inherited from <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon&lt; TrackStateProxy&lt; trajectory_t, M, true &gt;, true &gt;</a></td></tr>
<tr class="memitem:ae1e81f4a291996c6f5b7f0c7b94b6dca inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_ae1e81f4a291996c6f5b7f0c7b94b6dca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a></td></tr>
<tr class="memdesc:ae1e81f4a291996c6f5b7f0c7b94b6dca inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable Eigen map type for bound track parameters.  <br /></td></tr>
<tr class="memitem:aae5aa77e2e24848e8b241d784ad23dfd inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_aae5aa77e2e24848e8b241d784ad23dfd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a></td></tr>
<tr class="memdesc:aae5aa77e2e24848e8b241d784ad23dfd inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const Eigen map type for bound track parameters.  <br /></td></tr>
<tr class="memitem:a2d98de5976dbf8e189a73f2b8ca219b0 inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_a2d98de5976dbf8e189a73f2b8ca219b0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a></td></tr>
<tr class="memdesc:a2d98de5976dbf8e189a73f2b8ca219b0 inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable Eigen map type for bound track parameter covariance.  <br /></td></tr>
<tr class="memitem:ab0f2f94fc5a3600cc1f61a368e427963 inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_ab0f2f94fc5a3600cc1f61a368e427963"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a></td></tr>
<tr class="memdesc:ab0f2f94fc5a3600cc1f61a368e427963 inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const Eigen map type for bound track parameter covariance.  <br /></td></tr>
<tr class="memitem:a2640cb1596c0c91b3befbfcafd48f170 inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_a2640cb1596c0c91b3befbfcafd48f170"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2640cb1596c0c91b3befbfcafd48f170">EffectiveCalibratedMap</a></td></tr>
<tr class="memdesc:a2640cb1596c0c91b3befbfcafd48f170 inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable Eigen map type for calibrated measurements (dynamic size).  <br /></td></tr>
<tr class="memitem:a13a94a3c1198948a338b43ab31b1edd8 inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_a13a94a3c1198948a338b43ab31b1edd8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a13a94a3c1198948a338b43ab31b1edd8">ConstEffectiveCalibratedMap</a></td></tr>
<tr class="memdesc:a13a94a3c1198948a338b43ab31b1edd8 inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const Eigen map type for calibrated measurements (dynamic size).  <br /></td></tr>
<tr class="memitem:a23a99e03ffbb25cc9a84e325cfbd01cf inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_a23a99e03ffbb25cc9a84e325cfbd01cf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a23a99e03ffbb25cc9a84e325cfbd01cf">EffectiveCalibratedCovarianceMap</a></td></tr>
<tr class="memdesc:a23a99e03ffbb25cc9a84e325cfbd01cf inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable Eigen map type for calibrated measurement covariance (dynamic size).  <br /></td></tr>
<tr class="memitem:a9c0e91c6a1603f6e8dba7c1e00160fd8 inherit pub_types_class_acts_1_1_track_state_proxy_common" id="r_a9c0e91c6a1603f6e8dba7c1e00160fd8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a9c0e91c6a1603f6e8dba7c1e00160fd8">ConstEffectiveCalibratedCovarianceMap</a></td></tr>
<tr class="memdesc:a9c0e91c6a1603f6e8dba7c1e00160fd8 inherit pub_types_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const Eigen map type for calibrated measurement covariance (dynamic size).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a57411fe42df941f900652b5abf8367f4" id="r_a57411fe42df941f900652b5abf8367f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57411fe42df941f900652b5abf8367f4">allocateCalibrated</a> (const Eigen::DenseBase&lt; val_t &gt; &amp;val, const Eigen::DenseBase&lt; cov_t &gt; &amp;cov)</td></tr>
<tr class="memdesc:a57411fe42df941f900652b5abf8367f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize calibrated data from static-size Eigen objects.  <br /></td></tr>
<tr class="memitem:a061b45091e71a2c21bffaf220b074d40" id="r_a061b45091e71a2c21bffaf220b074d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, false &gt;<a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">::Calibrated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a061b45091e71a2c21bffaf220b074d40">calibrated</a> ()</td></tr>
<tr class="memdesc:a061b45091e71a2c21bffaf220b074d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access calibrated measurement data with compile-time dimension.  <br /></td></tr>
<tr class="memitem:a1b3332284b421bd617aafd1534d16df9" id="r_a1b3332284b421bd617aafd1534d16df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, true &gt;<a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">::Calibrated</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3332284b421bd617aafd1534d16df9">calibrated</a> () const</td></tr>
<tr class="memdesc:a1b3332284b421bd617aafd1534d16df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access calibrated measurement data with compile-time dimension.  <br /></td></tr>
<tr class="memitem:a90ab0ce99fd899289a7eccbbc124e7f1" id="r_a90ab0ce99fd899289a7eccbbc124e7f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, false &gt;<a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">::CalibratedCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90ab0ce99fd899289a7eccbbc124e7f1">calibratedCovariance</a> ()</td></tr>
<tr class="memdesc:a90ab0ce99fd899289a7eccbbc124e7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access calibrated covariance data with compile-time dimension.  <br /></td></tr>
<tr class="memitem:ae67a7eb32a22133b667d0341c1265fa6" id="r_ae67a7eb32a22133b667d0341c1265fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, true &gt;<a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">::CalibratedCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae67a7eb32a22133b667d0341c1265fa6">calibratedCovariance</a> () const</td></tr>
<tr class="memdesc:ae67a7eb32a22133b667d0341c1265fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access calibrated covariance data with compile-time dimension.  <br /></td></tr>
<tr class="memitem:a87f65691fe7db92ac5851a22b2fd5291" id="r_a87f65691fe7db92ac5851a22b2fd5291"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87f65691fe7db92ac5851a22b2fd5291">chi2</a> ()</td></tr>
<tr class="memdesc:a87f65691fe7db92ac5851a22b2fd5291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to the local chi2 contribution.  <br /></td></tr>
<tr class="memitem:ad491bca3865ac50502a0184eeda6ac20" id="r_ad491bca3865ac50502a0184eeda6ac20"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad491bca3865ac50502a0184eeda6ac20">chi2</a> () const</td></tr>
<tr class="memdesc:ad491bca3865ac50502a0184eeda6ac20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the local chi2 contribution.  <br /></td></tr>
<tr class="memitem:a9eeeb3cd9207c308fa6bf497318d1f0d" id="r_a9eeeb3cd9207c308fa6bf497318d1f0d"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eeeb3cd9207c308fa6bf497318d1f0d">container</a> ()</td></tr>
<tr class="memdesc:a9eeeb3cd9207c308fa6bf497318d1f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the track state container backend.  <br /></td></tr>
<tr class="memitem:a28f8e6a2a933d5979843a6327d700349" id="r_a28f8e6a2a933d5979843a6327d700349"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28f8e6a2a933d5979843a6327d700349">container</a> () const</td></tr>
<tr class="memdesc:a28f8e6a2a933d5979843a6327d700349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the track state container backend.  <br /></td></tr>
<tr class="memitem:a1dedcbb96a0da5c1fd76879c6f6b371d" id="r_a1dedcbb96a0da5c1fd76879c6f6b371d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dedcbb96a0da5c1fd76879c6f6b371d">covariance</a> () const</td></tr>
<tr class="memdesc:a1dedcbb96a0da5c1fd76879c6f6b371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the best available covariance (smoothed, filtered, or predicted).  <br /></td></tr>
<tr class="memitem:a2eb2c9ba0c2fc651046852881854d9d0" id="r_a2eb2c9ba0c2fc651046852881854d9d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2640cb1596c0c91b3befbfcafd48f170">EffectiveCalibratedMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eb2c9ba0c2fc651046852881854d9d0">effectiveCalibrated</a> ()</td></tr>
<tr class="memdesc:a2eb2c9ba0c2fc651046852881854d9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access mutable calibrated measurement values with runtime dimension.  <br /></td></tr>
<tr class="memitem:a0d0d794fc481cb2061503297db51bec2" id="r_a0d0d794fc481cb2061503297db51bec2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a13a94a3c1198948a338b43ab31b1edd8">ConstEffectiveCalibratedMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d0d794fc481cb2061503297db51bec2">effectiveCalibrated</a> () const</td></tr>
<tr class="memdesc:a0d0d794fc481cb2061503297db51bec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the calibrated measurement values with runtime dimension.  <br /></td></tr>
<tr class="memitem:aa879ee3dffdd625152428e6c25f98562" id="r_aa879ee3dffdd625152428e6c25f98562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a23a99e03ffbb25cc9a84e325cfbd01cf">EffectiveCalibratedCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa879ee3dffdd625152428e6c25f98562">effectiveCalibratedCovariance</a> ()</td></tr>
<tr class="memdesc:aa879ee3dffdd625152428e6c25f98562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access mutable calibrated covariance with runtime dimension.  <br /></td></tr>
<tr class="memitem:a9d5455b8b30a2c62a9bc623f9152dc77" id="r_a9d5455b8b30a2c62a9bc623f9152dc77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a9c0e91c6a1603f6e8dba7c1e00160fd8">ConstEffectiveCalibratedCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d5455b8b30a2c62a9bc623f9152dc77">effectiveCalibratedCovariance</a> () const</td></tr>
<tr class="memdesc:a9d5455b8b30a2c62a9bc623f9152dc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the calibrated covariance with runtime dimension.  <br /></td></tr>
<tr class="memitem:ab61c120c85b1a4f77752da0f6175dc7e" id="r_ab61c120c85b1a4f77752da0f6175dc7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab61c120c85b1a4f77752da0f6175dc7e">filtered</a> ()</td></tr>
<tr class="memdesc:ab61c120c85b1a4f77752da0f6175dc7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the filtered parameter vector.  <br /></td></tr>
<tr class="memitem:a184d0e403fd72b9be172e2b48159f91e" id="r_a184d0e403fd72b9be172e2b48159f91e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a184d0e403fd72b9be172e2b48159f91e">filtered</a> () const</td></tr>
<tr class="memdesc:a184d0e403fd72b9be172e2b48159f91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the filtered parameter vector.  <br /></td></tr>
<tr class="memitem:aa2f1ee12886f8fcbddd9818ce7ef10ea" id="r_aa2f1ee12886f8fcbddd9818ce7ef10ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2f1ee12886f8fcbddd9818ce7ef10ea">filteredCovariance</a> ()</td></tr>
<tr class="memdesc:aa2f1ee12886f8fcbddd9818ce7ef10ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the filtered covariance matrix.  <br /></td></tr>
<tr class="memitem:abab58ea4443ec2dfeb587cc7aae1dd08" id="r_abab58ea4443ec2dfeb587cc7aae1dd08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab58ea4443ec2dfeb587cc7aae1dd08">filteredCovariance</a> () const</td></tr>
<tr class="memdesc:abab58ea4443ec2dfeb587cc7aae1dd08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the filtered covariance matrix.  <br /></td></tr>
<tr class="memitem:a05f976cf656dc5571f37ce6e7408a386" id="r_a05f976cf656dc5571f37ce6e7408a386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05f976cf656dc5571f37ce6e7408a386">getMask</a> () const</td></tr>
<tr class="memdesc:a05f976cf656dc5571f37ce6e7408a386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the property mask describing which components are present.  <br /></td></tr>
<tr class="memitem:a8147aa516779278055bb852cbb4878d0" id="r_a8147aa516779278055bb852cbb4878d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8147aa516779278055bb852cbb4878d0">hasCalibrated</a> () const</td></tr>
<tr class="memdesc:a8147aa516779278055bb852cbb4878d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of calibrated measurement data.  <br /></td></tr>
<tr class="memitem:aa275b2ab0856e73063d3bd9a8b7dee18" id="r_aa275b2ab0856e73063d3bd9a8b7dee18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa275b2ab0856e73063d3bd9a8b7dee18">hasColumn</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:aa275b2ab0856e73063d3bd9a8b7dee18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the track state has a specific dynamic column.  <br /></td></tr>
<tr class="memitem:a9449289ba1a6b3a69303a306fc6fd566" id="r_a9449289ba1a6b3a69303a306fc6fd566"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9449289ba1a6b3a69303a306fc6fd566">hasFiltered</a> () const</td></tr>
<tr class="memdesc:a9449289ba1a6b3a69303a306fc6fd566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of filtered track parameters.  <br /></td></tr>
<tr class="memitem:a1ecdfebc5f88dbc52b614157ba961b1f" id="r_a1ecdfebc5f88dbc52b614157ba961b1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ecdfebc5f88dbc52b614157ba961b1f">hasJacobian</a> () const</td></tr>
<tr class="memdesc:a1ecdfebc5f88dbc52b614157ba961b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of a transport Jacobian.  <br /></td></tr>
<tr class="memitem:aba99d3d9722f0281d188d1d960c51cc2" id="r_aba99d3d9722f0281d188d1d960c51cc2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba99d3d9722f0281d188d1d960c51cc2">hasPredicted</a> () const</td></tr>
<tr class="memdesc:aba99d3d9722f0281d188d1d960c51cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of predicted track parameters.  <br /></td></tr>
<tr class="memitem:a784763dbe362b26d5a8a8bcac0b84b38" id="r_a784763dbe362b26d5a8a8bcac0b84b38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a784763dbe362b26d5a8a8bcac0b84b38">hasPrevious</a> () const</td></tr>
<tr class="memdesc:a784763dbe362b26d5a8a8bcac0b84b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this state links to a previous state.  <br /></td></tr>
<tr class="memitem:ab0e43ff669b7f0c610719bb35e89d058" id="r_ab0e43ff669b7f0c610719bb35e89d058"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0e43ff669b7f0c610719bb35e89d058">hasProjector</a> () const</td></tr>
<tr class="memdesc:ab0e43ff669b7f0c610719bb35e89d058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of a measurement projector.  <br /></td></tr>
<tr class="memitem:a5bdeaa8ece88091b540b439953e27d93" id="r_a5bdeaa8ece88091b540b439953e27d93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bdeaa8ece88091b540b439953e27d93">hasSmoothed</a> () const</td></tr>
<tr class="memdesc:a5bdeaa8ece88091b540b439953e27d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of smoothed track parameters.  <br /></td></tr>
<tr class="memitem:a646005da1a4e0fd60e864735dbbb4254" id="r_a646005da1a4e0fd60e864735dbbb4254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646005da1a4e0fd60e864735dbbb4254">jacobian</a> ()</td></tr>
<tr class="memdesc:a646005da1a4e0fd60e864735dbbb4254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the jacobian from the previous trackstate to this one.  <br /></td></tr>
<tr class="memitem:a963bb4bd89f7e9f6db39b0215ef7ae28" id="r_a963bb4bd89f7e9f6db39b0215ef7ae28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a963bb4bd89f7e9f6db39b0215ef7ae28">jacobian</a> () const</td></tr>
<tr class="memdesc:a963bb4bd89f7e9f6db39b0215ef7ae28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the jacobian from the previous trackstate to this one.  <br /></td></tr>
<tr class="memitem:a2776d616f96dd2cc9e55287853d8346b" id="r_a2776d616f96dd2cc9e55287853d8346b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2776d616f96dd2cc9e55287853d8346b">parameters</a> () const</td></tr>
<tr class="memdesc:a2776d616f96dd2cc9e55287853d8346b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the best available parameters (smoothed, filtered, or predicted).  <br /></td></tr>
<tr class="memitem:a6b422188f5dabfaa9deb94c2a6ed2af8" id="r_a6b422188f5dabfaa9deb94c2a6ed2af8"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b422188f5dabfaa9deb94c2a6ed2af8">pathLength</a> ()</td></tr>
<tr class="memdesc:a6b422188f5dabfaa9deb94c2a6ed2af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to the accumulated path length.  <br /></td></tr>
<tr class="memitem:ab4ef83672e971d4325ecf9f1619f0398" id="r_ab4ef83672e971d4325ecf9f1619f0398"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4ef83672e971d4325ecf9f1619f0398">pathLength</a> () const</td></tr>
<tr class="memdesc:ab4ef83672e971d4325ecf9f1619f0398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the accumulated path length.  <br /></td></tr>
<tr class="memitem:a8ba0f1e591afedf48f20f5bc1dea34bf" id="r_a8ba0f1e591afedf48f20f5bc1dea34bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba0f1e591afedf48f20f5bc1dea34bf">predicted</a> ()</td></tr>
<tr class="memdesc:a8ba0f1e591afedf48f20f5bc1dea34bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the predicted parameter vector.  <br /></td></tr>
<tr class="memitem:a91893e2cf9f9d97417d144a94ee01f82" id="r_a91893e2cf9f9d97417d144a94ee01f82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91893e2cf9f9d97417d144a94ee01f82">predicted</a> () const</td></tr>
<tr class="memdesc:a91893e2cf9f9d97417d144a94ee01f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the predicted parameter vector.  <br /></td></tr>
<tr class="memitem:ad1d4c1592543653bf38a411b0c71ffcd" id="r_ad1d4c1592543653bf38a411b0c71ffcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1d4c1592543653bf38a411b0c71ffcd">predictedCovariance</a> ()</td></tr>
<tr class="memdesc:ad1d4c1592543653bf38a411b0c71ffcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the predicted covariance matrix.  <br /></td></tr>
<tr class="memitem:a279850fe954db0735e3181cfd56d7b69" id="r_a279850fe954db0735e3181cfd56d7b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a279850fe954db0735e3181cfd56d7b69">predictedCovariance</a> () const</td></tr>
<tr class="memdesc:a279850fe954db0735e3181cfd56d7b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the predicted covariance matrix.  <br /></td></tr>
<tr class="memitem:a1ec7af81a908e39fdf6a2ec9c6c4a1c1" id="r_a1ec7af81a908e39fdf6a2ec9c6c4a1c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ec7af81a908e39fdf6a2ec9c6c4a1c1">previous</a> ()</td></tr>
<tr class="memdesc:a1ec7af81a908e39fdf6a2ec9c6c4a1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to the previous track state index.  <br /></td></tr>
<tr class="memitem:ae455c518344fada230edba3c3572be0c" id="r_ae455c518344fada230edba3c3572be0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae455c518344fada230edba3c3572be0c">previous</a> () const</td></tr>
<tr class="memdesc:ae455c518344fada230edba3c3572be0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the previous track state index in the linked trajectory.  <br /></td></tr>
<tr class="memitem:abd61dda2e361b43c07ddae9491f70efc" id="r_abd61dda2e361b43c07ddae9491f70efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#aaaa9c77f4dd9efc1ac464d9a941f2ef2">VariableBoundSubspaceHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd61dda2e361b43c07ddae9491f70efc">projectorSubspaceHelper</a> () const</td></tr>
<tr class="memdesc:abd61dda2e361b43c07ddae9491f70efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable size subspace helper.  <br /></td></tr>
<tr class="memitem:ad89b9a55ab23c18569fe1a5416a8ea6c" id="r_ad89b9a55ab23c18569fe1a5416a8ea6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad89b9a55ab23c18569fe1a5416a8ea6c">projectorSubspaceIndices</a> () const</td></tr>
<tr class="memdesc:ad89b9a55ab23c18569fe1a5416a8ea6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the measurement projector indices.  <br /></td></tr>
<tr class="memitem:abf5df1fa62aff40e599d1ae290dd6c36" id="r_abf5df1fa62aff40e599d1ae290dd6c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5df1fa62aff40e599d1ae290dd6c36">setProjectorSubspaceIndices</a> (const index_range_t &amp;subspaceIndices)</td></tr>
<tr class="memdesc:abf5df1fa62aff40e599d1ae290dd6c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store subspace indices describing the measurement projector.  <br /></td></tr>
<tr class="memitem:acd2a6f05110c3d1844d924aaccda1e93" id="r_acd2a6f05110c3d1844d924aaccda1e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd2a6f05110c3d1844d924aaccda1e93">smoothed</a> ()</td></tr>
<tr class="memdesc:acd2a6f05110c3d1844d924aaccda1e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the smoothed parameter vector.  <br /></td></tr>
<tr class="memitem:a9797391008d4c7c2b9eb507ce63f91cd" id="r_a9797391008d4c7c2b9eb507ce63f91cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9797391008d4c7c2b9eb507ce63f91cd">smoothed</a> () const</td></tr>
<tr class="memdesc:a9797391008d4c7c2b9eb507ce63f91cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the smoothed parameter vector.  <br /></td></tr>
<tr class="memitem:a46478c8cb23308835288edc2b995c487" id="r_a46478c8cb23308835288edc2b995c487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46478c8cb23308835288edc2b995c487">smoothedCovariance</a> ()</td></tr>
<tr class="memdesc:a46478c8cb23308835288edc2b995c487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the smoothed covariance matrix.  <br /></td></tr>
<tr class="memitem:a9f5d8cac8885aec3e5c215da961f14b9" id="r_a9f5d8cac8885aec3e5c215da961f14b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5d8cac8885aec3e5c215da961f14b9">smoothedCovariance</a> () const</td></tr>
<tr class="memdesc:a9f5d8cac8885aec3e5c215da961f14b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the smoothed covariance matrix.  <br /></td></tr>
<tr class="memitem:a5fbed9bb3b46afcbd08f6d8559b55684" id="r_a5fbed9bb3b46afcbd08f6d8559b55684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fbed9bb3b46afcbd08f6d8559b55684">trajectory</a> ()</td></tr>
<tr class="memdesc:a5fbed9bb3b46afcbd08f6d8559b55684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the underlying backend container.  <br /></td></tr>
<tr class="memitem:a400c5a87fdeb279c3c705463f95195ff" id="r_a400c5a87fdeb279c3c705463f95195ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a400c5a87fdeb279c3c705463f95195ff">trajectory</a> () const</td></tr>
<tr class="memdesc:a400c5a87fdeb279c3c705463f95195ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the underlying backend container.  <br /></td></tr>
<tr class="memitem:a791a21c02ce98188ac4b5dd56da9811f" id="r_a791a21c02ce98188ac4b5dd56da9811f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#aea0ba56b78fc7596ea8c54f1fdd6dc86">MutableTrackStateTypeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791a21c02ce98188ac4b5dd56da9811f">typeFlags</a> ()</td></tr>
<tr class="memdesc:a791a21c02ce98188ac4b5dd56da9811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve mutable track-state type flags.  <br /></td></tr>
<tr class="memitem:a23edcbb710e2a286de0052f4cc549661" id="r_a23edcbb710e2a286de0052f4cc549661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a396cf9dc9d64968f658960b949be9db2">ConstTrackStateTypeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23edcbb710e2a286de0052f4cc549661">typeFlags</a> () const</td></tr>
<tr class="memdesc:a23edcbb710e2a286de0052f4cc549661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the track-state type flags.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors and assignment operator</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_construct"></a> Public constructors and assignment operators for <code>TrackStateProxy</code> only allow construction from another <code>TrackStateProxy</code>. You should generally not have to construct <code>TrackStateProxy</code> manually. </p>
</div></td></tr>
<tr class="memitem:a7c64da1d3029b735fd7651a2cc12cd9e" id="r_a7c64da1d3029b735fd7651a2cc12cd9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> (const TrackStateProxy &amp;other)=default</td></tr>
<tr class="memdesc:a7c64da1d3029b735fd7651a2cc12cd9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: const to const or mutable to mutable.  <br /></td></tr>
<tr class="memitem:a4b952743d6b1f741c480358fc8674e49" id="r_a4b952743d6b1f741c480358fc8674e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b952743d6b1f741c480358fc8674e49">operator=</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp;other)=default</td></tr>
<tr class="memdesc:a4b952743d6b1f741c480358fc8674e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: const to const or mutable to mutable.  <br /></td></tr>
<tr class="memitem:ada128f1703a9355dd6e2d1e84d30176c" id="r_ada128f1703a9355dd6e2d1e84d30176c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada128f1703a9355dd6e2d1e84d30176c">TrackStateProxy</a> (const TrackStateProxy&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;other)</td></tr>
<tr class="memdesc:ada128f1703a9355dd6e2d1e84d30176c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from mutable TrackStateProxy.  <br /></td></tr>
<tr class="memitem:a2a7d2d25ba9d29f2d08793e7d82a323d" id="r_a2a7d2d25ba9d29f2d08793e7d82a323d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a7d2d25ba9d29f2d08793e7d82a323d">operator=</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;other)</td></tr>
<tr class="memdesc:a2a7d2d25ba9d29f2d08793e7d82a323d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator to from mutable <code>TrackStateProxy</code>.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state properties</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_props"></a> Properties of the track state represented by <code>TrackStateProxy</code>.</p>
<p>Many of these methods come in a <code>const</code> and a non-<code>const</code> version. The non-<code>const</code> version is only available if you have an instance of <code>TrackStateProxy</code> that does not have the <code>read_only</code> template parameter set to <code>true</code>, even if you hold it as an lvalue.</p>
<p>The track states each have an index in the track state container. The sequence of track states is implemented as a one or two-way linked list, which uses indices into the same container.</p>
<p>Each track state has a <code>previous</code> index, which points at the track state immediately preceding. A track state with a <code>previous</code> index of <code>kInvalid</code> is the first (innermost) track state in a track or track candidate. This is also referred to as a <em>stem</em> at the track level.</p>
<p>During track finding and fitting, track states are usually appended to the sequence, populating the <code>previous</code> index of the new track state. Combinatorial track finding can produce track states which fork in this way, by having more than one track state with the same <code>previous</code> index.</p>
<p>The track states have static, optional and dynamic properties. Static properties are always present, and can always be retrieved. Optional components use an extra indirection mechanism that coordinates with the backend to allow both not having the component set, or sharing it with other track states. An example is a branching trajectory from track finding which shares the same predicted parameter vector and associated covariance.</p>
<p>Optional components are</p><ul>
<li>predicted parameters and covariance</li>
<li>filtered parameters and covariance</li>
<li>smoothed parameters and covariance</li>
<li>jacobian</li>
<li>calibrated measurement info including projector</li>
</ul>
<p>They can be unset via <a class="el" href="#a58ecea4d41d25884af489e1391a1fdb5">unset</a>, <a class="el" href="#a05f976cf656dc5571f37ce6e7408a386">getMask</a> can be used to check which components are present. The first four are shareable between track states via <a class="el" href="#a95304204468f54911b50a674f7ada1d6">shareFrom</a>. </p>
</div></td></tr>
<tr class="memitem:a0c262c2b5ad8f0c90c99a157de006a60" id="r_a0c262c2b5ad8f0c90c99a157de006a60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c262c2b5ad8f0c90c99a157de006a60">index</a> () const</td></tr>
<tr class="memdesc:a0c262c2b5ad8f0c90c99a157de006a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index within the trajectory.  <br /></td></tr>
<tr class="memitem:a58ecea4d41d25884af489e1391a1fdb5" id="r_a58ecea4d41d25884af489e1391a1fdb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ecea4d41d25884af489e1391a1fdb5">unset</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> target)</td></tr>
<tr class="memdesc:a58ecea4d41d25884af489e1391a1fdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset an optional track state component.  <br /></td></tr>
<tr class="memitem:a71b5772cf7d277d0f2b8051adb619188" id="r_a71b5772cf7d277d0f2b8051adb619188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b5772cf7d277d0f2b8051adb619188">addComponents</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> mask)</td></tr>
<tr class="memdesc:a71b5772cf7d277d0f2b8051adb619188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add additional components to the track state.  <br /></td></tr>
<tr class="memitem:a412f66e00d2d9194b0d1c1adee50a279" id="r_a412f66e00d2d9194b0d1c1adee50a279"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a412f66e00d2d9194b0d1c1adee50a279">referenceSurface</a> () const</td></tr>
<tr class="memdesc:a412f66e00d2d9194b0d1c1adee50a279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference surface.  <br /></td></tr>
<tr class="memitem:a9a727e6069185f42a12198df597e7c6e" id="r_a9a727e6069185f42a12198df597e7c6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a727e6069185f42a12198df597e7c6e">hasReferenceSurface</a> () const</td></tr>
<tr class="memdesc:a9a727e6069185f42a12198df597e7c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the track state has a non nullptr surface associated.  <br /></td></tr>
<tr class="memitem:a57835d73120cd60cf7dd0c37fa92d3c3" id="r_a57835d73120cd60cf7dd0c37fa92d3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57835d73120cd60cf7dd0c37fa92d3c3">setReferenceSurface</a> (std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt; srf)</td></tr>
<tr class="memdesc:a57835d73120cd60cf7dd0c37fa92d3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference surface to a given value.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state measurement properties</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_meas"></a> Properties of the measurement associated with the track state represented. This consists of a vector and an associated square matrix of a measurement dimension which is between one and the size of the track parametrization. The measurement coordinate frame is required to be a strict subset of the bound track parametrization on the local geometry coordinate frame, i.e. using a pure projector matrix to convert from the bound parametrization to the measurement frame is possible.</p>
<p>The track state stores the parameter vector and covariance, and the backend is given the possibility to do so in a jagged way, i.e. only storing the number of values needed. This requires calling <a class="el" href="#a8a6f76ec69c3de04836a2d2982be565a">allocateCalibrated</a> before storing the measurements (even if it might be a no-op).</p>
<p>The projector matrix is packed as a bitset, which is converted to a matrix on-demand (and therefore returned by value).</p>
<p>The track state also includes a <a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> which acts as a proxy to the original uncalibrated measurement that the calibrated measurement was derived from. It is set and returned by value, to allow unpacking / repacking by the backend, if needed. </p>
</div></td></tr>
<tr class="memitem:ae735c7f377c9d136cd0dae9b404e1363" id="r_ae735c7f377c9d136cd0dae9b404e1363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae735c7f377c9d136cd0dae9b404e1363">getUncalibratedSourceLink</a> () const</td></tr>
<tr class="memdesc:ae735c7f377c9d136cd0dae9b404e1363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uncalibrated measurement in the form of a source link.  <br /></td></tr>
<tr class="memitem:ad9e34422bd144eca89d0a0a3a3b085ab" id="r_ad9e34422bd144eca89d0a0a3a3b085ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9e34422bd144eca89d0a0a3a3b085ab">setUncalibratedSourceLink</a> (<a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> &amp;&amp;sourceLink)</td></tr>
<tr class="memdesc:ad9e34422bd144eca89d0a0a3a3b085ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an uncalibrated source link.  <br /></td></tr>
<tr class="memitem:a9861fa7fb806028eb6ab74c98152e9c1" id="r_a9861fa7fb806028eb6ab74c98152e9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9861fa7fb806028eb6ab74c98152e9c1">hasUncalibratedSourceLink</a> () const</td></tr>
<tr class="memdesc:a9861fa7fb806028eb6ab74c98152e9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the point has an associated uncalibrated measurement.  <br /></td></tr>
<tr class="memitem:a9288cb73d98dd95221ae6dd086d802fd" id="r_a9288cb73d98dd95221ae6dd086d802fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9288cb73d98dd95221ae6dd086d802fd">calibratedSize</a> () const</td></tr>
<tr class="memdesc:a9288cb73d98dd95221ae6dd086d802fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the (dynamic) number of dimensions stored for this measurement.  <br /></td></tr>
<tr class="memitem:a8a6f76ec69c3de04836a2d2982be565a" id="r_a8a6f76ec69c3de04836a2d2982be565a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8a6f76ec69c3de04836a2d2982be565a">allocateCalibrated</a> (std::size_t measdim)</td></tr>
<tr class="memdesc:a8a6f76ec69c3de04836a2d2982be565a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate storage to be able to store a measurement of size <code class="param">measdim</code>.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Sharing and copying</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_share_copy"></a> Methods to share and copy track state components. Sharing means setting up more than one track state to point to the same component.</p>
<p>Shareable components are</p><ul>
<li>predicted parameters and covariance</li>
<li>filtered parameters and covariance</li>
<li>smoothed parameters and covariance</li>
<li>jacobian</li>
</ul>
<p>See <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a>. </p>
</div></td></tr>
<tr class="memitem:a95304204468f54911b50a674f7ada1d6" id="r_a95304204468f54911b50a674f7ada1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95304204468f54911b50a674f7ada1d6">shareFrom</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareSource, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareTarget)</td></tr>
<tr class="memdesc:a95304204468f54911b50a674f7ada1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share a shareable component <b>within</b> this track state.  <br /></td></tr>
<tr class="memitem:a8086412d1967b46203d8a00c0811e8de" id="r_a8086412d1967b46203d8a00c0811e8de"><td class="memTemplParams" colspan="2">template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a8086412d1967b46203d8a00c0811e8de template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8086412d1967b46203d8a00c0811e8de">shareFrom</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;other, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> <a class="el" href="#a1accd7846f32112e931dc3cbe683ae4a">component</a>)</td></tr>
<tr class="memdesc:a8086412d1967b46203d8a00c0811e8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share a shareable component from another track state.  <br /></td></tr>
<tr class="memitem:a4bb9736a7c382a83ce79d543f563e6f9" id="r_a4bb9736a7c382a83ce79d543f563e6f9"><td class="memTemplParams" colspan="2">template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a4bb9736a7c382a83ce79d543f563e6f9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bb9736a7c382a83ce79d543f563e6f9">shareFrom</a> (const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;other, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareSource, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> shareTarget)</td></tr>
<tr class="memdesc:a4bb9736a7c382a83ce79d543f563e6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Share a shareable component from another track state.  <br /></td></tr>
<tr class="memitem:affcbffae2f5137aad8fbc5dffe187f2e" id="r_affcbffae2f5137aad8fbc5dffe187f2e"><td class="memTemplParams" colspan="2">template&lt;TrackStateProxyConcept track_state_proxy_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:affcbffae2f5137aad8fbc5dffe187f2e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affcbffae2f5137aad8fbc5dffe187f2e">copyFrom</a> (const track_state_proxy_t &amp;other, <a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> mask=<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">TrackStatePropMask::All</a>, bool onlyAllocated=true)</td></tr>
<tr class="memdesc:affcbffae2f5137aad8fbc5dffe187f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the contents of another track state proxy into this one.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Track state proxy Generic component access</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_state_proxy_generic_component"></a></p>
</div></td></tr>
<tr class="memitem:af1035fd64a07b94bf5df59e5c84978f8" id="r_af1035fd64a07b94bf5df59e5c84978f8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </td></tr>
<tr class="memitem:af1035fd64a07b94bf5df59e5c84978f8 template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1035fd64a07b94bf5df59e5c84978f8">has</a> () const</td></tr>
<tr class="memdesc:af1035fd64a07b94bf5df59e5c84978f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a component is set.  <br /></td></tr>
<tr class="memitem:a2f032c5a6b354bcf96c600429dd47dbd" id="r_a2f032c5a6b354bcf96c600429dd47dbd"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f032c5a6b354bcf96c600429dd47dbd">has</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:a2f032c5a6b354bcf96c600429dd47dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a component is set.  <br /></td></tr>
<tr class="memitem:a05ba115f5833ed450aa28e94cd21e2f2" id="r_a05ba115f5833ed450aa28e94cd21e2f2"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05ba115f5833ed450aa28e94cd21e2f2">has</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a05ba115f5833ed450aa28e94cd21e2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a component is set.  <br /></td></tr>
<tr class="memitem:a1accd7846f32112e931dc3cbe683ae4a" id="r_a1accd7846f32112e931dc3cbe683ae4a"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a1accd7846f32112e931dc3cbe683ae4a template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1accd7846f32112e931dc3cbe683ae4a">component</a> ()</td></tr>
<tr class="memdesc:a1accd7846f32112e931dc3cbe683ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:a7fa8a0971eb199e1f77c669ea485e93b" id="r_a7fa8a0971eb199e1f77c669ea485e93b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:a7fa8a0971eb199e1f77c669ea485e93b template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fa8a0971eb199e1f77c669ea485e93b">component</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key)</td></tr>
<tr class="memdesc:a7fa8a0971eb199e1f77c669ea485e93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:aaba9ae1881ae6d359047c983abead7e5" id="r_aaba9ae1881ae6d359047c983abead7e5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</td></tr>
<tr class="memitem:aaba9ae1881ae6d359047c983abead7e5 template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaba9ae1881ae6d359047c983abead7e5">component</a> (std::string_view key)</td></tr>
<tr class="memdesc:aaba9ae1881ae6d359047c983abead7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:a02384247b8232dfcfe24ad0e8a54773e" id="r_a02384247b8232dfcfe24ad0e8a54773e"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </td></tr>
<tr class="memitem:a02384247b8232dfcfe24ad0e8a54773e template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02384247b8232dfcfe24ad0e8a54773e">component</a> () const</td></tr>
<tr class="memdesc:a02384247b8232dfcfe24ad0e8a54773e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="memitem:a3e2161c9e5d0ab6781732ba63f81f379" id="r_a3e2161c9e5d0ab6781732ba63f81f379"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a3e2161c9e5d0ab6781732ba63f81f379 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e2161c9e5d0ab6781732ba63f81f379">component</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:a3e2161c9e5d0ab6781732ba63f81f379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="memitem:aa5176de3179f8fa3a6f69bf4697842e4" id="r_aa5176de3179f8fa3a6f69bf4697842e4"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aa5176de3179f8fa3a6f69bf4697842e4 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5176de3179f8fa3a6f69bf4697842e4">component</a> (std::string_view key) const</td></tr>
<tr class="memdesc:aa5176de3179f8fa3a6f69bf4697842e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="inherit_header pub_methods_class_acts_1_1_track_state_proxy_common"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_acts_1_1_track_state_proxy_common')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon&lt; TrackStateProxy&lt; trajectory_t, M, true &gt;, true &gt;</a></td></tr>
<tr class="memitem:a1a49d176d8f372c0b9bb839732c1c145 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a1a49d176d8f372c0b9bb839732c1c145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a1a49d176d8f372c0b9bb839732c1c145">allocateCalibrated</a> (const Eigen::DenseBase&lt; val_t &gt; &amp;val, const Eigen::DenseBase&lt; cov_t &gt; &amp;cov)</td></tr>
<tr class="memdesc:a1a49d176d8f372c0b9bb839732c1c145 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize calibrated data from static-size Eigen objects.  <br /></td></tr>
<tr class="memitem:ab62320423496ff279f1b7ba3acd9f310 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_ab62320423496ff279f1b7ba3acd9f310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, true &gt;::Calibrated&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab62320423496ff279f1b7ba3acd9f310">calibrated</a> () const</td></tr>
<tr class="memdesc:ab62320423496ff279f1b7ba3acd9f310 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access calibrated measurement data with compile-time dimension.  <br /></td></tr>
<tr class="memitem:ad5ca9bfdc88d65e2eb601f72d456c272 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_ad5ca9bfdc88d65e2eb601f72d456c272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, true &gt;::CalibratedCovariance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ad5ca9bfdc88d65e2eb601f72d456c272">calibratedCovariance</a> () const</td></tr>
<tr class="memdesc:ad5ca9bfdc88d65e2eb601f72d456c272 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access calibrated covariance data with compile-time dimension.  <br /></td></tr>
<tr class="memitem:add6fb48e3d0a0ea2c5b7488ac2d45c71 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_add6fb48e3d0a0ea2c5b7488ac2d45c71"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#add6fb48e3d0a0ea2c5b7488ac2d45c71">chi2</a> () const</td></tr>
<tr class="memdesc:add6fb48e3d0a0ea2c5b7488ac2d45c71 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the local chi2 contribution.  <br /></td></tr>
<tr class="memitem:ad88c0584f9702a613c41e8b38ec6ba17 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_ad88c0584f9702a613c41e8b38ec6ba17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ad88c0584f9702a613c41e8b38ec6ba17">covariance</a> () const</td></tr>
<tr class="memdesc:ad88c0584f9702a613c41e8b38ec6ba17 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the best available covariance (smoothed, filtered, or predicted).  <br /></td></tr>
<tr class="memitem:aa8531df924e58911dcfb579ad7579521 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_aa8531df924e58911dcfb579ad7579521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a13a94a3c1198948a338b43ab31b1edd8">ConstEffectiveCalibratedMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aa8531df924e58911dcfb579ad7579521">effectiveCalibrated</a> () const</td></tr>
<tr class="memdesc:aa8531df924e58911dcfb579ad7579521 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the calibrated measurement values with runtime dimension.  <br /></td></tr>
<tr class="memitem:a9d8384874ef921f58fe0d2ea41b9f643 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a9d8384874ef921f58fe0d2ea41b9f643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a9c0e91c6a1603f6e8dba7c1e00160fd8">ConstEffectiveCalibratedCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a9d8384874ef921f58fe0d2ea41b9f643">effectiveCalibratedCovariance</a> () const</td></tr>
<tr class="memdesc:a9d8384874ef921f58fe0d2ea41b9f643 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the calibrated covariance with runtime dimension.  <br /></td></tr>
<tr class="memitem:aed0b9c6793469f890de1634891b07c7c inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_aed0b9c6793469f890de1634891b07c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aed0b9c6793469f890de1634891b07c7c">filtered</a> () const</td></tr>
<tr class="memdesc:aed0b9c6793469f890de1634891b07c7c inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the filtered parameter vector.  <br /></td></tr>
<tr class="memitem:a4e08fc45fd16cca52b4d2a27116d1876 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a4e08fc45fd16cca52b4d2a27116d1876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a4e08fc45fd16cca52b4d2a27116d1876">filteredCovariance</a> () const</td></tr>
<tr class="memdesc:a4e08fc45fd16cca52b4d2a27116d1876 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the filtered covariance matrix.  <br /></td></tr>
<tr class="memitem:a1ac8e0bdf8916e29b81679c64ac5d1a4 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a1ac8e0bdf8916e29b81679c64ac5d1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a1ac8e0bdf8916e29b81679c64ac5d1a4">getMask</a> () const</td></tr>
<tr class="memdesc:a1ac8e0bdf8916e29b81679c64ac5d1a4 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the property mask describing which components are present.  <br /></td></tr>
<tr class="memitem:aa0fc27902bfe77cffd48fb04f25178ee inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_aa0fc27902bfe77cffd48fb04f25178ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aa0fc27902bfe77cffd48fb04f25178ee">hasCalibrated</a> () const</td></tr>
<tr class="memdesc:aa0fc27902bfe77cffd48fb04f25178ee inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of calibrated measurement data.  <br /></td></tr>
<tr class="memitem:a846c295dc1d84b70f7bf9098c56c5b0b inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a846c295dc1d84b70f7bf9098c56c5b0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a846c295dc1d84b70f7bf9098c56c5b0b">hasFiltered</a> () const</td></tr>
<tr class="memdesc:a846c295dc1d84b70f7bf9098c56c5b0b inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of filtered track parameters.  <br /></td></tr>
<tr class="memitem:a71dc42abdce5c4c3c80a4533abcd3173 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a71dc42abdce5c4c3c80a4533abcd3173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a71dc42abdce5c4c3c80a4533abcd3173">hasJacobian</a> () const</td></tr>
<tr class="memdesc:a71dc42abdce5c4c3c80a4533abcd3173 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of a transport Jacobian.  <br /></td></tr>
<tr class="memitem:accc1ca9f1f24b74b550f1499c807dbe3 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_accc1ca9f1f24b74b550f1499c807dbe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#accc1ca9f1f24b74b550f1499c807dbe3">hasPredicted</a> () const</td></tr>
<tr class="memdesc:accc1ca9f1f24b74b550f1499c807dbe3 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of predicted track parameters.  <br /></td></tr>
<tr class="memitem:a043ce2db2bc377a51ce736f93d91b825 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a043ce2db2bc377a51ce736f93d91b825"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a043ce2db2bc377a51ce736f93d91b825">hasPrevious</a> () const</td></tr>
<tr class="memdesc:a043ce2db2bc377a51ce736f93d91b825 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this state links to a previous state.  <br /></td></tr>
<tr class="memitem:a09e8129dc01278f91c0c0a98967e2438 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a09e8129dc01278f91c0c0a98967e2438"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a09e8129dc01278f91c0c0a98967e2438">hasProjector</a> () const</td></tr>
<tr class="memdesc:a09e8129dc01278f91c0c0a98967e2438 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of a measurement projector.  <br /></td></tr>
<tr class="memitem:ac134ba5a7322e18dd19d34de4b52bcf4 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_ac134ba5a7322e18dd19d34de4b52bcf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ac134ba5a7322e18dd19d34de4b52bcf4">hasSmoothed</a> () const</td></tr>
<tr class="memdesc:ac134ba5a7322e18dd19d34de4b52bcf4 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for presence of smoothed track parameters.  <br /></td></tr>
<tr class="memitem:a6c71b60c654cdf30f156e51816cbf86e inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a6c71b60c654cdf30f156e51816cbf86e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a6c71b60c654cdf30f156e51816cbf86e">parameters</a> () const</td></tr>
<tr class="memdesc:a6c71b60c654cdf30f156e51816cbf86e inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the best available parameters (smoothed, filtered, or predicted).  <br /></td></tr>
<tr class="memitem:aac65653b4fb788bdc1a796f934f7d9d6 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_aac65653b4fb788bdc1a796f934f7d9d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aac65653b4fb788bdc1a796f934f7d9d6">pathLength</a> () const</td></tr>
<tr class="memdesc:aac65653b4fb788bdc1a796f934f7d9d6 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the accumulated path length.  <br /></td></tr>
<tr class="memitem:aacf3155dd624ccff5b346e168ba78238 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_aacf3155dd624ccff5b346e168ba78238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aacf3155dd624ccff5b346e168ba78238">predicted</a> () const</td></tr>
<tr class="memdesc:aacf3155dd624ccff5b346e168ba78238 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the predicted parameter vector.  <br /></td></tr>
<tr class="memitem:ab0a098d5002c967571f5150e1b89dfca inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_ab0a098d5002c967571f5150e1b89dfca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0a098d5002c967571f5150e1b89dfca">predictedCovariance</a> () const</td></tr>
<tr class="memdesc:ab0a098d5002c967571f5150e1b89dfca inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the predicted covariance matrix.  <br /></td></tr>
<tr class="memitem:acd0d888ebb4557950c99625a57baea8d inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_acd0d888ebb4557950c99625a57baea8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#acd0d888ebb4557950c99625a57baea8d">previous</a> () const</td></tr>
<tr class="memdesc:acd0d888ebb4557950c99625a57baea8d inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the previous track state index in the linked trajectory.  <br /></td></tr>
<tr class="memitem:a25aecd7f746f8017ced73b0a737633c1 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a25aecd7f746f8017ced73b0a737633c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#aaaa9c77f4dd9efc1ac464d9a941f2ef2">VariableBoundSubspaceHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a25aecd7f746f8017ced73b0a737633c1">projectorSubspaceHelper</a> () const</td></tr>
<tr class="memdesc:a25aecd7f746f8017ced73b0a737633c1 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable size subspace helper.  <br /></td></tr>
<tr class="memitem:adae356b8c002e3b891d613ee4a62bd3f inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_adae356b8c002e3b891d613ee4a62bd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#adae356b8c002e3b891d613ee4a62bd3f">projectorSubspaceIndices</a> () const</td></tr>
<tr class="memdesc:adae356b8c002e3b891d613ee4a62bd3f inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode the measurement projector indices.  <br /></td></tr>
<tr class="memitem:a7fae38925b0390135f23a5403d4fbad7 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a7fae38925b0390135f23a5403d4fbad7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a7fae38925b0390135f23a5403d4fbad7">setProjectorSubspaceIndices</a> (const index_range_t &amp;subspaceIndices)</td></tr>
<tr class="memdesc:a7fae38925b0390135f23a5403d4fbad7 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store subspace indices describing the measurement projector.  <br /></td></tr>
<tr class="memitem:ab2f8197f3ee7aa50ff262176609b5e93 inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_ab2f8197f3ee7aa50ff262176609b5e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab2f8197f3ee7aa50ff262176609b5e93">smoothed</a> () const</td></tr>
<tr class="memdesc:ab2f8197f3ee7aa50ff262176609b5e93 inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the smoothed parameter vector.  <br /></td></tr>
<tr class="memitem:abab3287e46fcbfc75ef4033e414c49ab inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_abab3287e46fcbfc75ef4033e414c49ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#abab3287e46fcbfc75ef4033e414c49ab">smoothedCovariance</a> () const</td></tr>
<tr class="memdesc:abab3287e46fcbfc75ef4033e414c49ab inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the smoothed covariance matrix.  <br /></td></tr>
<tr class="memitem:a6de152ca1f25fe8f8534393a52bdabab inherit pub_methods_class_acts_1_1_track_state_proxy_common" id="r_a6de152ca1f25fe8f8534393a52bdabab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#a396cf9dc9d64968f658960b949be9db2">ConstTrackStateTypeMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a6de152ca1f25fe8f8534393a52bdabab">typeFlags</a> () const</td></tr>
<tr class="memdesc:a6de152ca1f25fe8f8534393a52bdabab inherit pub_methods_class_acts_1_1_track_state_proxy_common"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the track-state type flags.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac971a8625ee702ef7cb743fa52e4f186" id="r_ac971a8625ee702ef7cb743fa52e4f186"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac971a8625ee702ef7cb743fa52e4f186">kInvalid</a> = <a class="el" href="namespace_acts.html#a589e3f01b082df3de46c2a6f5e6ce749">kTrackIndexInvalid</a></td></tr>
<tr class="memdesc:ac971a8625ee702ef7cb743fa52e4f186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value that indicates an invalid index.  <br /></td></tr>
<tr class="memitem:a99b5acfc879ef16dc1c017452b5bbe87" id="r_a99b5acfc879ef16dc1c017452b5bbe87"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a> = read_only</td></tr>
<tr class="memdesc:a99b5acfc879ef16dc1c017452b5bbe87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this track state proxy is read-only or if it can be modified.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3d6c0e3e172cfb8a8a5a64b016880357" id="r_a3d6c0e3e172cfb8a8a5a64b016880357"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d6c0e3e172cfb8a8a5a64b016880357">calibratedCovarianceData</a> () const</td></tr>
<tr class="memitem:a93228bc024cce804758a23771a3f0a5e" id="r_a93228bc024cce804758a23771a3f0a5e"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93228bc024cce804758a23771a3f0a5e">calibratedCovarianceDataMutable</a> ()</td></tr>
<tr class="memitem:a53acd90035e1c3e155a472d4e55abd00" id="r_a53acd90035e1c3e155a472d4e55abd00"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53acd90035e1c3e155a472d4e55abd00">calibratedData</a> () const</td></tr>
<tr class="memitem:ab8035fe0d309c18548cd0c8fc6abe0f4" id="r_ab8035fe0d309c18548cd0c8fc6abe0f4"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8035fe0d309c18548cd0c8fc6abe0f4">calibratedDataMutable</a> ()</td></tr>
<tr class="memitem:afcd8287dac42309c07357dc494c24226" id="r_afcd8287dac42309c07357dc494c24226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcd8287dac42309c07357dc494c24226">covarianceAtIndex</a> (<a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> covIndex) const</td></tr>
<tr class="memitem:ac6ebf59da4c60e51f95ce696c3b1e91f" id="r_ac6ebf59da4c60e51f95ce696c3b1e91f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ebf59da4c60e51f95ce696c3b1e91f">covarianceAtIndexMutable</a> (<a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> covIndex)</td></tr>
<tr class="memitem:a14bee409ce04e472b9a5f007e2bb683c" id="r_a14bee409ce04e472b9a5f007e2bb683c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bee409ce04e472b9a5f007e2bb683c">parametersAtIndex</a> (<a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> parIndex) const</td></tr>
<tr class="memitem:ad32f3b6734489b4b156277cd99ec1da5" id="r_ad32f3b6734489b4b156277cd99ec1da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad32f3b6734489b4b156277cd99ec1da5">parametersAtIndexMutable</a> (<a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> parIndex)</td></tr>
<tr class="inherit_header pro_methods_class_acts_1_1_track_state_proxy_common"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_acts_1_1_track_state_proxy_common')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Member Functions inherited from <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon&lt; TrackStateProxy&lt; trajectory_t, M, true &gt;, true &gt;</a></td></tr>
<tr class="memitem:a2af33c16285fe18d3b55f573eff37777 inherit pro_methods_class_acts_1_1_track_state_proxy_common" id="r_a2af33c16285fe18d3b55f573eff37777"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="class_acts_1_1_track_state_proxy.html">TrackStateProxy</a>&lt; trajectory_t, M, true &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2af33c16285fe18d3b55f573eff37777">derived</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_class_acts_1_1_track_state_proxy_common"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_types_class_acts_1_1_track_state_proxy_common')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Protected Types inherited from <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon&lt; TrackStateProxy&lt; trajectory_t, M, true &gt;, true &gt;</a></td></tr>
<tr class="memitem:a1eb7bb75ad008d22048fe498e6b11ebb inherit pro_types_class_acts_1_1_track_state_proxy_common" id="r_a1eb7bb75ad008d22048fe498e6b11ebb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a1eb7bb75ad008d22048fe498e6b11ebb">IndexType</a></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt;<br />
class Acts::TrackStateProxy&lt; trajectory_t, M, read_only &gt;</div><p>Proxy object to access a single point on the trajectory. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SourceLink</td><td>Type to link back to an original measurement </td></tr>
    <tr><td class="paramname">M</td><td>Maximum number of measurement dimensions </td></tr>
    <tr><td class="paramname">read_only</td><td>true for read-only access to underlying storage </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a1e895ddc7749c062ea1343f4ad891608" name="a1e895ddc7749c062ea1343f4ad891608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e895ddc7749c062ea1343f4ad891608">&#9670;&#160;</a></span>Calibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Calibrated = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, false&gt;::Calibrated</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-type for a calibrated measurement vector, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="abe078d39a530a75ce5e36dd39cec3492" name="abe078d39a530a75ce5e36dd39cec3492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe078d39a530a75ce5e36dd39cec3492">&#9670;&#160;</a></span>CalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::CalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#a69c1b4dda6f50162722441d089a51a39">TrackStateTraits&lt;N, false&gt;::CalibratedCovariance</a></div>
<div class="ttc" id="astruct_acts_1_1_track_state_traits_html_a69c1b4dda6f50162722441d089a51a39"><div class="ttname"><a href="struct_acts_1_1_track_state_traits.html#a69c1b4dda6f50162722441d089a51a39">Acts::TrackStateTraits::CalibratedCovariance</a></div><div class="ttdeci">typename detail_tsp::FixedSizeTypes&lt; M, ReadOnly &gt;::CovarianceMap CalibratedCovariance</div><div class="ttdef"><b>Definition</b> Types.hpp:104</div></div>
</div><!-- fragment -->
<p>Map-type for a calibrated measurement covariance matrix, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="a6bc7781170388e6a5efc5dbfba2e369b" name="a6bc7781170388e6a5efc5dbfba2e369b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc7781170388e6a5efc5dbfba2e369b">&#9670;&#160;</a></span>ConstCalibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstCalibrated = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;N, true&gt;<a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">::Calibrated</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>Calibrated</code>, but with const semantics. </p>

</div>
</div>
<a id="a105d545b90be92b01c15163e89b8c763" name="a105d545b90be92b01c15163e89b8c763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105d545b90be92b01c15163e89b8c763">&#9670;&#160;</a></span>ConstCalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstCalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#a69c1b4dda6f50162722441d089a51a39">TrackStateTraits&lt;N, true&gt;::CalibratedCovariance</a></div>
</div><!-- fragment -->
<p>Same as <a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">CalibratedCovariance</a>, but with const semantics. </p>

</div>
</div>
<a id="a04aa68f896e3a74cfc505a953867aa70" name="a04aa68f896e3a74cfc505a953867aa70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa68f896e3a74cfc505a953867aa70">&#9670;&#160;</a></span>ConstCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstCovariance = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">::Covariance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>, but with const semantics. </p>

</div>
</div>
<a id="a7fbdcef77447c959db9a629ce2a1a50a" name="a7fbdcef77447c959db9a629ce2a1a50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbdcef77447c959db9a629ce2a1a50a">&#9670;&#160;</a></span>ConstEffectiveCalibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstEffectiveCalibrated</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#ad1aba98b04ee9311c42f7a393c7e87fb">TrackStateTraits&lt;M, true&gt;::EffectiveCalibrated</a></div>
<div class="ttc" id="astruct_acts_1_1_track_state_traits_html_ad1aba98b04ee9311c42f7a393c7e87fb"><div class="ttname"><a href="struct_acts_1_1_track_state_traits.html#ad1aba98b04ee9311c42f7a393c7e87fb">Acts::TrackStateTraits::EffectiveCalibrated</a></div><div class="ttdeci">typename detail_tsp::DynamicSizeTypes&lt; ReadOnly &gt;::CoefficientsMap EffectiveCalibrated</div><div class="ttdef"><b>Definition</b> Types.hpp:106</div></div>
</div><!-- fragment -->
<p>Same as <code>EffectiveCalibrated</code>, but with const semantics. </p>

</div>
</div>
<a id="a1ef98ae9574bf01c97c83eb7ab023257" name="a1ef98ae9574bf01c97c83eb7ab023257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef98ae9574bf01c97c83eb7ab023257">&#9670;&#160;</a></span>ConstEffectiveCalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstEffectiveCalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#ab8a875b8aa96b3a6024a5e50c5e816d0">TrackStateTraits&lt;M, true&gt;::EffectiveCalibratedCovariance</a></div>
<div class="ttc" id="astruct_acts_1_1_track_state_traits_html_ab8a875b8aa96b3a6024a5e50c5e816d0"><div class="ttname"><a href="struct_acts_1_1_track_state_traits.html#ab8a875b8aa96b3a6024a5e50c5e816d0">Acts::TrackStateTraits::EffectiveCalibratedCovariance</a></div><div class="ttdeci">typename detail_tsp::DynamicSizeTypes&lt; ReadOnly &gt;::CovarianceMap EffectiveCalibratedCovariance</div><div class="ttdef"><b>Definition</b> Types.hpp:108</div></div>
</div><!-- fragment -->
<p>Same as <a class="el" href="#a70ad68bbb136d1a602fbec002d79aa65">EffectiveCalibratedCovariance</a>, but with const semantics. </p>

</div>
</div>
<a id="a3b1a94121abb954a002a593bd61ef840" name="a3b1a94121abb954a002a593bd61ef840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1a94121abb954a002a593bd61ef840">&#9670;&#160;</a></span>ConstJacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstJacobian = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">::Covariance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jacobian shape is identical to <a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>. </p>

</div>
</div>
<a id="aeccd8d3a35af248c909696973307e1e8" name="aeccd8d3a35af248c909696973307e1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccd8d3a35af248c909696973307e1e8">&#9670;&#160;</a></span>ConstParameters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstParameters = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, true&gt;<a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">::Parameters</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">Parameters</a>, but with const semantics. </p>

</div>
</div>
<a id="ae2d3dcceec1ddf3457f1bc3b18462a3c" name="ae2d3dcceec1ddf3457f1bc3b18462a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d3dcceec1ddf3457f1bc3b18462a3c">&#9670;&#160;</a></span>ConstProxyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ConstProxyType = <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt;trajectory_t, M, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an associated const track state proxy, with the same backends. </p>

</div>
</div>
<a id="a0fb668c32599042bdb52cfa0db146ddb" name="a0fb668c32599042bdb52cfa0db146ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb668c32599042bdb52cfa0db146ddb">&#9670;&#160;</a></span>Covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Covariance = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, false&gt;::Covariance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-type for a bound covariance. </p>
<p>This has reference semantics, i.e. points at a matrix by an internal pointer. </p>

</div>
</div>
<a id="abb5a22a568840d5db0b57015c3cdf96a" name="abb5a22a568840d5db0b57015c3cdf96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5a22a568840d5db0b57015c3cdf96a">&#9670;&#160;</a></span>EffectiveCalibrated</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::EffectiveCalibrated</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#ad1aba98b04ee9311c42f7a393c7e87fb">TrackStateTraits&lt;M, false&gt;::EffectiveCalibrated</a></div>
</div><!-- fragment -->
<p>Map-type for a measurement vector, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="a70ad68bbb136d1a602fbec002d79aa65" name="a70ad68bbb136d1a602fbec002d79aa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ad68bbb136d1a602fbec002d79aa65">&#9670;&#160;</a></span>EffectiveCalibratedCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::EffectiveCalibratedCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> <a class="code hl_typedef" href="struct_acts_1_1_track_state_traits.html#ab8a875b8aa96b3a6024a5e50c5e816d0">TrackStateTraits&lt;M, false&gt;::EffectiveCalibratedCovariance</a></div>
</div><!-- fragment -->
<p>Map-type for a measurement covariance matrix, where the local measurement dimension is variable. </p>

</div>
</div>
<a id="a88faa591bbaae408e41c6db7fb39e0e5" name="a88faa591bbaae408e41c6db7fb39e0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88faa591bbaae408e41c6db7fb39e0e5">&#9670;&#160;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::IndexType = <a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index type of the track state container. </p>

</div>
</div>
<a id="aaff8087426b7d32fdb08af4c0fd38381" name="aaff8087426b7d32fdb08af4c0fd38381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff8087426b7d32fdb08af4c0fd38381">&#9670;&#160;</a></span>Jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Jacobian = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, false&gt;<a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">::Covariance</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jacobian shape is identical to <a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a>. </p>

</div>
</div>
<a id="ac11c999ddcc05da568b3a67de7f9dfe3" name="ac11c999ddcc05da568b3a67de7f9dfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11c999ddcc05da568b3a67de7f9dfe3">&#9670;&#160;</a></span>Parameters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Parameters = typename <a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt;M, false&gt;::Parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map-type for a bound parameter vector. </p>
<p>This has reference semantics, i.e. points at a matrix by an internal pointer. </p>

</div>
</div>
<a id="ab5e5ad251ac9d342e90dfe255b698896" name="ab5e5ad251ac9d342e90dfe255b698896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e5ad251ac9d342e90dfe255b698896">&#9670;&#160;</a></span>Trajectory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::Trajectory = trajectory_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The track state container backend given as a template parameter. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7c64da1d3029b735fd7651a2cc12cd9e" name="a7c64da1d3029b735fd7651a2cc12cd9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c64da1d3029b735fd7651a2cc12cd9e">&#9670;&#160;</a></span>TrackStateProxy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::TrackStateProxy </td>
          <td>(</td>
          <td class="paramtype">const TrackStateProxy&lt; trajectory_t, M, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: const to const or mutable to mutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to construct from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada128f1703a9355dd6e2d1e84d30176c" name="ada128f1703a9355dd6e2d1e84d30176c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada128f1703a9355dd6e2d1e84d30176c">&#9670;&#160;</a></span>TrackStateProxy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::TrackStateProxy </td>
          <td>(</td>
          <td class="paramtype">const TrackStateProxy&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from mutable TrackStateProxy. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to construct from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a71b5772cf7d277d0f2b8051adb619188" name="a71b5772cf7d277d0f2b8051adb619188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b5772cf7d277d0f2b8051adb619188">&#9670;&#160;</a></span>addComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::addComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add additional components to the track state. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is not read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The bitmask that instructs which components to allocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57411fe42df941f900652b5abf8367f4" name="a57411fe42df941f900652b5abf8367f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57411fe42df941f900652b5abf8367f4">&#9670;&#160;</a></span>allocateCalibrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::allocateCalibrated </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; val_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; cov_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cov</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize calibrated data from static-size Eigen objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">val_t</td><td>Eigen vector type holding calibrated values. </td></tr>
    <tr><td class="paramname">cov_t</td><td>Eigen matrix type holding the covariance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Vector to copy into the calibrated storage. </td></tr>
    <tr><td class="paramname">cov</td><td>Covariance matrix to copy into the calibrated storage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a6f76ec69c3de04836a2d2982be565a" name="a8a6f76ec69c3de04836a2d2982be565a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6f76ec69c3de04836a2d2982be565a">&#9670;&#160;</a></span>allocateCalibrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::allocateCalibrated </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>measdim</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate storage to be able to store a measurement of size <code class="param">measdim</code>. </p>
<p>This must be called <b>before</b> setting the measurement content. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measdim</td><td>Number of measurement dimensions to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This does not allocate if an allocation of the same size already exists </dd>
<dd>
This will zero-initialize the allocated storage </dd>
<dd>
This is an error if an existing allocation has different size </dd></dl>

</div>
</div>
<a id="a061b45091e71a2c21bffaf220b074d40" name="a061b45091e71a2c21bffaf220b074d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061b45091e71a2c21bffaf220b074d40">&#9670;&#160;</a></span>calibrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, false &gt;<a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">::Calibrated</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::calibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access calibrated measurement data with compile-time dimension. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">measdim</td><td>Measurement dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable Eigen map referencing the calibrated measurement vector. </dd></dl>

</div>
</div>
<a id="a1b3332284b421bd617aafd1534d16df9" name="a1b3332284b421bd617aafd1534d16df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3332284b421bd617aafd1534d16df9">&#9670;&#160;</a></span>calibrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, true &gt;<a class="el" href="#a1e895ddc7749c062ea1343f4ad891608">::Calibrated</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::calibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access calibrated measurement data with compile-time dimension. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">measdim</td><td>Measurement dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen map referencing the calibrated measurement vector. </dd></dl>

</div>
</div>
<a id="a90ab0ce99fd899289a7eccbbc124e7f1" name="a90ab0ce99fd899289a7eccbbc124e7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ab0ce99fd899289a7eccbbc124e7f1">&#9670;&#160;</a></span>calibratedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, false &gt;<a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">::CalibratedCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::calibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access calibrated covariance data with compile-time dimension. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">measdim</td><td>Measurement dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable Eigen map referencing the covariance matrix. </dd></dl>

</div>
</div>
<a id="ae67a7eb32a22133b667d0341c1265fa6" name="ae67a7eb32a22133b667d0341c1265fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67a7eb32a22133b667d0341c1265fa6">&#9670;&#160;</a></span>calibratedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_track_state_traits.html">TrackStateTraits</a>&lt; measdim, true &gt;<a class="el" href="#abe078d39a530a75ce5e36dd39cec3492">::CalibratedCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::calibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access calibrated covariance data with compile-time dimension. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">measdim</td><td>Measurement dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Eigen map referencing the covariance matrix. </dd></dl>

</div>
</div>
<a id="a3d6c0e3e172cfb8a8a5a64b016880357" name="a3d6c0e3e172cfb8a8a5a64b016880357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6c0e3e172cfb8a8a5a64b016880357">&#9670;&#160;</a></span>calibratedCovarianceData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double * <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedCovarianceData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93228bc024cce804758a23771a3f0a5e" name="a93228bc024cce804758a23771a3f0a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93228bc024cce804758a23771a3f0a5e">&#9670;&#160;</a></span>calibratedCovarianceDataMutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedCovarianceDataMutable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a53acd90035e1c3e155a472d4e55abd00" name="a53acd90035e1c3e155a472d4e55abd00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53acd90035e1c3e155a472d4e55abd00">&#9670;&#160;</a></span>calibratedData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double * <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8035fe0d309c18548cd0c8fc6abe0f4" name="ab8035fe0d309c18548cd0c8fc6abe0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8035fe0d309c18548cd0c8fc6abe0f4">&#9670;&#160;</a></span>calibratedDataMutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedDataMutable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9288cb73d98dd95221ae6dd086d802fd" name="a9288cb73d98dd95221ae6dd086d802fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9288cb73d98dd95221ae6dd086d802fd">&#9670;&#160;</a></span>calibratedSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::calibratedSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the (dynamic) number of dimensions stored for this measurement. </p>
<dl class="section note"><dt>Note</dt><dd>Depending on the backend, this size is used to determine the memory range of the measurement vector and covariance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of dimensions </dd></dl>

</div>
</div>
<a id="a87f65691fe7db92ac5851a22b2fd5291" name="a87f65691fe7db92ac5851a22b2fd5291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f65691fe7db92ac5851a22b2fd5291">&#9670;&#160;</a></span>chi2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float &amp; <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::chi2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to the local chi2 contribution. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable chi2 value. </dd></dl>

</div>
</div>
<a id="ad491bca3865ac50502a0184eeda6ac20" name="ad491bca3865ac50502a0184eeda6ac20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad491bca3865ac50502a0184eeda6ac20">&#9670;&#160;</a></span>chi2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::chi2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the local chi2 contribution. </p>
<dl class="section return"><dt>Returns</dt><dd>Chi2 value associated with this state. </dd></dl>

</div>
</div>
<a id="a1accd7846f32112e931dc3cbe683ae4a" name="a1accd7846f32112e931dc3cbe683ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1accd7846f32112e931dc3cbe683ae4a">&#9670;&#160;</a></span>component() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a02384247b8232dfcfe24ad0e8a54773e" name="a02384247b8232dfcfe24ad0e8a54773e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02384247b8232dfcfe24ad0e8a54773e">&#9670;&#160;</a></span>component() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a7fa8a0971eb199e1f77c669ea485e93b" name="a7fa8a0971eb199e1f77c669ea485e93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa8a0971eb199e1f77c669ea485e93b">&#9670;&#160;</a></span>component() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a3e2161c9e5d0ab6781732ba63f81f379" name="a3e2161c9e5d0ab6781732ba63f81f379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2161c9e5d0ab6781732ba63f81f379">&#9670;&#160;</a></span>component() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="aaba9ae1881ae6d359047c983abead7e5" name="aaba9ae1881ae6d359047c983abead7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba9ae1881ae6d359047c983abead7e5">&#9670;&#160;</a></span>component() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="aa5176de3179f8fa3a6f69bf4697842e4" name="aa5176de3179f8fa3a6f69bf4697842e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5176de3179f8fa3a6f69bf4697842e4">&#9670;&#160;</a></span>component() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a9eeeb3cd9207c308fa6bf497318d1f0d" name="a9eeeb3cd9207c308fa6bf497318d1f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeeb3cd9207c308fa6bf497318d1f0d">&#9670;&#160;</a></span>container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::container </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable reference to the track state container backend. </p>
<dl class="section return"><dt>Returns</dt><dd>a mutable reference to the backend </dd></dl>

</div>
</div>
<a id="a28f8e6a2a933d5979843a6327d700349" name="a28f8e6a2a933d5979843a6327d700349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f8e6a2a933d5979843a6327d700349">&#9670;&#160;</a></span>container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::container </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const reference to the track state container backend. </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the backend </dd></dl>

</div>
</div>
<a id="affcbffae2f5137aad8fbc5dffe187f2e" name="affcbffae2f5137aad8fbc5dffe187f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affcbffae2f5137aad8fbc5dffe187f2e">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;TrackStateProxyConcept track_state_proxy_t&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const track_state_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">TrackStatePropMask::All</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>onlyAllocated</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the contents of another track state proxy into this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other track state to copy from </td></tr>
    <tr><td class="paramname">mask</td><td>An optional mask to determine what to copy from </td></tr>
    <tr><td class="paramname">onlyAllocated</td><td>Whether to only copy allocated components </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the this track state proxy does not have compatible allocations with the source track state proxy, and <code class="param">onlyAllocated</code> is false, an exception is thrown. </dd>
<dd>
The mask parameter will not cause a copy of components that are not allocated in the source track state proxy. </dd></dl>

</div>
</div>
<a id="a1dedcbb96a0da5c1fd76879c6f6b371d" name="a1dedcbb96a0da5c1fd76879c6f6b371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dedcbb96a0da5c1fd76879c6f6b371d">&#9670;&#160;</a></span>covariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::covariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the best available covariance (smoothed, filtered, or predicted). </p>
<dl class="section return"><dt>Returns</dt><dd>Bound covariance map for the state. </dd></dl>

</div>
</div>
<a id="afcd8287dac42309c07357dc494c24226" name="afcd8287dac42309c07357dc494c24226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd8287dac42309c07357dc494c24226">&#9670;&#160;</a></span>covarianceAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::covarianceAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a></td>          <td class="paramname"><span class="paramname"><em>covIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6ebf59da4c60e51f95ce696c3b1e91f" name="ac6ebf59da4c60e51f95ce696c3b1e91f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ebf59da4c60e51f95ce696c3b1e91f">&#9670;&#160;</a></span>covarianceAtIndexMutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::covarianceAtIndexMutable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a></td>          <td class="paramname"><span class="paramname"><em>covIndex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eb2c9ba0c2fc651046852881854d9d0" name="a2eb2c9ba0c2fc651046852881854d9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb2c9ba0c2fc651046852881854d9d0">&#9670;&#160;</a></span>effectiveCalibrated() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2640cb1596c0c91b3befbfcafd48f170">EffectiveCalibratedMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::effectiveCalibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access mutable calibrated measurement values with runtime dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>Eigen map referencing the calibrated measurement vector. </dd></dl>

</div>
</div>
<a id="a0d0d794fc481cb2061503297db51bec2" name="a0d0d794fc481cb2061503297db51bec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0d794fc481cb2061503297db51bec2">&#9670;&#160;</a></span>effectiveCalibrated() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a13a94a3c1198948a338b43ab31b1edd8">ConstEffectiveCalibratedMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::effectiveCalibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the calibrated measurement values with runtime dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>Eigen map referencing the calibrated measurement vector. </dd></dl>

</div>
</div>
<a id="aa879ee3dffdd625152428e6c25f98562" name="aa879ee3dffdd625152428e6c25f98562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa879ee3dffdd625152428e6c25f98562">&#9670;&#160;</a></span>effectiveCalibratedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a23a99e03ffbb25cc9a84e325cfbd01cf">EffectiveCalibratedCovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::effectiveCalibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access mutable calibrated covariance with runtime dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>Eigen map referencing the measurement covariance matrix. </dd></dl>

</div>
</div>
<a id="a9d5455b8b30a2c62a9bc623f9152dc77" name="a9d5455b8b30a2c62a9bc623f9152dc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5455b8b30a2c62a9bc623f9152dc77">&#9670;&#160;</a></span>effectiveCalibratedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a9c0e91c6a1603f6e8dba7c1e00160fd8">ConstEffectiveCalibratedCovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::effectiveCalibratedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the calibrated covariance with runtime dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>Eigen map referencing the measurement covariance matrix. </dd></dl>

</div>
</div>
<a id="ab61c120c85b1a4f77752da0f6175dc7e" name="ab61c120c85b1a4f77752da0f6175dc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61c120c85b1a4f77752da0f6175dc7e">&#9670;&#160;</a></span>filtered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::filtered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the filtered parameter vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bound parameter map for the filtered state. </dd></dl>

</div>
</div>
<a id="a184d0e403fd72b9be172e2b48159f91e" name="a184d0e403fd72b9be172e2b48159f91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184d0e403fd72b9be172e2b48159f91e">&#9670;&#160;</a></span>filtered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::filtered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the filtered parameter vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound parameter map for the filtered state. </dd></dl>

</div>
</div>
<a id="aa2f1ee12886f8fcbddd9818ce7ef10ea" name="aa2f1ee12886f8fcbddd9818ce7ef10ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f1ee12886f8fcbddd9818ce7ef10ea">&#9670;&#160;</a></span>filteredCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::filteredCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the filtered covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bound covariance map for the filtered state. </dd></dl>

</div>
</div>
<a id="abab58ea4443ec2dfeb587cc7aae1dd08" name="abab58ea4443ec2dfeb587cc7aae1dd08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab58ea4443ec2dfeb587cc7aae1dd08">&#9670;&#160;</a></span>filteredCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::filteredCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the filtered covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound covariance map for the filtered state. </dd></dl>

</div>
</div>
<a id="a05f976cf656dc5571f37ce6e7408a386" name="a05f976cf656dc5571f37ce6e7408a386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f976cf656dc5571f37ce6e7408a386">&#9670;&#160;</a></span>getMask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::getMask </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the property mask describing which components are present. </p>
<dl class="section return"><dt>Returns</dt><dd>Bit mask of available properties. </dd></dl>

</div>
</div>
<a id="ae735c7f377c9d136cd0dae9b404e1363" name="ae735c7f377c9d136cd0dae9b404e1363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae735c7f377c9d136cd0dae9b404e1363">&#9670;&#160;</a></span>getUncalibratedSourceLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::getUncalibratedSourceLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uncalibrated measurement in the form of a source link. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The uncalibrated measurement source link </dd></dl>

</div>
</div>
<a id="af1035fd64a07b94bf5df59e5c84978f8" name="af1035fd64a07b94bf5df59e5c84978f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1035fd64a07b94bf5df59e5c84978f8">&#9670;&#160;</a></span>has() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::has </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a component is set. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">key</td><td>Hashed string key to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the component exists, false if not </dd></dl>

</div>
</div>
<a id="a2f032c5a6b354bcf96c600429dd47dbd" name="a2f032c5a6b354bcf96c600429dd47dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f032c5a6b354bcf96c600429dd47dbd">&#9670;&#160;</a></span>has() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::has </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a component is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Hashed string key to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the component exists, false if not </dd></dl>

</div>
</div>
<a id="a05ba115f5833ed450aa28e94cd21e2f2" name="a05ba115f5833ed450aa28e94cd21e2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ba115f5833ed450aa28e94cd21e2f2">&#9670;&#160;</a></span>has() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::has </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a component is set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key to check for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the component exists, false if not </dd></dl>

</div>
</div>
<a id="a8147aa516779278055bb852cbb4878d0" name="a8147aa516779278055bb852cbb4878d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8147aa516779278055bb852cbb4878d0">&#9670;&#160;</a></span>hasCalibrated()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasCalibrated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for presence of calibrated measurement data. </p>
<dl class="section return"><dt>Returns</dt><dd>True if calibrated measurements exist. </dd></dl>

</div>
</div>
<a id="aa275b2ab0856e73063d3bd9a8b7dee18" name="aa275b2ab0856e73063d3bd9a8b7dee18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa275b2ab0856e73063d3bd9a8b7dee18">&#9670;&#160;</a></span>hasColumn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the track state has a specific dynamic column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The hashed column key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the column exists </dd></dl>

</div>
</div>
<a id="a9449289ba1a6b3a69303a306fc6fd566" name="a9449289ba1a6b3a69303a306fc6fd566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9449289ba1a6b3a69303a306fc6fd566">&#9670;&#160;</a></span>hasFiltered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasFiltered </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for presence of filtered track parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the filtered component exists. </dd></dl>

</div>
</div>
<a id="a1ecdfebc5f88dbc52b614157ba961b1f" name="a1ecdfebc5f88dbc52b614157ba961b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecdfebc5f88dbc52b614157ba961b1f">&#9670;&#160;</a></span>hasJacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasJacobian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for presence of a transport Jacobian. </p>
<dl class="section return"><dt>Returns</dt><dd>True if a Jacobian is stored. </dd></dl>

</div>
</div>
<a id="aba99d3d9722f0281d188d1d960c51cc2" name="aba99d3d9722f0281d188d1d960c51cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba99d3d9722f0281d188d1d960c51cc2">&#9670;&#160;</a></span>hasPredicted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasPredicted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for presence of predicted track parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the predicted component exists. </dd></dl>

</div>
</div>
<a id="a784763dbe362b26d5a8a8bcac0b84b38" name="a784763dbe362b26d5a8a8bcac0b84b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784763dbe362b26d5a8a8bcac0b84b38">&#9670;&#160;</a></span>hasPrevious()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasPrevious </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether this state links to a previous state. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the previous index is valid. </dd></dl>

</div>
</div>
<a id="ab0e43ff669b7f0c610719bb35e89d058" name="ab0e43ff669b7f0c610719bb35e89d058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e43ff669b7f0c610719bb35e89d058">&#9670;&#160;</a></span>hasProjector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasProjector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for presence of a measurement projector. </p>
<dl class="section return"><dt>Returns</dt><dd>True if projector indices are stored. </dd></dl>

</div>
</div>
<a id="a9a727e6069185f42a12198df597e7c6e" name="a9a727e6069185f42a12198df597e7c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a727e6069185f42a12198df597e7c6e">&#9670;&#160;</a></span>hasReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasReferenceSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the track state has a non nullptr surface associated. </p>
<dl class="section return"><dt>Returns</dt><dd>whether a surface exists or not </dd></dl>

</div>
</div>
<a id="a5bdeaa8ece88091b540b439953e27d93" name="a5bdeaa8ece88091b540b439953e27d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdeaa8ece88091b540b439953e27d93">&#9670;&#160;</a></span>hasSmoothed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::hasSmoothed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for presence of smoothed track parameters. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the smoothed component exists. </dd></dl>

</div>
</div>
<a id="a9861fa7fb806028eb6ab74c98152e9c1" name="a9861fa7fb806028eb6ab74c98152e9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9861fa7fb806028eb6ab74c98152e9c1">&#9670;&#160;</a></span>hasUncalibratedSourceLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::hasUncalibratedSourceLink </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the point has an associated uncalibrated measurement. </p>
<dl class="section return"><dt>Returns</dt><dd>Whether it is set </dd></dl>

</div>
</div>
<a id="a0c262c2b5ad8f0c90c99a157de006a60" name="a0c262c2b5ad8f0c90c99a157de006a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c262c2b5ad8f0c90c99a157de006a60">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index within the trajectory. </p>
<dl class="section return"><dt>Returns</dt><dd>the index </dd></dl>

</div>
</div>
<a id="a646005da1a4e0fd60e864735dbbb4254" name="a646005da1a4e0fd60e864735dbbb4254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646005da1a4e0fd60e864735dbbb4254">&#9670;&#160;</a></span>jacobian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a0fb668c32599042bdb52cfa0db146ddb">Covariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::jacobian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the jacobian from the previous trackstate to this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The jacobian matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutable version </dd></dl>

</div>
</div>
<a id="a963bb4bd89f7e9f6db39b0215ef7ae28" name="a963bb4bd89f7e9f6db39b0215ef7ae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a963bb4bd89f7e9f6db39b0215ef7ae28">&#9670;&#160;</a></span>jacobian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a04aa68f896e3a74cfc505a953867aa70">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::jacobian </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the jacobian from the previous trackstate to this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The jacobian matrix </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Const version </dd></dl>

</div>
</div>
<a id="a4b952743d6b1f741c480358fc8674e49" name="a4b952743d6b1f741c480358fc8674e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b952743d6b1f741c480358fc8674e49">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator: const to const or mutable to mutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this TrackStateProxy </dd></dl>

</div>
</div>
<a id="a2a7d2d25ba9d29f2d08793e7d82a323d" name="a2a7d2d25ba9d29f2d08793e7d82a323d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7d2d25ba9d29f2d08793e7d82a323d">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, false &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator to from mutable <code>TrackStateProxy</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other TrackStateProxy to assign from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this TrackStateProxy </dd></dl>

</div>
</div>
<a id="a2776d616f96dd2cc9e55287853d8346b" name="a2776d616f96dd2cc9e55287853d8346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776d616f96dd2cc9e55287853d8346b">&#9670;&#160;</a></span>parameters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::parameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the best available parameters (smoothed, filtered, or predicted). </p>
<dl class="section return"><dt>Returns</dt><dd>Bound parameter map for the state. </dd></dl>

</div>
</div>
<a id="a14bee409ce04e472b9a5f007e2bb683c" name="a14bee409ce04e472b9a5f007e2bb683c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bee409ce04e472b9a5f007e2bb683c">&#9670;&#160;</a></span>parametersAtIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aeccd8d3a35af248c909696973307e1e8">ConstParameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::parametersAtIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a></td>          <td class="paramname"><span class="paramname"><em>parIndex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad32f3b6734489b4b156277cd99ec1da5" name="ad32f3b6734489b4b156277cd99ec1da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32f3b6734489b4b156277cd99ec1da5">&#9670;&#160;</a></span>parametersAtIndexMutable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac11c999ddcc05da568b3a67de7f9dfe3">Parameters</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::parametersAtIndexMutable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a></td>          <td class="paramname"><span class="paramname"><em>parIndex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b422188f5dabfaa9deb94c2a6ed2af8" name="a6b422188f5dabfaa9deb94c2a6ed2af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b422188f5dabfaa9deb94c2a6ed2af8">&#9670;&#160;</a></span>pathLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double &amp; <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::pathLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to the accumulated path length. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable path length. </dd></dl>

</div>
</div>
<a id="ab4ef83672e971d4325ecf9f1619f0398" name="ab4ef83672e971d4325ecf9f1619f0398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ef83672e971d4325ecf9f1619f0398">&#9670;&#160;</a></span>pathLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::pathLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the accumulated path length. </p>
<dl class="section return"><dt>Returns</dt><dd>Path length stored on the state. </dd></dl>

</div>
</div>
<a id="a8ba0f1e591afedf48f20f5bc1dea34bf" name="a8ba0f1e591afedf48f20f5bc1dea34bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba0f1e591afedf48f20f5bc1dea34bf">&#9670;&#160;</a></span>predicted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::predicted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the predicted parameter vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bound parameter map for the predicted state. </dd></dl>

</div>
</div>
<a id="a91893e2cf9f9d97417d144a94ee01f82" name="a91893e2cf9f9d97417d144a94ee01f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91893e2cf9f9d97417d144a94ee01f82">&#9670;&#160;</a></span>predicted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::predicted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the predicted parameter vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound parameter map for the predicted state. </dd></dl>

</div>
</div>
<a id="ad1d4c1592543653bf38a411b0c71ffcd" name="ad1d4c1592543653bf38a411b0c71ffcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d4c1592543653bf38a411b0c71ffcd">&#9670;&#160;</a></span>predictedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::predictedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the predicted covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bound covariance map for the predicted state. </dd></dl>

</div>
</div>
<a id="a279850fe954db0735e3181cfd56d7b69" name="a279850fe954db0735e3181cfd56d7b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279850fe954db0735e3181cfd56d7b69">&#9670;&#160;</a></span>predictedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::predictedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the predicted covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound covariance map for the predicted state. </dd></dl>

</div>
</div>
<a id="a1ec7af81a908e39fdf6a2ec9c6c4a1c1" name="a1ec7af81a908e39fdf6a2ec9c6c4a1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec7af81a908e39fdf6a2ec9c6c4a1c1">&#9670;&#160;</a></span>previous() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::previous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to the previous track state index. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable index of the previous state. </dd></dl>

</div>
</div>
<a id="ae455c518344fada230edba3c3572be0c" name="ae455c518344fada230edba3c3572be0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae455c518344fada230edba3c3572be0c">&#9670;&#160;</a></span>previous() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#ab10f01c2759ff4e801d804fdf1a91199">TrackIndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::previous </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the previous track state index in the linked trajectory. </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the previous state or <span class="tt">kTrackIndexInvalid</span>. </dd></dl>

</div>
</div>
<a id="abd61dda2e361b43c07ddae9491f70efc" name="abd61dda2e361b43c07ddae9491f70efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd61dda2e361b43c07ddae9491f70efc">&#9670;&#160;</a></span>projectorSubspaceHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#aaaa9c77f4dd9efc1ac464d9a941f2ef2">VariableBoundSubspaceHelper</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::projectorSubspaceHelper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a variable size subspace helper. </p>
<dl class="section return"><dt>Returns</dt><dd>The subspace helper </dd></dl>

</div>
</div>
<a id="ad89b9a55ab23c18569fe1a5416a8ea6c" name="ad89b9a55ab23c18569fe1a5416a8ea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89b9a55ab23c18569fe1a5416a8ea6c">&#9670;&#160;</a></span>projectorSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a1b6c456f1650d94a2549251f1306dde4">BoundSubspaceIndices</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::projectorSubspaceIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode the measurement projector indices. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound parameter indices used for projection. </dd></dl>

</div>
</div>
<a id="a412f66e00d2d9194b0d1c1adee50a279" name="a412f66e00d2d9194b0d1c1adee50a279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412f66e00d2d9194b0d1c1adee50a279">&#9670;&#160;</a></span>referenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::referenceSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>the reference surface </dd></dl>

</div>
</div>
<a id="abf5df1fa62aff40e599d1ae290dd6c36" name="abf5df1fa62aff40e599d1ae290dd6c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5df1fa62aff40e599d1ae290dd6c36">&#9670;&#160;</a></span>setProjectorSubspaceIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::setProjectorSubspaceIndices </td>
          <td>(</td>
          <td class="paramtype">const index_range_t &amp;</td>          <td class="paramname"><span class="paramname"><em>subspaceIndices</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store subspace indices describing the measurement projector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index_range_t</td><td>Range of indices to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subspaceIndices</td><td>Collection of bound indices forming the projector rows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57835d73120cd60cf7dd0c37fa92d3c3" name="a57835d73120cd60cf7dd0c37fa92d3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57835d73120cd60cf7dd0c37fa92d3c3">&#9670;&#160;</a></span>setReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::setReferenceSurface </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>srf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the reference surface to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srf</td><td>Shared pointer to the surface to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is only present in case <code>ReadOnly</code> is false. </dd></dl>

</div>
</div>
<a id="ad9e34422bd144eca89d0a0a3a3b085ab" name="ad9e34422bd144eca89d0a0a3a3b085ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e34422bd144eca89d0a0a3a3b085ab">&#9670;&#160;</a></span>setUncalibratedSourceLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::setUncalibratedSourceLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_acts_1_1_source_link.html">SourceLink</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>sourceLink</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an uncalibrated source link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceLink</td><td>The uncalibrated source link to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8086412d1967b46203d8a00c0811e8de" name="a8086412d1967b46203d8a00c0811e8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8086412d1967b46203d8a00c0811e8de">&#9670;&#160;</a></span>shareFrom() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::shareFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>component</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share a shareable component from another track state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Track state proxy to share component from </td></tr>
    <tr><td class="paramname">component</td><td>Which component to share. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The track states both need to be stored in the same <code>MultiTrajectory</code> instance </dd></dl>

</div>
</div>
<a id="a4bb9736a7c382a83ce79d543f563e6f9" name="a4bb9736a7c382a83ce79d543f563e6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb9736a7c382a83ce79d543f563e6f9">&#9670;&#160;</a></span>shareFrom() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;bool ReadOnlyOther&gt; <br />
requires (!<a class="el" href="#a99b5acfc879ef16dc1c017452b5bbe87">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::shareFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a>, M, ReadOnlyOther &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareTarget</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share a shareable component from another track state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Track state proxy to share component(s) from </td></tr>
    <tr><td class="paramname">shareSource</td><td>Which component to share from </td></tr>
    <tr><td class="paramname">shareTarget</td><td>Which component to share as. This can be be different from as <code class="param">shareSource</code>, e.g. predicted can be shared as filtered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Shareable components are predicted, filtered, smoothed, calibrated, jacobian, or projector. See <code>TrackStatePropMask</code>. </dd></dl>

</div>
</div>
<a id="a95304204468f54911b50a674f7ada1d6" name="a95304204468f54911b50a674f7ada1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95304204468f54911b50a674f7ada1d6">&#9670;&#160;</a></span>shareFrom() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::shareFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareSource</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>shareTarget</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Share a shareable component <b>within</b> this track state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shareSource</td><td>Which component to share from </td></tr>
    <tr><td class="paramname">shareTarget</td><td>Which component to share as. This should be different from as <code class="param">shareSource</code>, e.g. predicted can be shared as filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd2a6f05110c3d1844d924aaccda1e93" name="acd2a6f05110c3d1844d924aaccda1e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2a6f05110c3d1844d924aaccda1e93">&#9670;&#160;</a></span>smoothed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ae1e81f4a291996c6f5b7f0c7b94b6dca">ParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::smoothed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the smoothed parameter vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bound parameter map for the smoothed state. </dd></dl>

</div>
</div>
<a id="a9797391008d4c7c2b9eb507ce63f91cd" name="a9797391008d4c7c2b9eb507ce63f91cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9797391008d4c7c2b9eb507ce63f91cd">&#9670;&#160;</a></span>smoothed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#aae5aa77e2e24848e8b241d784ad23dfd">ConstParametersMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::smoothed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the smoothed parameter vector. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound parameter map for the smoothed state. </dd></dl>

</div>
</div>
<a id="a46478c8cb23308835288edc2b995c487" name="a46478c8cb23308835288edc2b995c487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46478c8cb23308835288edc2b995c487">&#9670;&#160;</a></span>smoothedCovariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#a2d98de5976dbf8e189a73f2b8ca219b0">CovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::smoothedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the smoothed covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bound covariance map for the smoothed state. </dd></dl>

</div>
</div>
<a id="a9f5d8cac8885aec3e5c215da961f14b9" name="a9f5d8cac8885aec3e5c215da961f14b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5d8cac8885aec3e5c215da961f14b9">&#9670;&#160;</a></span>smoothedCovariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_state_proxy_common.html#ab0f2f94fc5a3600cc1f61a368e427963">ConstCovarianceMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::smoothedCovariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the smoothed covariance matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Bound covariance map for the smoothed state. </dd></dl>

</div>
</div>
<a id="a5fbed9bb3b46afcbd08f6d8559b55684" name="a5fbed9bb3b46afcbd08f6d8559b55684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbed9bb3b46afcbd08f6d8559b55684">&#9670;&#160;</a></span>trajectory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::trajectory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the underlying backend container. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the backend container </dd></dl>

</div>
</div>
<a id="a400c5a87fdeb279c3c705463f95195ff" name="a400c5a87fdeb279c3c705463f95195ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400c5a87fdeb279c3c705463f95195ff">&#9670;&#160;</a></span>trajectory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_multi_trajectory.html">MultiTrajectory</a>&lt; <a class="el" href="#ab5e5ad251ac9d342e90dfe255b698896">Trajectory</a> &gt; &amp; <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::trajectory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const reference to the underlying backend container. </p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the backend container </dd></dl>

</div>
</div>
<a id="a791a21c02ce98188ac4b5dd56da9811f" name="a791a21c02ce98188ac4b5dd56da9811f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791a21c02ce98188ac4b5dd56da9811f">&#9670;&#160;</a></span>typeFlags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#aea0ba56b78fc7596ea8c54f1fdd6dc86">MutableTrackStateTypeMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::typeFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve mutable track-state type flags. </p>
<dl class="section return"><dt>Returns</dt><dd>Mutable bit mask describing the state type. </dd></dl>

</div>
</div>
<a id="a23edcbb710e2a286de0052f4cc549661" name="a23edcbb710e2a286de0052f4cc549661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23edcbb710e2a286de0052f4cc549661">&#9670;&#160;</a></span>typeFlags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#a396cf9dc9d64968f658960b949be9db2">ConstTrackStateTypeMap</a> <a class="el" href="class_acts_1_1_track_state_proxy_common.html">Acts::TrackStateProxyCommon</a>&lt; <a class="el" href="#a7c64da1d3029b735fd7651a2cc12cd9e">TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;, read_only &gt;::typeFlags </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the track-state type flags. </p>
<dl class="section return"><dt>Returns</dt><dd>Bit mask describing the state type. </dd></dl>

</div>
</div>
<a id="a58ecea4d41d25884af489e1391a1fdb5" name="a58ecea4d41d25884af489e1391a1fdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ecea4d41d25884af489e1391a1fdb5">&#9670;&#160;</a></span>unset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::unset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unset an optional track state component. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track state proxy is not read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The component to unset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="ac971a8625ee702ef7cb743fa52e4f186" name="ac971a8625ee702ef7cb743fa52e4f186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac971a8625ee702ef7cb743fa52e4f186">&#9670;&#160;</a></span>kInvalid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a88faa591bbaae408e41c6db7fb39e0e5">IndexType</a> <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::kInvalid = <a class="el" href="namespace_acts.html#a589e3f01b082df3de46c2a6f5e6ce749">kTrackIndexInvalid</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sentinel value that indicates an invalid index. </p>

</div>
</div>
<a id="a99b5acfc879ef16dc1c017452b5bbe87" name="a99b5acfc879ef16dc1c017452b5bbe87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b5acfc879ef16dc1c017452b5bbe87">&#9670;&#160;</a></span>ReadOnly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename trajectory_t, std::size_t M, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_state_proxy.html">Acts::TrackStateProxy</a>&lt; trajectory_t, M, read_only &gt;::ReadOnly = read_only</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this track state proxy is read-only or if it can be modified. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="class_acts_1_1_track_state_proxy.html">TrackStateProxy</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
