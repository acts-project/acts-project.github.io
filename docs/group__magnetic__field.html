<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Magnetic Field</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__magnetic__field.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Magnetic Field <div class="ingroups"><a class="el" href="group__detector__descr.html">Detector Description</a> &#124; <a class="el" href="group__propagation.html">Propagation</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>A description of magnetic field configurations for algorithms. </p>
<p>The magnetic field component of ACTS provides functionality to describe arbitrary magnetic field configurations in an experiment. It is implemented in a generic way and can be extended to connect to an experiment specific upstream source of field data.</p>
<p>Algorithms which need magnetic field information (e.g. <a class="el" href="class_acts_1_1_atlas_stepper.html">Acts::AtlasStepper</a>, <a class="el" href="class_acts_1_1_eigen_stepper.html">Acts::EigenStepper</a>) accept the magnetic field as an explicit argument.</p>
<ul>
<li>The documentation of <a class="el" href="class_acts_1_1_magnetic_field_provider.html">Acts::MagneticFieldProvider</a> provides a good overview of the design and patterns associated with the magnetic field component.</li>
<li>The potentially event-context dependent configuration of the magnetic field is documented in <a class="el" href="class_acts_1_1_magnetic_field_context.html">Acts::MagneticFieldContext</a>.</li>
</ul>
<p><b>Classes of field providers in the library:</b></p>
<ul>
<li>Analytical magnetic fields like <a class="el" href="class_acts_1_1_solenoid_b_field.html">Acts::SolenoidBField</a> that calculate their respective field values on the fly.</li>
<li><em>Special</em> magnetic fields like <a class="el" href="class_acts_1_1_constant_b_field.html">Acts::ConstantBField</a> or <a class="el" href="class_acts_1_1_null_b_field.html">Acts::NullBField</a></li>
<li>The main <a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a> that is most commonly used by experiments to provide magnetic field maps from discrete data. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Acts_3A_3AConstantBField" id="r_Acts_3A_3AConstantBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_constant_b_field.html">Acts::ConstantBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The simplest magnetic field implementation is a constant field, which returns the same field values at every queried location.  <a href="class_acts_1_1_constant_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AInterpolatedBFieldMap_3C_20grid_5Ft_20_3E" id="r_Acts_3A_3AInterpolatedBFieldMap_3C_20grid_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap&lt; grid_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates magnetic field value from field values on a given grid.  <a href="class_acts_1_1_interpolated_b_field_map.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AInterpolatedMagneticField" id="r_Acts_3A_3AInterpolatedMagneticField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_interpolated_magnetic_field.html">Acts::InterpolatedMagneticField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for interpolated magnetic field providers.  <a href="class_acts_1_1_interpolated_magnetic_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AMagneticFieldContext" id="r_Acts_3A_3AMagneticFieldContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_magnetic_field_context.html">Acts::MagneticFieldContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object for lookup of magnetic field values.  <a href="class_acts_1_1_magnetic_field_context.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AMagneticFieldProvider" id="r_Acts_3A_3AMagneticFieldProvider"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_magnetic_field_provider.html">Acts::MagneticFieldProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all magnetic field providers.  <a href="class_acts_1_1_magnetic_field_provider.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AMultiRangeBField" id="r_Acts_3A_3AMultiRangeBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_multi_range_b_field.html">Acts::MultiRangeBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magnetic field provider modelling a magnetic field consisting of several (potentially overlapping) regions of constant values.  <a href="class_acts_1_1_multi_range_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3ANullBField" id="r_Acts_3A_3ANullBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_null_b_field.html">Acts::NullBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null bfield which returns 0 always.  <a href="class_acts_1_1_null_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3ASolenoidBField" id="r_Acts_3A_3ASolenoidBField"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_solenoid_b_field.html">Acts::SolenoidBField</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analytical solenoid magnetic field implementation.  <a href="class_acts_1_1_solenoid_b_field.html#details">More...</a><br /></td></tr>
<tr class="memitem:ActsPlugins_3A_3ADD4hepFieldAdapter" id="r_ActsPlugins_3A_3ADD4hepFieldAdapter"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_plugins_1_1_d_d4hep_field_adapter.html">ActsPlugins::DD4hepFieldAdapter</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga38f23b40e50cf64609d44c5392c00088" id="r_ga38f23b40e50cf64609d44c5392c00088"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38f23b40e50cf64609d44c5392c00088">Acts::fieldMapRZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;localToGlobalBin, std::vector&lt; double &gt; rPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a> &gt; &amp;bField, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>, double BFieldUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#ae1a6a8868aedfe9a2fa3c3d6d0fae230">UnitConstants::T</a>, bool firstQuadrant=false)</td></tr>
<tr class="memdesc:ga38f23b40e50cf64609d44c5392c00088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMap.  <br /></td></tr>
<tr class="memitem:ga0a2a24528115e4a19afa750157c52642" id="r_ga0a2a24528115e4a19afa750157c52642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0a2a24528115e4a19afa750157c52642">Acts::fieldMapXYZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;localToGlobalBin, std::vector&lt; double &gt; xPos, std::vector&lt; double &gt; yPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &gt; &amp;bField, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>, double BFieldUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#ae1a6a8868aedfe9a2fa3c3d6d0fae230">UnitConstants::T</a>, bool firstOctant=false)</td></tr>
<tr class="memdesc:ga0a2a24528115e4a19afa750157c52642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMap.  <br /></td></tr>
<tr class="memitem:ga5867649c2811a2b164af6e62f4ee6d8c" id="r_ga5867649c2811a2b164af6e62f4ee6d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5867649c2811a2b164af6e62f4ee6d8c">Acts::makeMagneticFieldMapRzFromText</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;localToGlobalBin, const std::string &amp;fieldMapFile, double lengthUnit, double BFieldUnit, bool firstQuadrant=false, const std::string &amp;delimiter=&quot;&quot;)</td></tr>
<tr class="memdesc:ga5867649c2811a2b164af6e62f4ee6d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMapper.  <br /></td></tr>
<tr class="memitem:ga3baad317424227151687cad974537339" id="r_ga3baad317424227151687cad974537339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3baad317424227151687cad974537339">Acts::makeMagneticFieldMapXyzFromText</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;localToGlobalBin, const std::string &amp;fieldMapFile, double lengthUnit, double BFieldUnit, bool firstOctant=false, const std::string &amp;delimiter=&quot;&quot;)</td></tr>
<tr class="memdesc:ga3baad317424227151687cad974537339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the FieldMapper.  <br /></td></tr>
<tr class="memitem:ga5036eb1d51177fbb2503f1dc623d197b" id="r_ga5036eb1d51177fbb2503f1dc623d197b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5036eb1d51177fbb2503f1dc623d197b">Acts::solenoidFieldMap</a> (const std::pair&lt; double, double &gt; &amp;rLim, const std::pair&lt; double, double &gt; &amp;zLim, const std::pair&lt; std::size_t, std::size_t &gt; &amp;nBins, const <a class="el" href="class_acts_1_1_solenoid_b_field.html">SolenoidBField</a> &amp;field)</td></tr>
<tr class="memdesc:ga5036eb1d51177fbb2503f1dc623d197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which takes an existing SolenoidBField instance and creates a field mapper by sampling grid points from the analytical solenoid field.  <br /></td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga38f23b40e50cf64609d44c5392c00088" name="ga38f23b40e50cf64609d44c5392c00088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38f23b40e50cf64609d44c5392c00088">&#9670;&#160;</a></span>fieldMapRZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt; Acts::fieldMapRZ </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>localToGlobalBin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>rPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>zPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bField</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lengthUnit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>BFieldUnit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#ae1a6a8868aedfe9a2fa3c3d6d0fae230">UnitConstants::T</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstQuadrant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to setup the FieldMap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localToGlobalBin</td><td>Function mapping the local bins of r,z to the global bin of the map magnetic field value</td></tr>
  </table>
  </dd>
</dl>
<p>e.g.: we have small grid with the values: r={2,3}, z ={4,5}, the corresponding indices are i (belonging to r) and j (belonging to z), the globalIndex is M (belonging to the value of the magnetic field B(r,z)) and the field map is: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">r  </th><th class="markdownTableHeadCenter">i  </th><th class="markdownTableHeadCenter">z  </th><th class="markdownTableHeadCenter">j  </th><th class="markdownTableHeadCenter">B(r,z)  </th><th class="markdownTableHeadLeft">M  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2.323  </td><td class="markdownTableBodyLeft">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2.334  </td><td class="markdownTableBodyLeft">1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2.325  </td><td class="markdownTableBodyLeft">2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2.331  </td><td class="markdownTableBodyLeft">3  </td></tr>
</table>
<p>In this case the function would look like: </p><div class="fragment"><div class="line">[](std::array&lt;std::size_t, 2&gt; binsRZ, std::array&lt;std::size_t, 2&gt; nBinsRZ) {</div>
<div class="line">   <span class="keywordflow">return</span> (binsRZ.at(0) * nBinsRZ.at(1) + binsRZ.at(1));</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPos</td><td>Values of the grid points in r </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zPos</td><td>Values of the grid points in z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bField</td><td>The magnetic field values inr r and z for all given grid points stored in a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function localToGlobalBin determines how the magnetic field was stored in the vector in respect to the grid values </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthUnit</td><td>The unit of the grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BFieldUnit</td><td>The unit of the magnetic field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstQuadrant</td><td>Flag if set to true indicating that only the first quadrant of the grid points and the BField values has been given. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code class="param">firstQuadrant</code> is true will create a field that is symmetric for all quadrants. e.g. we have the grid values r={0,1} with BFieldValues={2,3} on the r axis. If the flag is set to true the r-axis grid values will be set to {-1,0,1} and the BFieldValues will be set to {3,2,3}. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A field map instance for use in interpolation. </dd></dl>

</div>
</div>
<a id="ga0a2a24528115e4a19afa750157c52642" name="ga0a2a24528115e4a19afa750157c52642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2a24528115e4a19afa750157c52642">&#9670;&#160;</a></span>fieldMapXYZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt; Acts::fieldMapXYZ </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>localToGlobalBin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>xPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>yPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>zPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Acts::Vector3</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bField</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lengthUnit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>BFieldUnit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#ae1a6a8868aedfe9a2fa3c3d6d0fae230">UnitConstants::T</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstOctant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to setup the FieldMap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localToGlobalBin</td><td>Function mapping the local bins of x,y,z to the global bin of the map magnetic field value</td></tr>
  </table>
  </dd>
</dl>
<p>e.g.: we have small grid with the values: x={2,3}, y={3,4}, z ={4,5}, the corresponding indices are i (belonging to x), j (belonging to y) and k (belonging to z), the globalIndex is M (belonging to the value of the magnetic field B(x,y,z)) and the field map is:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">x  </th><th class="markdownTableHeadCenter">i  </th><th class="markdownTableHeadCenter">y  </th><th class="markdownTableHeadCenter">j  </th><th class="markdownTableHeadCenter">z  </th><th class="markdownTableHeadCenter">k  </th><th class="markdownTableHeadCenter">B(x,y,z)  </th><th class="markdownTableHeadLeft">M  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2.323  </td><td class="markdownTableBodyLeft">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2.334  </td><td class="markdownTableBodyLeft">1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2.325  </td><td class="markdownTableBodyLeft">2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2.331  </td><td class="markdownTableBodyLeft">3  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2.323  </td><td class="markdownTableBodyLeft">4  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2.334  </td><td class="markdownTableBodyLeft">5  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">2.325  </td><td class="markdownTableBodyLeft">6  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">2.331  </td><td class="markdownTableBodyLeft">7  </td></tr>
</table>
<p>In this case the function would look like: </p><div class="fragment"><div class="line">[](std::array&lt;std::size_t, 3&gt; binsXYZ, std::array&lt;std::size_t, 3&gt; nBinsXYZ)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (binsXYZ.at(0) * (nBinsXYZ.at(1) * nBinsXYZ.at(2))</div>
<div class="line">       + binsXYZ.at(1) * nBinsXYZ.at(2)</div>
<div class="line">       + binsXYZ.at(2));</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The grid point values <code class="param">xPos</code>, <code class="param">yPos</code> and <code class="param">zPos</code> do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xPos</td><td>Values of the grid points in x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yPos</td><td>Values of the grid points in y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zPos</td><td>Values of the grid points in z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bField</td><td>The magnetic field values inr r and z for all given grid points stored in a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function <code class="param">localToGlobalBin</code> determines how the magnetic field was stored in the vector in respect to the grid values </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthUnit</td><td>The unit of the grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BFieldUnit</td><td>The unit of the magnetic field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstOctant</td><td>Flag if set to true indicating that only the first octant of the grid points and the BField values has been given. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code class="param">firstOctant</code> is true, the function will assume a symmetrical field for all quadrants. e.g. we have the grid values z={0,1} with BFieldValues={2,3} on the r axis. If the flag is set to true the z-axis grid values will be set to {-1,0,1} and the BFieldValues will be set to {3,2,3}. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A field map instance for use in interpolation. </dd></dl>

</div>
</div>
<a id="ga5867649c2811a2b164af6e62f4ee6d8c" name="ga5867649c2811a2b164af6e62f4ee6d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5867649c2811a2b164af6e62f4ee6d8c">&#9670;&#160;</a></span>makeMagneticFieldMapRzFromText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt; &gt; &gt; Acts::makeMagneticFieldMapRzFromText </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>localToGlobalBin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldMapFile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lengthUnit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>BFieldUnit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstQuadrant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to setup the FieldMapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localToGlobalBin</td><td>Function mapping the local bins of r,z to the global bin of the map magnetic field value e.g.: we have small grid with the values: r={2,3}, z ={4,5}, the corresponding indices are i(r) and j(z), the globalIndex is M and the field map is: </td></tr>
  </table>
  </dd>
</dl>
<h2 class="doxsection"><a class="anchor" id="autotoc_md71"></a>
|| r | i || z | j || |B(r,z)| || M ||</h2>
<p>|| 2 | 0 || 4 | 0 || 2.323 || 0 || || 2 | 0 || 5 | 1 || 2.334 || 1 || || 3 | 1 || 4 | 0 || 2.325 || 2 || || 3 | 1 || 5 | 1 || 2.331 || 3 ||</p>
<div class="fragment"><div class="line">In <span class="keyword">this</span> <span class="keywordflow">case</span> the function would look like:</div>
<div class="line">[](std::array&lt;std::size_t, 2&gt; binsRZ, std::array&lt;std::size_t, 2&gt; nBinsRZ) {</div>
<div class="line">   <span class="keywordflow">return</span> (binsRZ.at(0) * nBinsRZ.at(1) + binsRZ.at(1));</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fieldMapFile</td><td>Path to file containing field map in txt format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthUnit</td><td>The unit of the grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BFieldUnit</td><td>The unit of the magnetic field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This information is only used as a hint for the required size of the internal vectors. A correct value is not needed, but will help to speed up the field map initialization process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstQuadrant</td><td>Flag if set to true indicating that only the first quadrant of the grid points and the BField values has been given and that the BFieldMap should be created symmetrically for all quadrants. e.g. we have the grid values r={0,1} with BFieldValues={2,3} on the r axis. If the flag is set to true the r-axis grid values will be set to {-1,0,1} and the BFieldValues will be set to {3,2,3}. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">delimiter</td><td>The delimiter used in the text file to separate values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3baad317424227151687cad974537339" name="ga3baad317424227151687cad974537339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3baad317424227151687cad974537339">&#9670;&#160;</a></span>makeMagneticFieldMapXyzFromText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">AxisType::Equidistant</a> &gt; &gt; &gt; Acts::makeMagneticFieldMapXyzFromText </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>localToGlobalBin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fieldMapFile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lengthUnit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>BFieldUnit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>firstOctant</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to setup the FieldMapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localToGlobalBin</td><td>Function mapping the local bins of x,y,z to the global bin of the map magnetic field value e.g.: we have small grid with the values: x={2,3}, y={3,4}, z ={4,5}, the corresponding indices are i(x), j(y) and z(k), the globalIndex is M and the field map is: </td></tr>
  </table>
  </dd>
</dl>
<h2 class="doxsection"><a class="anchor" id="autotoc_md72"></a>
|| x | i || y | j || z | k || |B(x,y,z)| || M ||</h2>
<p>|| 2 | 0 || 3 | 0 || 4 | 0 || 2.323 || 0 || || 2 | 0 || 3 | 0 || 5 | 1 || 2.334 || 1 || || 2 | 0 || 4 | 1 || 4 | 0 || 2.325 || 2 || || 2 | 0 || 4 | 1 || 5 | 1 || 2.331 || 3 || || 3 | 1 || 3 | 0 || 4 | 0 || 2.323 || 4 || || 3 | 1 || 3 | 0 || 5 | 1 || 2.334 || 5 || || 3 | 1 || 4 | 1 || 4 | 0 || 2.325 || 6 || || 3 | 1 || 4 | 1 || 5 | 1 || 2.331 || 7 ||</p>
<div class="fragment"><div class="line">In <span class="keyword">this</span> <span class="keywordflow">case</span> the function would look like:</div>
<div class="line">[](std::array&lt;std::size_t, 3&gt; binsXYZ, std::array&lt;std::size_t, 3&gt; nBinsXYZ)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (binsXYZ.at(0) * (nBinsXYZ.at(1) * nBinsXYZ.at(2))</div>
<div class="line">       + binsXYZ.at(1) * nBinsXYZ.at(2)</div>
<div class="line">       + binsXYZ.at(2));</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fieldMapFile</td><td>Path to file containing field map in txt format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthUnit</td><td>The unit of the grid points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BFieldUnit</td><td>The unit of the magnetic field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This information is only used as a hint for the required size of the internal vectors. A correct value is not needed, but will help to speed up the field map initialization process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstOctant</td><td>Flag if set to true indicating that only the first octant of the grid points and the BField values has been given and that the BFieldMap should be created symmetrically for all quadrants. e.g. we have the grid values z={0,1} with BFieldValues={2,3} on the r axis. If the flag is set to true the z-axis grid values will be set to {-1,0,1} and the BFieldValues will be set to {3,2,3}. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">delimiter</td><td>The delimiter used in the text file to separate values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5036eb1d51177fbb2503f1dc623d197b" name="ga5036eb1d51177fbb2503f1dc623d197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5036eb1d51177fbb2503f1dc623d197b">&#9670;&#160;</a></span>solenoidFieldMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_interpolated_b_field_map.html">Acts::InterpolatedBFieldMap</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Acts::Grid</a>&lt; <a class="el" href="group__algebra__types.html#gabb76f2d48e0590ef82a8afaad39a77b5">Acts::Vector2</a>, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Acts::Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt; Acts::solenoidFieldMap </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rLim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>zLim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::size_t, std::size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nBins</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_solenoid_b_field.html">SolenoidBField</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>field</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which takes an existing SolenoidBField instance and creates a field mapper by sampling grid points from the analytical solenoid field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rLim</td><td>pair of r bounds </td></tr>
    <tr><td class="paramname">zLim</td><td>pair of z bounds </td></tr>
    <tr><td class="paramname">nBins</td><td>pair of bin counts </td></tr>
    <tr><td class="paramname">field</td><td>the solenoid field instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A field map instance for use in interpolation. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
