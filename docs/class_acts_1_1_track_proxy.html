<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Acts::TrackProxy&lt; track_container_t, trajectory_t, holder_t, read_only &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js">
</script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('class_acts_1_1_track_proxy.html','','class_acts_1_1_track_proxy-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Acts::TrackProxy&lt; track_container_t, trajectory_t, holder_t, read_only &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Proxy class representing a single track.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_track_proxy_8hpp_source.html">Acts/EventData/TrackProxy.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Acts::TrackProxy&lt; track_container_t, trajectory_t, holder_t, read_only &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="class_acts_1_1_track_proxy__inherit__graph.svg" width="590" height="343"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a658d133ca50acf18de523695c5d68f1d" id="r_a658d133ca50acf18de523695c5d68f1d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a658d133ca50acf18de523695c5d68f1d">ConstCovariance</a></td></tr>
<tr class="memdesc:a658d133ca50acf18de523695c5d68f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a1cf8f5adf5f851bacb83e9a8f2771891">Covariance</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:ac99d36ea3253a188c77863b2dcc1216c" id="r_ac99d36ea3253a188c77863b2dcc1216c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac99d36ea3253a188c77863b2dcc1216c">ConstParameters</a></td></tr>
<tr class="memdesc:ac99d36ea3253a188c77863b2dcc1216c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#a7e8c1a9321efd1d543fc582377558df7">Parameters</a>, but with const semantics.  <br /></td></tr>
<tr class="memitem:a5b030607cf1603fd3cf61f730ddf7dd7" id="r_a5b030607cf1603fd3cf61f730ddf7dd7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b030607cf1603fd3cf61f730ddf7dd7">ConstProxyType</a> = <a class="el" href="#a20fe849b319215f22efcf54ff4766e9e">ConstTrackProxy</a></td></tr>
<tr class="memdesc:a5b030607cf1603fd3cf61f730ddf7dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an associated const track proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:a20fe849b319215f22efcf54ff4766e9e" id="r_a20fe849b319215f22efcf54ff4766e9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20fe849b319215f22efcf54ff4766e9e">ConstTrackProxy</a></td></tr>
<tr class="memdesc:a20fe849b319215f22efcf54ff4766e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the const version of this track proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:ac8d6b26852a5efa2e3365a2314ae65a1" id="r_ac8d6b26852a5efa2e3365a2314ae65a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8d6b26852a5efa2e3365a2314ae65a1">ConstTrackStateProxy</a> = typename Trajectory::ConstTrackStateProxy</td></tr>
<tr class="memdesc:ac8d6b26852a5efa2e3365a2314ae65a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an associated const track state proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:ae288d68ecea172c537b59abad56826a2" id="r_ae288d68ecea172c537b59abad56826a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae288d68ecea172c537b59abad56826a2">Container</a> = track_container_t</td></tr>
<tr class="memdesc:ae288d68ecea172c537b59abad56826a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The track container backend given as a template parameter.  <br /></td></tr>
<tr class="memitem:a1cf8f5adf5f851bacb83e9a8f2771891" id="r_a1cf8f5adf5f851bacb83e9a8f2771891"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cf8f5adf5f851bacb83e9a8f2771891">Covariance</a></td></tr>
<tr class="memdesc:a1cf8f5adf5f851bacb83e9a8f2771891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a bound covariance.  <br /></td></tr>
<tr class="memitem:a53fe18b4659a50f1ff7529423adfd93a" id="r_a53fe18b4659a50f1ff7529423adfd93a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> = typename Container::IndexType</td></tr>
<tr class="memdesc:a53fe18b4659a50f1ff7529423adfd93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type of the track container.  <br /></td></tr>
<tr class="memitem:a00f56d433d15782817a75f9de53a0d14" id="r_a00f56d433d15782817a75f9de53a0d14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00f56d433d15782817a75f9de53a0d14">MutableTrackProxy</a></td></tr>
<tr class="memdesc:a00f56d433d15782817a75f9de53a0d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the mutable version of this track proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:a7e8c1a9321efd1d543fc582377558df7" id="r_a7e8c1a9321efd1d543fc582377558df7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e8c1a9321efd1d543fc582377558df7">Parameters</a></td></tr>
<tr class="memdesc:a7e8c1a9321efd1d543fc582377558df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map-type for a bound parameter vector.  <br /></td></tr>
<tr class="memitem:a5c1457f0d31400817d4204b6c60ec63e" id="r_a5c1457f0d31400817d4204b6c60ec63e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c1457f0d31400817d4204b6c60ec63e">TrackStateProxy</a> = typename Trajectory::TrackStateProxy</td></tr>
<tr class="memdesc:a5c1457f0d31400817d4204b6c60ec63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for an associated mutable track state proxy, with the same backends.  <br /></td></tr>
<tr class="memitem:a472a9c319d8880a00057aa49b4450515" id="r_a472a9c319d8880a00057aa49b4450515"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a472a9c319d8880a00057aa49b4450515">Trajectory</a> = trajectory_t</td></tr>
<tr class="memdesc:a472a9c319d8880a00057aa49b4450515"><td class="mdescLeft">&#160;</td><td class="mdescRight">The track state container backend given as a template parameter.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21f27df670a69a25284a1c848db7c687" id="r_a21f27df670a69a25284a1c848db7c687"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f27df670a69a25284a1c848db7c687">container</a> ()</td></tr>
<tr class="memdesc:a21f27df670a69a25284a1c848db7c687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the track container backend, mutable version.  <br /></td></tr>
<tr class="memitem:a1244943cd9ac6543d92b677f5d971d52" id="r_a1244943cd9ac6543d92b677f5d971d52"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1244943cd9ac6543d92b677f5d971d52">container</a> () const</td></tr>
<tr class="memdesc:a1244943cd9ac6543d92b677f5d971d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the track container backend, const version.  <br /></td></tr>
<tr class="memitem:a3a15902f7e3d11de0b17eb9f3151a973" id="r_a3a15902f7e3d11de0b17eb9f3151a973"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a15902f7e3d11de0b17eb9f3151a973">createParametersAtReference</a> () const</td></tr>
<tr class="memdesc:a3a15902f7e3d11de0b17eb9f3151a973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the track parameters at the reference surface.  <br /></td></tr>
<tr class="memitem:a6564a71452cccc25478e8b0f19f9d99c" id="r_a6564a71452cccc25478e8b0f19f9d99c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_acts.html#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6564a71452cccc25478e8b0f19f9d99c">createParametersFromState</a> (const <a class="el" href="#ac8d6b26852a5efa2e3365a2314ae65a1">ConstTrackStateProxy</a> &amp;trackState) const</td></tr>
<tr class="memdesc:a6564a71452cccc25478e8b0f19f9d99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a track state into track parameters.  <br /></td></tr>
<tr class="memitem:a89e6800cf06b95cdc7e7de2b3abe0bb5" id="r_a89e6800cf06b95cdc7e7de2b3abe0bb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89e6800cf06b95cdc7e7de2b3abe0bb5">operator==</a> (const <a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> &amp;other) const</td></tr>
<tr class="memdesc:a89e6800cf06b95cdc7e7de2b3abe0bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator with another track proxy Checks the container identity and the track index.  <br /></td></tr>
<tr id="pub-methods-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Constructors and assignment operator</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_proxy_construct"></a> Public constructors and assignment operators for <code>TrackProxy</code> only allow construction from another <code>TrackProxy</code>. You should generally not have to construct <code>TrackProxy</code> manually. </p>
</div></td></tr>
<tr class="memitem:ac1c227c580f1faa008376c71e349df37" id="r_ac1c227c580f1faa008376c71e349df37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> (const TrackProxy &amp;other)=default</td></tr>
<tr class="memdesc:ac1c227c580f1faa008376c71e349df37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor: const to const or mutable to mutable.  <br /></td></tr>
<tr class="memitem:ac15d5edb3f464ad4faf7a1e4d86f1810" id="r_ac15d5edb3f464ad4faf7a1e4d86f1810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac15d5edb3f464ad4faf7a1e4d86f1810">operator=</a> (const <a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> &amp;other)=default</td></tr>
<tr class="memdesc:ac15d5edb3f464ad4faf7a1e4d86f1810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator: const to const or mutable to mutable.  <br /></td></tr>
<tr class="memitem:ab9567992d8cd81a438f16a7e66312f09" id="r_ab9567992d8cd81a438f16a7e66312f09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9567992d8cd81a438f16a7e66312f09">TrackProxy</a> (const <a class="el" href="#a00f56d433d15782817a75f9de53a0d14">MutableTrackProxy</a> &amp;other)</td></tr>
<tr class="memdesc:ab9567992d8cd81a438f16a7e66312f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from mutable track proxy.  <br /></td></tr>
<tr class="memitem:aaafee755fec1e0bf4016d56bab900b06" id="r_aaafee755fec1e0bf4016d56bab900b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaafee755fec1e0bf4016d56bab900b06">operator=</a> (const <a class="el" href="#a00f56d433d15782817a75f9de53a0d14">MutableTrackProxy</a> &amp;other)</td></tr>
<tr class="memdesc:aaafee755fec1e0bf4016d56bab900b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator from mutable track proxy.  <br /></td></tr>
<tr id="pub-methods-1" class="groupHeader"><td colspan="2"><div class="groupHeader">TrackProxy properties</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_proxy_props"></a> Methods that give access to the properties of a track represented by <code>TrackProxy</code>.</p>
<p>Many of these methods come in a <code>const</code> and a non-<code>const</code> version. The non-<code>const</code> version is only available if you have an instance of <code>TrackProxy</code> that does not have the <code>read_only</code> template parameter set to <code>true</code>, even if you hold it as an lvalue. </p>
</div></td></tr>
<tr class="memitem:a25e0a66cbacf16a864fac81b954f6971" id="r_a25e0a66cbacf16a864fac81b954f6971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e0a66cbacf16a864fac81b954f6971">tipIndex</a> () const</td></tr>
<tr class="memdesc:a25e0a66cbacf16a864fac81b954f6971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tip index, i.e.  <br /></td></tr>
<tr class="memitem:ac0ee0f6dabaa02110a59e22cc57bba12" id="r_ac0ee0f6dabaa02110a59e22cc57bba12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ee0f6dabaa02110a59e22cc57bba12">stemIndex</a> () const</td></tr>
<tr class="memdesc:ac0ee0f6dabaa02110a59e22cc57bba12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the stem, i.e.  <br /></td></tr>
<tr class="memitem:acccd8c2750199cfb86c687417d5f7f66" id="r_acccd8c2750199cfb86c687417d5f7f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acccd8c2750199cfb86c687417d5f7f66">tipIndex</a> ()</td></tr>
<tr class="memdesc:acccd8c2750199cfb86c687417d5f7f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the tip index, i.e.  <br /></td></tr>
<tr class="memitem:a1bdfdf46f79cd44cd40b3066ef8bfc3d" id="r_a1bdfdf46f79cd44cd40b3066ef8bfc3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bdfdf46f79cd44cd40b3066ef8bfc3d">stemIndex</a> ()</td></tr>
<tr class="memdesc:a1bdfdf46f79cd44cd40b3066ef8bfc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the stem, i.e.  <br /></td></tr>
<tr class="memitem:a5d2752b19ae2ec79ee68816f2ad00166" id="r_a5d2752b19ae2ec79ee68816f2ad00166"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d2752b19ae2ec79ee68816f2ad00166">referenceSurface</a> () const</td></tr>
<tr class="memdesc:a5d2752b19ae2ec79ee68816f2ad00166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference surface of the track (e.g.  <br /></td></tr>
<tr class="memitem:a8d5163f0a52664a300eb5de163312624" id="r_a8d5163f0a52664a300eb5de163312624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d5163f0a52664a300eb5de163312624">setReferenceSurface</a> (std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt; srf)</td></tr>
<tr class="memdesc:a8d5163f0a52664a300eb5de163312624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new reference surface for this track.  <br /></td></tr>
<tr class="memitem:ad8653ee1cbb1df482757e676c19bddcd" id="r_ad8653ee1cbb1df482757e676c19bddcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8653ee1cbb1df482757e676c19bddcd">hasReferenceSurface</a> () const</td></tr>
<tr class="memdesc:ad8653ee1cbb1df482757e676c19bddcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the track has a reference surface or not.  <br /></td></tr>
<tr class="memitem:ad17d90489f76fa4e7340cdd219e2bd5e" id="r_ad17d90489f76fa4e7340cdd219e2bd5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac99d36ea3253a188c77863b2dcc1216c">ConstParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad17d90489f76fa4e7340cdd219e2bd5e">parameters</a> () const</td></tr>
<tr class="memdesc:ad17d90489f76fa4e7340cdd219e2bd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters of the track at the reference surface (e.g.  <br /></td></tr>
<tr class="memitem:a1fa116e3834ad52783b87a13f573a3bf" id="r_a1fa116e3834ad52783b87a13f573a3bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a658d133ca50acf18de523695c5d68f1d">ConstCovariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fa116e3834ad52783b87a13f573a3bf">covariance</a> () const</td></tr>
<tr class="memdesc:a1fa116e3834ad52783b87a13f573a3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the covariance of the track at the reference surface (e.g.  <br /></td></tr>
<tr class="memitem:a6082eedc813a17cbeab9b4417ead7402" id="r_a6082eedc813a17cbeab9b4417ead7402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a7e8c1a9321efd1d543fc582377558df7">Parameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6082eedc813a17cbeab9b4417ead7402">parameters</a> ()</td></tr>
<tr class="memdesc:a6082eedc813a17cbeab9b4417ead7402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parameters of the track at the reference surface (e.g.  <br /></td></tr>
<tr class="memitem:a180e8720d0f90c64336d2ee7bb7c29a6" id="r_a180e8720d0f90c64336d2ee7bb7c29a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1cf8f5adf5f851bacb83e9a8f2771891">Covariance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a180e8720d0f90c64336d2ee7bb7c29a6">covariance</a> ()</td></tr>
<tr class="memdesc:a180e8720d0f90c64336d2ee7bb7c29a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the covariance of the track at the reference surface (e.g.  <br /></td></tr>
<tr class="memitem:a09077e1b4c809350d3fd66013c292be8" id="r_a09077e1b4c809350d3fd66013c292be8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09077e1b4c809350d3fd66013c292be8">theta</a> () const</td></tr>
<tr class="memdesc:a09077e1b4c809350d3fd66013c292be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the theta parameter of the track at the reference surface.  <br /></td></tr>
<tr class="memitem:a5d5c13b7f6be4d962fc409e66f41ba3b" id="r_a5d5c13b7f6be4d962fc409e66f41ba3b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d5c13b7f6be4d962fc409e66f41ba3b">phi</a> () const</td></tr>
<tr class="memdesc:a5d5c13b7f6be4d962fc409e66f41ba3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the phi parameter of the track at the reference surface.  <br /></td></tr>
<tr class="memitem:a4afd2aca2239c2b080249a42ae6c3e8f" id="r_a4afd2aca2239c2b080249a42ae6c3e8f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4afd2aca2239c2b080249a42ae6c3e8f">loc0</a> () const</td></tr>
<tr class="memdesc:a4afd2aca2239c2b080249a42ae6c3e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the loc0 parameter of the track at the reference surface.  <br /></td></tr>
<tr class="memitem:a05a43c267b02678ac108930291fa1fbd" id="r_a05a43c267b02678ac108930291fa1fbd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05a43c267b02678ac108930291fa1fbd">loc1</a> () const</td></tr>
<tr class="memdesc:a05a43c267b02678ac108930291fa1fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the loc1 parameter of the track at the reference surface.  <br /></td></tr>
<tr class="memitem:a06b446f718c8263ed4d11f2dcaed2df4" id="r_a06b446f718c8263ed4d11f2dcaed2df4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06b446f718c8263ed4d11f2dcaed2df4">time</a> () const</td></tr>
<tr class="memdesc:a06b446f718c8263ed4d11f2dcaed2df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the time parameter of the track at the reference surface.  <br /></td></tr>
<tr class="memitem:ae8d700c5c318dc48b459af59d9f66378" id="r_ae8d700c5c318dc48b459af59d9f66378"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8d700c5c318dc48b459af59d9f66378">qOverP</a> () const</td></tr>
<tr class="memdesc:ae8d700c5c318dc48b459af59d9f66378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the q/p (curvature) parameter of the track at the reference surface.  <br /></td></tr>
<tr class="memitem:a26baa4d599c8f23a87c2264ba19dafcf" id="r_a26baa4d599c8f23a87c2264ba19dafcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26baa4d599c8f23a87c2264ba19dafcf">particleHypothesis</a> () const</td></tr>
<tr class="memdesc:a26baa4d599c8f23a87c2264ba19dafcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the particle hypothesis.  <br /></td></tr>
<tr class="memitem:a79732fb3f908c9a130a45b1f5bd601c2" id="r_a79732fb3f908c9a130a45b1f5bd601c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79732fb3f908c9a130a45b1f5bd601c2">setParticleHypothesis</a> (const <a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a> &amp;<a class="el" href="#a26baa4d599c8f23a87c2264ba19dafcf">particleHypothesis</a>)</td></tr>
<tr class="memdesc:a79732fb3f908c9a130a45b1f5bd601c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new particle hypothesis for this track.  <br /></td></tr>
<tr class="memitem:a6382c305862f4a0f5752b6b9c89ab4a6" id="r_a6382c305862f4a0f5752b6b9c89ab4a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6382c305862f4a0f5752b6b9c89ab4a6">charge</a> () const</td></tr>
<tr class="memdesc:a6382c305862f4a0f5752b6b9c89ab4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the charge of the tack.  <br /></td></tr>
<tr class="memitem:a8435be7e11e2b22e7fa928966d577677" id="r_a8435be7e11e2b22e7fa928966d577677"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8435be7e11e2b22e7fa928966d577677">absoluteMomentum</a> () const</td></tr>
<tr class="memdesc:a8435be7e11e2b22e7fa928966d577677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute momentum of the tack.  <br /></td></tr>
<tr class="memitem:a8e0e4252b5aef814d776acb6997dac1e" id="r_a8e0e4252b5aef814d776acb6997dac1e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0e4252b5aef814d776acb6997dac1e">transverseMomentum</a> () const</td></tr>
<tr class="memdesc:a8e0e4252b5aef814d776acb6997dac1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the transverse momentum of the track.  <br /></td></tr>
<tr class="memitem:ae7b72398e2c873decf0fa7a0cad2ac69" id="r_ae7b72398e2c873decf0fa7a0cad2ac69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7b72398e2c873decf0fa7a0cad2ac69">direction</a> () const</td></tr>
<tr class="memdesc:ae7b72398e2c873decf0fa7a0cad2ac69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a unit vector along the track direction at the reference surface.  <br /></td></tr>
<tr class="memitem:a667621746cedeb71a66f97c6a3a33166" id="r_a667621746cedeb71a66f97c6a3a33166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a667621746cedeb71a66f97c6a3a33166">momentum</a> () const</td></tr>
<tr class="memdesc:a667621746cedeb71a66f97c6a3a33166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global momentum vector.  <br /></td></tr>
<tr class="memitem:ac8d3e358c3cc28a8735f298d502b6c71" id="r_ac8d3e358c3cc28a8735f298d502b6c71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__algebra__types.html#ga3a320a58e0d6145e3f7ecf78c289dfd7">Vector4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8d3e358c3cc28a8735f298d502b6c71">fourMomentum</a> () const</td></tr>
<tr class="memdesc:ac8d3e358c3cc28a8735f298d502b6c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the four-momentum vector: (px, py, pz, e).  <br /></td></tr>
<tr class="memitem:ac5e38c1e9170703d670823d87d106b07" id="r_ac5e38c1e9170703d670823d87d106b07"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e38c1e9170703d670823d87d106b07">nTrackStates</a> () const</td></tr>
<tr class="memdesc:ac5e38c1e9170703d670823d87d106b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of track states associated to this track.  <br /></td></tr>
<tr class="memitem:a3e98384a05a1bf8621d391b83beca79e" id="r_a3e98384a05a1bf8621d391b83beca79e"><td class="memItemLeft" align="right" valign="top">unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e98384a05a1bf8621d391b83beca79e">nMeasurements</a> ()</td></tr>
<tr class="memdesc:a3e98384a05a1bf8621d391b83beca79e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the number of measurements for the track.  <br /></td></tr>
<tr class="memitem:aa0c1d303c229c76ca125827979991565" id="r_aa0c1d303c229c76ca125827979991565"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0c1d303c229c76ca125827979991565">nMeasurements</a> () const</td></tr>
<tr class="memdesc:aa0c1d303c229c76ca125827979991565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of measurements for the track.  <br /></td></tr>
<tr class="memitem:a96b0136175e46bc4852480dd46142a21" id="r_a96b0136175e46bc4852480dd46142a21"><td class="memItemLeft" align="right" valign="top">unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96b0136175e46bc4852480dd46142a21">nHoles</a> ()</td></tr>
<tr class="memdesc:a96b0136175e46bc4852480dd46142a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the number of holes for the track.  <br /></td></tr>
<tr class="memitem:a760a43a778f7ecf9ce89543d84cda39d" id="r_a760a43a778f7ecf9ce89543d84cda39d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a760a43a778f7ecf9ce89543d84cda39d">nHoles</a> () const</td></tr>
<tr class="memdesc:a760a43a778f7ecf9ce89543d84cda39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of measurements for the track.  <br /></td></tr>
<tr class="memitem:a480e5a7a09b4f0bee588968eb4a52a84" id="r_a480e5a7a09b4f0bee588968eb4a52a84"><td class="memItemLeft" align="right" valign="top">unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a480e5a7a09b4f0bee588968eb4a52a84">nOutliers</a> ()</td></tr>
<tr class="memdesc:a480e5a7a09b4f0bee588968eb4a52a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the number of outliers for the track.  <br /></td></tr>
<tr class="memitem:aac41b034569276aa97ad3d91eb74295b" id="r_aac41b034569276aa97ad3d91eb74295b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac41b034569276aa97ad3d91eb74295b">nOutliers</a> () const</td></tr>
<tr class="memdesc:aac41b034569276aa97ad3d91eb74295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of outliers for the track.  <br /></td></tr>
<tr class="memitem:ab7558d39f5db6b45a59758073cecb088" id="r_ab7558d39f5db6b45a59758073cecb088"><td class="memItemLeft" align="right" valign="top">unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7558d39f5db6b45a59758073cecb088">nSharedHits</a> ()</td></tr>
<tr class="memdesc:ab7558d39f5db6b45a59758073cecb088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the number of shared hits for the track.  <br /></td></tr>
<tr class="memitem:ab636268ae467714be713a3f9e7db2633" id="r_ab636268ae467714be713a3f9e7db2633"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab636268ae467714be713a3f9e7db2633">nSharedHits</a> () const</td></tr>
<tr class="memdesc:ab636268ae467714be713a3f9e7db2633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of shared hits for the track.  <br /></td></tr>
<tr class="memitem:a5cae055c4025a04353fbc081a62868cd" id="r_a5cae055c4025a04353fbc081a62868cd"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cae055c4025a04353fbc081a62868cd">chi2</a> ()</td></tr>
<tr class="memdesc:a5cae055c4025a04353fbc081a62868cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the chi squared Mutable version.  <br /></td></tr>
<tr class="memitem:a500af283b72a5d7cb4b6fc3e99d7e475" id="r_a500af283b72a5d7cb4b6fc3e99d7e475"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a500af283b72a5d7cb4b6fc3e99d7e475">chi2</a> () const</td></tr>
<tr class="memdesc:a500af283b72a5d7cb4b6fc3e99d7e475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the chi squared for the track.  <br /></td></tr>
<tr class="memitem:aad3c7a59a8f4f445a05f995dd2920bd8" id="r_aad3c7a59a8f4f445a05f995dd2920bd8"><td class="memItemLeft" align="right" valign="top">unsigned int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad3c7a59a8f4f445a05f995dd2920bd8">nDoF</a> ()</td></tr>
<tr class="memdesc:aad3c7a59a8f4f445a05f995dd2920bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable reference to the number of degrees of freedom for the track.  <br /></td></tr>
<tr class="memitem:aa14cc0c100c0db5a0a47843529817f2a" id="r_aa14cc0c100c0db5a0a47843529817f2a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa14cc0c100c0db5a0a47843529817f2a">nDoF</a> () const</td></tr>
<tr class="memdesc:aa14cc0c100c0db5a0a47843529817f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of degrees of freedom for the track.  <br /></td></tr>
<tr class="memitem:a256b925b3c7a19e890d889d0229fc327" id="r_a256b925b3c7a19e890d889d0229fc327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a256b925b3c7a19e890d889d0229fc327">index</a> () const</td></tr>
<tr class="memdesc:a256b925b3c7a19e890d889d0229fc327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of this track in the track container.  <br /></td></tr>
<tr id="pub-methods-2" class="groupHeader"><td colspan="2"><div class="groupHeader">TrackProxy track state access</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_proxy_track_states"></a> Methods that give access to the track states of a track represented by <code>TrackProxy</code>. </p>
</div></td></tr>
<tr class="memitem:af772eaafcca5a565f575bcfc6fecd217" id="r_af772eaafcca5a565f575bcfc6fecd217"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ac8d6b26852a5efa2e3365a2314ae65a1">ConstTrackStateProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af772eaafcca5a565f575bcfc6fecd217">outermostTrackState</a> () const</td></tr>
<tr class="memdesc:af772eaafcca5a565f575bcfc6fecd217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const track state proxy to the outermost track state.  <br /></td></tr>
<tr class="memitem:ae37c0b996cc268815dcdfaf88d0c8bf3" id="r_ae37c0b996cc268815dcdfaf88d0c8bf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5c1457f0d31400817d4204b6c60ec63e">TrackStateProxy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37c0b996cc268815dcdfaf88d0c8bf3">outermostTrackState</a> ()</td></tr>
<tr class="memdesc:ae37c0b996cc268815dcdfaf88d0c8bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable track state proxy to the outermost track state.  <br /></td></tr>
<tr class="memitem:a65ac57a6f3a555c919c8e7d3decff957" id="r_a65ac57a6f3a555c919c8e7d3decff957"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65ac57a6f3a555c919c8e7d3decff957">innermostTrackState</a> () const</td></tr>
<tr class="memdesc:a65ac57a6f3a555c919c8e7d3decff957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const track state proxy to the innermost track state.  <br /></td></tr>
<tr class="memitem:a2e91d88dda1467c62d1b8a7406f5247c" id="r_a2e91d88dda1467c62d1b8a7406f5247c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e91d88dda1467c62d1b8a7406f5247c">innermostTrackState</a> ()</td></tr>
<tr class="memdesc:a2e91d88dda1467c62d1b8a7406f5247c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mutable track state proxy to the innermost track state.  <br /></td></tr>
<tr class="memitem:a21b592cb22e3005dd443518e14e65ca8" id="r_a21b592cb22e3005dd443518e14e65ca8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21b592cb22e3005dd443518e14e65ca8">trackStatesReversed</a> () const</td></tr>
<tr class="memdesc:a21b592cb22e3005dd443518e14e65ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range over the track states of this track.  <br /></td></tr>
<tr class="memitem:a277a107ef3f64ed98293c179b2d35bd6" id="r_a277a107ef3f64ed98293c179b2d35bd6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277a107ef3f64ed98293c179b2d35bd6">trackStatesReversed</a> ()</td></tr>
<tr class="memdesc:a277a107ef3f64ed98293c179b2d35bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range over the track states of this track.  <br /></td></tr>
<tr class="memitem:a0620fcecb0bdc41cf443812178cb820e" id="r_a0620fcecb0bdc41cf443812178cb820e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0620fcecb0bdc41cf443812178cb820e">trackStates</a> () const</td></tr>
<tr class="memdesc:a0620fcecb0bdc41cf443812178cb820e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range over the track states of this track.  <br /></td></tr>
<tr class="memitem:a60ba80b44ead24411708cf84d8e82b19" id="r_a60ba80b44ead24411708cf84d8e82b19"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60ba80b44ead24411708cf84d8e82b19">trackStates</a> ()</td></tr>
<tr class="memdesc:a60ba80b44ead24411708cf84d8e82b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a range over the track states of this track.  <br /></td></tr>
<tr id="pub-methods-3" class="groupHeader"><td colspan="2"><div class="groupHeader">TrackProxy track state manipulation</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_proxy_track_state_manipulation"></a> Methods that manipulate the track states of a track represented by <code>TrackProxy</code>.</p>
<p><b>Copy Methods Overview:</b></p>
<p>Three main copy methods are available with different behaviors:</p><ul>
<li><code>copyFrom()</code>: Deep copy including all track states (creates new track states)</li>
<li><code>copyFromWithoutStates()</code>: Copy only track properties, invalidate track state indices</li>
<li><code>copyFromShallow()</code>: Shallow copy sharing the same track states (copy indices only)</li>
</ul>
<p>Choose based on your needs:</p><ul>
<li>Use <code>copyFrom()</code> for independent track copies with separate track states</li>
<li>Use <code>copyFromWithoutStates()</code> to update track metadata without affecting trajectories</li>
<li>Use <code>copyFromShallow()</code> for lightweight copies when track states can be shared </li>
</ul>
</div></td></tr>
<tr class="memitem:a3fa764ebfee2c55a8c5b55f45703c218" id="r_a3fa764ebfee2c55a8c5b55f45703c218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fa764ebfee2c55a8c5b55f45703c218">linkForward</a> ()</td></tr>
<tr class="memdesc:a3fa764ebfee2c55a8c5b55f45703c218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward connect a track.  <br /></td></tr>
<tr class="memitem:a3a8b447fe323dca41d95701ed50b6fda" id="r_a3a8b447fe323dca41d95701ed50b6fda"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a8b447fe323dca41d95701ed50b6fda">appendTrackState</a> (<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a> mask=<a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">TrackStatePropMask::All</a>)</td></tr>
<tr class="memdesc:a3a8b447fe323dca41d95701ed50b6fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a track state to this track.  <br /></td></tr>
<tr class="memitem:a793408c3dc8b7a8ad271ef0697c1d505" id="r_a793408c3dc8b7a8ad271ef0697c1d505"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</td></tr>
<tr class="memitem:a793408c3dc8b7a8ad271ef0697c1d505 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a793408c3dc8b7a8ad271ef0697c1d505">copyFrom</a> (const track_proxy_t &amp;other)</td></tr>
<tr class="memdesc:a793408c3dc8b7a8ad271ef0697c1d505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a complete deep copy of another track, including all track states.  <br /></td></tr>
<tr class="memitem:a2fcd0316fd805aab5fc5d99aa2716394" id="r_a2fcd0316fd805aab5fc5d99aa2716394"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</td></tr>
<tr class="memitem:a2fcd0316fd805aab5fc5d99aa2716394 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fcd0316fd805aab5fc5d99aa2716394">copyFromWithoutStates</a> (const track_proxy_t &amp;other)</td></tr>
<tr class="memdesc:a2fcd0316fd805aab5fc5d99aa2716394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy track-level properties from another track, but not the track states.  <br /></td></tr>
<tr class="memitem:a0f7131b2aa3036dfab53a5299695dce0" id="r_a0f7131b2aa3036dfab53a5299695dce0"><td class="memTemplParams" colspan="2">template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</td></tr>
<tr class="memitem:a0f7131b2aa3036dfab53a5299695dce0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f7131b2aa3036dfab53a5299695dce0">copyFromShallow</a> (const track_proxy_t &amp;other)</td></tr>
<tr class="memdesc:a0f7131b2aa3036dfab53a5299695dce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shallow copy from another track, sharing the same track states.  <br /></td></tr>
<tr class="memitem:a513c1a064775db25e7f6bdf8de92eac8" id="r_a513c1a064775db25e7f6bdf8de92eac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a513c1a064775db25e7f6bdf8de92eac8">reverseTrackStates</a> (bool invertJacobians=false)</td></tr>
<tr class="memdesc:a513c1a064775db25e7f6bdf8de92eac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the ordering of track states for this track Afterwards, the previous endpoint of the track state sequence will be the "innermost" track state.  <br /></td></tr>
<tr id="pub-methods-4" class="groupHeader"><td colspan="2"><div class="groupHeader">TrackProxy generic component access</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p><a class="anchor" id="track_proxy_generic_component"></a> Methods that give access to generic components of a track represented by <code>TrackProxy</code>.</p>
<p>Internally, a compile-time hash of the component name is used to identify which component is being requested. Most of the named methods in <a class="el" href="#track_proxy_props">TrackProxy properties</a> use these methods to retrieve the actual data.</p>
<p>A number of overloads exist, where you can either supply the <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> <code>key</code> as a template parameter or a runtime argument. The former has the advantage of being guaranteed to be evaluated at compile-time. </p>
</div></td></tr>
<tr class="memitem:a47b29d9988c9b0c3b7b86e44a1f5525e" id="r_a47b29d9988c9b0c3b7b86e44a1f5525e"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</td></tr>
<tr class="memitem:a47b29d9988c9b0c3b7b86e44a1f5525e template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47b29d9988c9b0c3b7b86e44a1f5525e">component</a> ()</td></tr>
<tr class="memdesc:a47b29d9988c9b0c3b7b86e44a1f5525e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:a661ea711b6021ace327ec7ea6e59992c" id="r_a661ea711b6021ace327ec7ea6e59992c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</td></tr>
<tr class="memitem:a661ea711b6021ace327ec7ea6e59992c template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a661ea711b6021ace327ec7ea6e59992c">component</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key)</td></tr>
<tr class="memdesc:a661ea711b6021ace327ec7ea6e59992c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:a776600cca145e2a8808750c2c89719b5" id="r_a776600cca145e2a8808750c2c89719b5"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</td></tr>
<tr class="memitem:a776600cca145e2a8808750c2c89719b5 template"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a776600cca145e2a8808750c2c89719b5">component</a> (std::string_view key)</td></tr>
<tr class="memdesc:a776600cca145e2a8808750c2c89719b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a mutable reference to a component.  <br /></td></tr>
<tr class="memitem:af6f42d498550a5569ff74e9c664622a8" id="r_af6f42d498550a5569ff74e9c664622a8"><td class="memTemplParams" colspan="2">template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </td></tr>
<tr class="memitem:af6f42d498550a5569ff74e9c664622a8 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6f42d498550a5569ff74e9c664622a8">component</a> () const</td></tr>
<tr class="memdesc:af6f42d498550a5569ff74e9c664622a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="memitem:a1cd4e66bc8072eb188df1e9ad94becc0" id="r_a1cd4e66bc8072eb188df1e9ad94becc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1cd4e66bc8072eb188df1e9ad94becc0">hasColumn</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:a1cd4e66bc8072eb188df1e9ad94becc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a dynamic column exists.  <br /></td></tr>
<tr class="memitem:a226feeb8413dc6304d3e93da1529a048" id="r_a226feeb8413dc6304d3e93da1529a048"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a226feeb8413dc6304d3e93da1529a048 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a226feeb8413dc6304d3e93da1529a048">component</a> (<a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key) const</td></tr>
<tr class="memdesc:a226feeb8413dc6304d3e93da1529a048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
<tr class="memitem:a35a3c818ceb208da411f86395ebb7d00" id="r_a35a3c818ceb208da411f86395ebb7d00"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a35a3c818ceb208da411f86395ebb7d00 template"><td class="memItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35a3c818ceb208da411f86395ebb7d00">component</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a35a3c818ceb208da411f86395ebb7d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to a component.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-attribs" class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4bd71bbbb663b7b2c52efcfc1df00ccf" id="r_a4bd71bbbb663b7b2c52efcfc1df00ccf"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4bd71bbbb663b7b2c52efcfc1df00ccf">kInvalid</a> = Container::kInvalid</td></tr>
<tr class="memdesc:a4bd71bbbb663b7b2c52efcfc1df00ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sentinel value that indicates an invalid index.  <br /></td></tr>
<tr class="memitem:a9842c1a3fb418179d94a69c77ac72fda" id="r_a9842c1a3fb418179d94a69c77ac72fda"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a> = read_only</td></tr>
<tr class="memdesc:a9842c1a3fb418179d94a69c77ac72fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this track proxy is read-only or if it can be modified.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt;<br />
class Acts::TrackProxy&lt; track_container_t, trajectory_t, holder_t, read_only &gt;</div><p>Proxy class representing a single track. </p>
<p>This class provides a <b>view</b> into an associated <a class="el" href="class_acts_1_1_track_container.html">TrackContainer</a>, and has <b>reference semantics</b>. You can think of it as a pointer to a vector of tracks, which exposes an object-oriented interface for accessing the track properties.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_container_t</td><td>the container backend </td></tr>
    <tr><td class="paramname">trajectory_t</td><td>the track state container backend </td></tr>
    <tr><td class="paramname">holder_t</td><td>ownership management class for the backend </td></tr>
    <tr><td class="paramname">read_only</td><td>true if this track container is not mutable </td></tr>
  </table>
  </dd>
</dl>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a658d133ca50acf18de523695c5d68f1d" name="a658d133ca50acf18de523695c5d68f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658d133ca50acf18de523695c5d68f1d">&#9670;&#160;</a></span>ConstCovariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::ConstCovariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> detail_lt::FixedSizeTypes&lt;eBoundSize, true&gt;::CovarianceMap</div>
</div><!-- fragment -->
<p>Same as <a class="el" href="#a1cf8f5adf5f851bacb83e9a8f2771891">Covariance</a>, but with const semantics. </p>

</div>
</div>
<a id="ac99d36ea3253a188c77863b2dcc1216c" name="ac99d36ea3253a188c77863b2dcc1216c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99d36ea3253a188c77863b2dcc1216c">&#9670;&#160;</a></span>ConstParameters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::ConstParameters</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> detail_lt::FixedSizeTypes&lt;eBoundSize, true&gt;::CoefficientsMap</div>
</div><!-- fragment -->
<p>Same as <a class="el" href="#a7e8c1a9321efd1d543fc582377558df7">Parameters</a>, but with const semantics. </p>

</div>
</div>
<a id="a5b030607cf1603fd3cf61f730ddf7dd7" name="a5b030607cf1603fd3cf61f730ddf7dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b030607cf1603fd3cf61f730ddf7dd7">&#9670;&#160;</a></span>ConstProxyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::ConstProxyType = <a class="el" href="#a20fe849b319215f22efcf54ff4766e9e">ConstTrackProxy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an associated const track proxy, with the same backends. </p>

</div>
</div>
<a id="a20fe849b319215f22efcf54ff4766e9e" name="a20fe849b319215f22efcf54ff4766e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fe849b319215f22efcf54ff4766e9e">&#9670;&#160;</a></span>ConstTrackProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::ConstTrackProxy</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <a class="code hl_function" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy&lt;track_container_t, trajectory_t, holder_t, true&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_track_proxy_html_ac1c227c580f1faa008376c71e349df37"><div class="ttname"><a href="#ac1c227c580f1faa008376c71e349df37">Acts::TrackProxy::TrackProxy</a></div><div class="ttdeci">TrackProxy(const TrackProxy &amp;other)=default</div><div class="ttdoc">Copy constructor: const to const or mutable to mutable.</div></div>
</div><!-- fragment -->
<p>Alias for the const version of this track proxy, with the same backends. </p>

</div>
</div>
<a id="ac8d6b26852a5efa2e3365a2314ae65a1" name="ac8d6b26852a5efa2e3365a2314ae65a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d6b26852a5efa2e3365a2314ae65a1">&#9670;&#160;</a></span>ConstTrackStateProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::ConstTrackStateProxy = typename Trajectory::ConstTrackStateProxy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an associated const track state proxy, with the same backends. </p>

</div>
</div>
<a id="ae288d68ecea172c537b59abad56826a2" name="ae288d68ecea172c537b59abad56826a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae288d68ecea172c537b59abad56826a2">&#9670;&#160;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::Container = track_container_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The track container backend given as a template parameter. </p>

</div>
</div>
<a id="a1cf8f5adf5f851bacb83e9a8f2771891" name="a1cf8f5adf5f851bacb83e9a8f2771891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf8f5adf5f851bacb83e9a8f2771891">&#9670;&#160;</a></span>Covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::Covariance</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> detail_lt::FixedSizeTypes&lt;eBoundSize, false&gt;::CovarianceMap</div>
</div><!-- fragment -->
<p>Map-type for a bound covariance. </p>
<p>This has reference semantics, i.e. points at a matrix by an internal pointer. </p>

</div>
</div>
<a id="a53fe18b4659a50f1ff7529423adfd93a" name="a53fe18b4659a50f1ff7529423adfd93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fe18b4659a50f1ff7529423adfd93a">&#9670;&#160;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::IndexType = typename Container::IndexType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index type of the track container. </p>

</div>
</div>
<a id="a00f56d433d15782817a75f9de53a0d14" name="a00f56d433d15782817a75f9de53a0d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f56d433d15782817a75f9de53a0d14">&#9670;&#160;</a></span>MutableTrackProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::MutableTrackProxy</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <a class="code hl_function" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy&lt;track_container_t, trajectory_t, holder_t, false&gt;</a></div>
</div><!-- fragment -->
<p>Alias for the mutable version of this track proxy, with the same backends. </p>

</div>
</div>
<a id="a7e8c1a9321efd1d543fc582377558df7" name="a7e8c1a9321efd1d543fc582377558df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8c1a9321efd1d543fc582377558df7">&#9670;&#160;</a></span>Parameters</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::Parameters</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">      <span class="keyword">typename</span> detail_lt::FixedSizeTypes&lt;eBoundSize, false&gt;::CoefficientsMap</div>
</div><!-- fragment -->
<p>Map-type for a bound parameter vector. </p>
<p>This has reference semantics, i.e. points at a matrix by an internal pointer. </p>

</div>
</div>
<a id="a5c1457f0d31400817d4204b6c60ec63e" name="a5c1457f0d31400817d4204b6c60ec63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1457f0d31400817d4204b6c60ec63e">&#9670;&#160;</a></span>TrackStateProxy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::TrackStateProxy = typename Trajectory::TrackStateProxy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for an associated mutable track state proxy, with the same backends. </p>

</div>
</div>
<a id="a472a9c319d8880a00057aa49b4450515" name="a472a9c319d8880a00057aa49b4450515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472a9c319d8880a00057aa49b4450515">&#9670;&#160;</a></span>Trajectory</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::Trajectory = trajectory_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The track state container backend given as a template parameter. </p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac1c227c580f1faa008376c71e349df37" name="ac1c227c580f1faa008376c71e349df37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c227c580f1faa008376c71e349df37">&#9670;&#160;</a></span>TrackProxy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::TrackProxy </td>
          <td>(</td>
          <td class="paramtype">const TrackProxy&lt; track_container_t, trajectory_t, holder_t, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor: const to const or mutable to mutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other track proxy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9567992d8cd81a438f16a7e66312f09" name="ab9567992d8cd81a438f16a7e66312f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9567992d8cd81a438f16a7e66312f09">&#9670;&#160;</a></span>TrackProxy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::TrackProxy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a00f56d433d15782817a75f9de53a0d14">MutableTrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from mutable track proxy. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other track proxy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8435be7e11e2b22e7fa928966d577677" name="a8435be7e11e2b22e7fa928966d577677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8435be7e11e2b22e7fa928966d577677">&#9670;&#160;</a></span>absoluteMomentum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::absoluteMomentum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute momentum of the tack. </p>
<dl class="section return"><dt>Returns</dt><dd>The absolute track momentum </dd></dl>

</div>
</div>
<a id="a3a8b447fe323dca41d95701ed50b6fda" name="a3a8b447fe323dca41d95701ed50b6fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8b447fe323dca41d95701ed50b6fda">&#9670;&#160;</a></span>appendTrackState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::appendTrackState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2">TrackStatePropMask</a></td>          <td class="paramname"><span class="paramname"><em>mask</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts.html#ac57de10a165c0a56408fd3de93e013e2ab1c94ca2fbc3e78fc30069c8d0f01680">TrackStatePropMask::All</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a track state to this track. </p>
<p>This will modify the tip index to point at the newly created track state, which will be directly after the previous track state at tip index. </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The allocation prop mask for the new track state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly added track state </dd></dl>

</div>
</div>
<a id="a6382c305862f4a0f5752b6b9c89ab4a6" name="a6382c305862f4a0f5752b6b9c89ab4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6382c305862f4a0f5752b6b9c89ab4a6">&#9670;&#160;</a></span>charge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::charge </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the charge of the tack. </p>
<dl class="section note"><dt>Note</dt><dd>this depends on the charge hypothesis </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The absolute track momentum </dd></dl>

</div>
</div>
<a id="a5cae055c4025a04353fbc081a62868cd" name="a5cae055c4025a04353fbc081a62868cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cae055c4025a04353fbc081a62868cd">&#9670;&#160;</a></span>chi2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::chi2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the chi squared Mutable version. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The chi squared </dd></dl>

</div>
</div>
<a id="a500af283b72a5d7cb4b6fc3e99d7e475" name="a500af283b72a5d7cb4b6fc3e99d7e475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500af283b72a5d7cb4b6fc3e99d7e475">&#9670;&#160;</a></span>chi2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::chi2 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the chi squared for the track. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The chi squared </dd></dl>

</div>
</div>
<a id="a47b29d9988c9b0c3b7b86e44a1f5525e" name="a47b29d9988c9b0c3b7b86e44a1f5525e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b29d9988c9b0c3b7b86e44a1f5525e">&#9670;&#160;</a></span>component() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="af6f42d498550a5569ff74e9c664622a8" name="af6f42d498550a5569ff74e9c664622a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f42d498550a5569ff74e9c664622a8">&#9670;&#160;</a></span>component() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T, <a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a> key&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a661ea711b6021ace327ec7ea6e59992c" name="a661ea711b6021ace327ec7ea6e59992c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661ea711b6021ace327ec7ea6e59992c">&#9670;&#160;</a></span>component() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a226feeb8413dc6304d3e93da1529a048" name="a226feeb8413dc6304d3e93da1529a048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226feeb8413dc6304d3e93da1529a048">&#9670;&#160;</a></span>component() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a776600cca145e2a8808750c2c89719b5" name="a776600cca145e2a8808750c2c89719b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776600cca145e2a8808750c2c89719b5">&#9670;&#160;</a></span>component() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a mutable reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Mutable reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a35a3c818ceb208da411f86395ebb7d00" name="a35a3c818ceb208da411f86395ebb7d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a3c818ceb208da411f86395ebb7d00">&#9670;&#160;</a></span>component() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::component </td>
          <td>(</td>
          <td class="paramtype">std::string_view</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to a component. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This might hash the <code class="param">key</code> at runtime instead of compile-time </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the component given by <code class="param">key</code> </dd></dl>

</div>
</div>
<a id="a21f27df670a69a25284a1c848db7c687" name="a21f27df670a69a25284a1c848db7c687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f27df670a69a25284a1c848db7c687">&#9670;&#160;</a></span>container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::container </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the track container backend, mutable version. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the track container backend </dd></dl>

</div>
</div>
<a id="a1244943cd9ac6543d92b677f5d971d52" name="a1244943cd9ac6543d92b677f5d971d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1244943cd9ac6543d92b677f5d971d52">&#9670;&#160;</a></span>container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::container </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the track container backend, const version. </p>
<dl class="section return"><dt>Returns</dt><dd>reference to the track container backend </dd></dl>

</div>
</div>
<a id="a793408c3dc8b7a8ad271ef0697c1d505" name="a793408c3dc8b7a8ad271ef0697c1d505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793408c3dc8b7a8ad271ef0697c1d505">&#9670;&#160;</a></span>copyFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a complete deep copy of another track, including all track states. </p>
<p>This creates new track states in the destination trajectory and copies all data from the source track states. The track state sequence order is preserved.</p>
<p><b>Implementation details:</b></p><ul>
<li>Track states are initially copied in reversed order for efficiency</li>
<li>The track state links are then updated using reverseTrackStates()</li>
<li>As a consequence, the resulting track is forward-linked</li>
</ul>
<p><b>What gets copied:</b></p><ul>
<li>All track-level properties (parameters, covariance, particle hypothesis, etc.)</li>
<li>Reference surface (shared pointer is copied)</li>
<li>Track summary data (nMeasurements, nHoles, chi2, etc.)</li>
<li>All dynamic track columns</li>
<li>Complete sequence of track states with all their data</li>
<li>All dynamic track state columns</li>
</ul>
<p><b>Result:</b></p><ul>
<li>The destination track will have newly created track states</li>
<li>tipIndex() and stemIndex() will point to the new track states</li>
<li>Track state indices will be different from the source</li>
<li>All track state data will be identical to the source</li>
<li>The track will be forward-linked (stemIndex() will be valid)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd>
<dd>
Both track containers must have compatible dynamic columns </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>the other track proxy's type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source track proxy to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f7131b2aa3036dfab53a5299695dce0" name="a0f7131b2aa3036dfab53a5299695dce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f7131b2aa3036dfab53a5299695dce0">&#9670;&#160;</a></span>copyFromShallow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::copyFromShallow </td>
          <td>(</td>
          <td class="paramtype">const track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shallow copy from another track, sharing the same track states. </p>
<p>This copies all track-level properties and makes the destination track point to the same track state sequence as the source. The track states themselves are not duplicated - both tracks will reference the same track state objects in memory.</p>
<p><b>What gets copied:</b></p><ul>
<li>All track-level properties (parameters, covariance, particle hypothesis, etc.)</li>
<li>Reference surface (shared pointer is copied)</li>
<li>Track summary data (nMeasurements, nHoles, chi2, etc.)</li>
<li>All dynamic track columns</li>
<li>tipIndex() and stemIndex() (track state linking information)</li>
</ul>
<p><b>What gets shared (not duplicated):</b></p><ul>
<li>Track states (both tracks reference the same track state objects)</li>
</ul>
<p><b>Result:</b></p><ul>
<li>The destination track will have the same nTrackStates() as the source</li>
<li>Both tracks will iterate over the same track state sequence</li>
<li>Modifications to track states will be visible in both tracks</li>
<li>Track state indices will be identical between tracks</li>
<li>The destination track will have a different track index than the source</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Modifying track states through either track will affect both tracks since they share the same track state objects </dd>
<dd>
It is the user's responsibility to ensure that the tip and stem indices from the source track are valid in the destination track's track state container. No validation is performed - invalid indices will lead to undefined behavior when accessing track states </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd>
<dd>
Both track containers must have compatible dynamic columns </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>the other track proxy's type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source track proxy to create a shallow copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fcd0316fd805aab5fc5d99aa2716394" name="a2fcd0316fd805aab5fc5d99aa2716394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fcd0316fd805aab5fc5d99aa2716394">&#9670;&#160;</a></span>copyFromWithoutStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<div class="memtemplate">
template&lt;TrackProxyConcept track_proxy_t&gt; <br />
requires (!<a class="el" href="#a9842c1a3fb418179d94a69c77ac72fda">ReadOnly</a>)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::copyFromWithoutStates </td>
          <td>(</td>
          <td class="paramtype">const track_proxy_t &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy track-level properties from another track, but not the track states. </p>
<p>This copies all track metadata and properties but leaves the track state sequence unchanged. Useful when you want to copy track properties to an existing track that may already have track states.</p>
<p><b>What gets copied:</b></p><ul>
<li>Track parameters at reference surface</li>
<li>Covariance matrix at reference surface</li>
<li>Particle hypothesis</li>
<li>Reference surface (shared pointer is copied)</li>
<li>Track summary data (nMeasurements, nHoles, nOutliers, nSharedHits, chi2, nDoF)</li>
<li>All dynamic track columns</li>
</ul>
<p><b>What does NOT get copied:</b></p><ul>
<li>Track states (existing track states remain unchanged in the container)</li>
</ul>
<p><b>Result:</b></p><ul>
<li>All track-level properties are updated to match the source</li>
<li>tipIndex() and stemIndex() are set to kInvalid (track states become inaccessible)</li>
<li>Existing track states remain in the container but are no longer linked to this track</li>
<li>nTrackStates() will return 0 due to invalid indices</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd>
<dd>
Both track containers must have compatible dynamic columns </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">track_proxy_t</td><td>the other track proxy's type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source track proxy to copy properties from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180e8720d0f90c64336d2ee7bb7c29a6" name="a180e8720d0f90c64336d2ee7bb7c29a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180e8720d0f90c64336d2ee7bb7c29a6">&#9670;&#160;</a></span>covariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1cf8f5adf5f851bacb83e9a8f2771891">Covariance</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::covariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the covariance of the track at the reference surface (e.g. </p>
<p>perigee). Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Proxy matrix for the covariance </dd></dl>

</div>
</div>
<a id="a1fa116e3834ad52783b87a13f573a3bf" name="a1fa116e3834ad52783b87a13f573a3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa116e3834ad52783b87a13f573a3bf">&#9670;&#160;</a></span>covariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a658d133ca50acf18de523695c5d68f1d">ConstCovariance</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::covariance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the covariance of the track at the reference surface (e.g. </p>
<p>perigee). Const version </p><dl class="section return"><dt>Returns</dt><dd>Proxy matrix for the covariance </dd></dl>

</div>
</div>
<a id="a3a15902f7e3d11de0b17eb9f3151a973" name="a3a15902f7e3d11de0b17eb9f3151a973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a15902f7e3d11de0b17eb9f3151a973">&#9670;&#160;</a></span>createParametersAtReference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::createParametersAtReference </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the track parameters at the reference surface. </p>
<dl class="section note"><dt>Note</dt><dd>The parameters are created on the fly </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the track parameters </dd></dl>

</div>
</div>
<a id="a6564a71452cccc25478e8b0f19f9d99c" name="a6564a71452cccc25478e8b0f19f9d99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6564a71452cccc25478e8b0f19f9d99c">&#9670;&#160;</a></span>createParametersFromState()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_acts.html#ad836aba005ba272c0a77227311e4a0ce">BoundTrackParameters</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::createParametersFromState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac8d6b26852a5efa2e3365a2314ae65a1">ConstTrackStateProxy</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>trackState</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a track state into track parameters. </p>
<dl class="section note"><dt>Note</dt><dd>The parameters are created on the fly </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trackState</td><td>Track state to convert to parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the track parameters </dd></dl>

</div>
</div>
<a id="ae7b72398e2c873decf0fa7a0cad2ac69" name="ae7b72398e2c873decf0fa7a0cad2ac69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b72398e2c873decf0fa7a0cad2ac69">&#9670;&#160;</a></span>direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::direction </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a unit vector along the track direction at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The direction unit vector </dd></dl>

</div>
</div>
<a id="ac8d3e358c3cc28a8735f298d502b6c71" name="ac8d3e358c3cc28a8735f298d502b6c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d3e358c3cc28a8735f298d502b6c71">&#9670;&#160;</a></span>fourMomentum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga3a320a58e0d6145e3f7ecf78c289dfd7">Vector4</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::fourMomentum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the four-momentum vector: (px, py, pz, e). </p>
<dl class="section return"><dt>Returns</dt><dd>the four-momentum vector </dd></dl>

</div>
</div>
<a id="a1cd4e66bc8072eb188df1e9ad94becc0" name="a1cd4e66bc8072eb188df1e9ad94becc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd4e66bc8072eb188df1e9ad94becc0">&#9670;&#160;</a></span>hasColumn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::hasColumn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_acts.html#a316aaac27fda3651c80ea8dfba83492a">HashedString</a></td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a dynamic column exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>String key for the component to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the column exists </dd></dl>

</div>
</div>
<a id="ad8653ee1cbb1df482757e676c19bddcd" name="ad8653ee1cbb1df482757e676c19bddcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8653ee1cbb1df482757e676c19bddcd">&#9670;&#160;</a></span>hasReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::hasReferenceSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the track has a reference surface or not. </p>
<dl class="section return"><dt>Returns</dt><dd>whether a surface exists or not </dd></dl>

</div>
</div>
<a id="a256b925b3c7a19e890d889d0229fc327" name="a256b925b3c7a19e890d889d0229fc327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256b925b3c7a19e890d889d0229fc327">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of this track in the track container. </p>
<dl class="section note"><dt>Note</dt><dd>This is separate from the tip index </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the track index </dd></dl>

</div>
</div>
<a id="a2e91d88dda1467c62d1b8a7406f5247c" name="a2e91d88dda1467c62d1b8a7406f5247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e91d88dda1467c62d1b8a7406f5247c">&#9670;&#160;</a></span>innermostTrackState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::innermostTrackState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable track state proxy to the innermost track state. </p>
<dl class="section note"><dt>Note</dt><dd>This is only available, if the track is forward linked </dd>
<dd>
Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The innermost track state proxy </dd></dl>

</div>
</div>
<a id="a65ac57a6f3a555c919c8e7d3decff957" name="a65ac57a6f3a555c919c8e7d3decff957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac57a6f3a555c919c8e7d3decff957">&#9670;&#160;</a></span>innermostTrackState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::innermostTrackState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const track state proxy to the innermost track state. </p>
<dl class="section note"><dt>Note</dt><dd>This is only available, if the track is forward linked </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The innermost track state proxy </dd></dl>

</div>
</div>
<a id="a3fa764ebfee2c55a8c5b55f45703c218" name="a3fa764ebfee2c55a8c5b55f45703c218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa764ebfee2c55a8c5b55f45703c218">&#9670;&#160;</a></span>linkForward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::linkForward </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward connect a track. </p>
<p>This means setting indices from the inside out on all track states. </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>

</div>
</div>
<a id="a4afd2aca2239c2b080249a42ae6c3e8f" name="a4afd2aca2239c2b080249a42ae6c3e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afd2aca2239c2b080249a42ae6c3e8f">&#9670;&#160;</a></span>loc0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::loc0 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the loc0 parameter of the track at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The loc0 parameter </dd></dl>

</div>
</div>
<a id="a05a43c267b02678ac108930291fa1fbd" name="a05a43c267b02678ac108930291fa1fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a43c267b02678ac108930291fa1fbd">&#9670;&#160;</a></span>loc1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::loc1 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the loc1 parameter of the track at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The loc1 parameter </dd></dl>

</div>
</div>
<a id="a667621746cedeb71a66f97c6a3a33166" name="a667621746cedeb71a66f97c6a3a33166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667621746cedeb71a66f97c6a3a33166">&#9670;&#160;</a></span>momentum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__algebra__types.html#ga8183a99dab8a7c6fff67d7c6c05bfb22">Vector3</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::momentum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the global momentum vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the global momentum vector </dd></dl>

</div>
</div>
<a id="aad3c7a59a8f4f445a05f995dd2920bd8" name="aad3c7a59a8f4f445a05f995dd2920bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3c7a59a8f4f445a05f995dd2920bd8">&#9670;&#160;</a></span>nDoF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nDoF </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the number of degrees of freedom for the track. </p>
<p>Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of degrees of freedom </dd></dl>

</div>
</div>
<a id="aa14cc0c100c0db5a0a47843529817f2a" name="aa14cc0c100c0db5a0a47843529817f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14cc0c100c0db5a0a47843529817f2a">&#9670;&#160;</a></span>nDoF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nDoF </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of degrees of freedom for the track. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The number of degrees of freedom </dd></dl>

</div>
</div>
<a id="a96b0136175e46bc4852480dd46142a21" name="a96b0136175e46bc4852480dd46142a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b0136175e46bc4852480dd46142a21">&#9670;&#160;</a></span>nHoles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nHoles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the number of holes for the track. </p>
<p>Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of holes </dd></dl>

</div>
</div>
<a id="a760a43a778f7ecf9ce89543d84cda39d" name="a760a43a778f7ecf9ce89543d84cda39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760a43a778f7ecf9ce89543d84cda39d">&#9670;&#160;</a></span>nHoles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nHoles </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of measurements for the track. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The number of measurements </dd></dl>

</div>
</div>
<a id="a3e98384a05a1bf8621d391b83beca79e" name="a3e98384a05a1bf8621d391b83beca79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e98384a05a1bf8621d391b83beca79e">&#9670;&#160;</a></span>nMeasurements() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nMeasurements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the number of measurements for the track. </p>
<p>Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of measurements </dd></dl>

</div>
</div>
<a id="aa0c1d303c229c76ca125827979991565" name="aa0c1d303c229c76ca125827979991565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1d303c229c76ca125827979991565">&#9670;&#160;</a></span>nMeasurements() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nMeasurements </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of measurements for the track. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The number of measurements </dd></dl>

</div>
</div>
<a id="a480e5a7a09b4f0bee588968eb4a52a84" name="a480e5a7a09b4f0bee588968eb4a52a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480e5a7a09b4f0bee588968eb4a52a84">&#9670;&#160;</a></span>nOutliers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nOutliers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the number of outliers for the track. </p>
<p>Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of outliers </dd></dl>

</div>
</div>
<a id="aac41b034569276aa97ad3d91eb74295b" name="aac41b034569276aa97ad3d91eb74295b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac41b034569276aa97ad3d91eb74295b">&#9670;&#160;</a></span>nOutliers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nOutliers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of outliers for the track. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The number of outliers </dd></dl>

</div>
</div>
<a id="ab7558d39f5db6b45a59758073cecb088" name="ab7558d39f5db6b45a59758073cecb088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7558d39f5db6b45a59758073cecb088">&#9670;&#160;</a></span>nSharedHits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nSharedHits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable reference to the number of shared hits for the track. </p>
<p>Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of shared hits </dd></dl>

</div>
</div>
<a id="ab636268ae467714be713a3f9e7db2633" name="ab636268ae467714be713a3f9e7db2633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab636268ae467714be713a3f9e7db2633">&#9670;&#160;</a></span>nSharedHits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nSharedHits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of shared hits for the track. </p>
<p>Const version </p><dl class="section return"><dt>Returns</dt><dd>The number of shared hits </dd></dl>

</div>
</div>
<a id="ac5e38c1e9170703d670823d87d106b07" name="ac5e38c1e9170703d670823d87d106b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e38c1e9170703d670823d87d106b07">&#9670;&#160;</a></span>nTrackStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::nTrackStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of track states associated to this track. </p>
<dl class="section note"><dt>Note</dt><dd>This is calculated by iterating over the track states which is somewhat expensive. Consider caching this value if you need It more than once. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of track states </dd></dl>

</div>
</div>
<a id="aaafee755fec1e0bf4016d56bab900b06" name="aaafee755fec1e0bf4016d56bab900b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafee755fec1e0bf4016d56bab900b06">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a00f56d433d15782817a75f9de53a0d14">MutableTrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator from mutable track proxy. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other track proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this track proxy </dd></dl>

</div>
</div>
<a id="ac15d5edb3f464ad4faf7a1e4d86f1810" name="ac15d5edb3f464ad4faf7a1e4d86f1810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15d5edb3f464ad4faf7a1e4d86f1810">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a> &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator: const to const or mutable to mutable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other track proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to this track proxy </dd></dl>

</div>
</div>
<a id="a89e6800cf06b95cdc7e7de2b3abe0bb5" name="a89e6800cf06b95cdc7e7de2b3abe0bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e6800cf06b95cdc7e7de2b3abe0bb5">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ac1c227c580f1faa008376c71e349df37">TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality operator with another track proxy Checks the container identity and the track index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Other track proxy to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the track proxies refer to the same track </dd></dl>

</div>
</div>
<a id="ae37c0b996cc268815dcdfaf88d0c8bf3" name="ae37c0b996cc268815dcdfaf88d0c8bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c0b996cc268815dcdfaf88d0c8bf3">&#9670;&#160;</a></span>outermostTrackState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5c1457f0d31400817d4204b6c60ec63e">TrackStateProxy</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::outermostTrackState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mutable track state proxy to the outermost track state. </p>
<dl class="section return"><dt>Returns</dt><dd>The outermost track state proxy </dd></dl>

</div>
</div>
<a id="af772eaafcca5a565f575bcfc6fecd217" name="af772eaafcca5a565f575bcfc6fecd217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af772eaafcca5a565f575bcfc6fecd217">&#9670;&#160;</a></span>outermostTrackState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac8d6b26852a5efa2e3365a2314ae65a1">ConstTrackStateProxy</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::outermostTrackState </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const track state proxy to the outermost track state. </p>
<dl class="section return"><dt>Returns</dt><dd>The outermost track state proxy </dd></dl>

</div>
</div>
<a id="a6082eedc813a17cbeab9b4417ead7402" name="a6082eedc813a17cbeab9b4417ead7402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6082eedc813a17cbeab9b4417ead7402">&#9670;&#160;</a></span>parameters() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a7e8c1a9321efd1d543fc582377558df7">Parameters</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::parameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameters of the track at the reference surface (e.g. </p>
<p>perigee). Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Proxy vector for the parameters </dd></dl>

</div>
</div>
<a id="ad17d90489f76fa4e7340cdd219e2bd5e" name="ad17d90489f76fa4e7340cdd219e2bd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17d90489f76fa4e7340cdd219e2bd5e">&#9670;&#160;</a></span>parameters() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ac99d36ea3253a188c77863b2dcc1216c">ConstParameters</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::parameters </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parameters of the track at the reference surface (e.g. </p>
<p>perigee). Const version </p><dl class="section return"><dt>Returns</dt><dd>Proxy vector for the parameters </dd></dl>

</div>
</div>
<a id="a26baa4d599c8f23a87c2264ba19dafcf" name="a26baa4d599c8f23a87c2264ba19dafcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26baa4d599c8f23a87c2264ba19dafcf">&#9670;&#160;</a></span>particleHypothesis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::particleHypothesis </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the particle hypothesis. </p>
<dl class="section return"><dt>Returns</dt><dd>the particle hypothesis </dd></dl>

</div>
</div>
<a id="a5d5c13b7f6be4d962fc409e66f41ba3b" name="a5d5c13b7f6be4d962fc409e66f41ba3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5c13b7f6be4d962fc409e66f41ba3b">&#9670;&#160;</a></span>phi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::phi </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the phi parameter of the track at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The phi parameter </dd></dl>

</div>
</div>
<a id="ae8d700c5c318dc48b459af59d9f66378" name="ae8d700c5c318dc48b459af59d9f66378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d700c5c318dc48b459af59d9f66378">&#9670;&#160;</a></span>qOverP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::qOverP </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the q/p (curvature) parameter of the track at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The q/p parameter </dd></dl>

</div>
</div>
<a id="a5d2752b19ae2ec79ee68816f2ad00166" name="a5d2752b19ae2ec79ee68816f2ad00166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2752b19ae2ec79ee68816f2ad00166">&#9670;&#160;</a></span>referenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::referenceSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reference surface of the track (e.g. </p>
<p>the perigee) </p><dl class="section return"><dt>Returns</dt><dd>the reference surface </dd></dl>

</div>
</div>
<a id="a513c1a064775db25e7f6bdf8de92eac8" name="a513c1a064775db25e7f6bdf8de92eac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513c1a064775db25e7f6bdf8de92eac8">&#9670;&#160;</a></span>reverseTrackStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::reverseTrackStates </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invertJacobians</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the ordering of track states for this track Afterwards, the previous endpoint of the track state sequence will be the "innermost" track state. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd>
<dd>
This is dangerous with branching track state sequences, as it will break them </dd>
<dd>
This also automatically forward-links the track! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invertJacobians</td><td>Whether to invert the Jacobians of the track states </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79732fb3f908c9a130a45b1f5bd601c2" name="a79732fb3f908c9a130a45b1f5bd601c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79732fb3f908c9a130a45b1f5bd601c2">&#9670;&#160;</a></span>setParticleHypothesis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::setParticleHypothesis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_acts_1_1_particle_hypothesis.html">ParticleHypothesis</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>particleHypothesis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new particle hypothesis for this track. </p>
<dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">particleHypothesis</td><td>The particle hypothesis to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d5163f0a52664a300eb5de163312624" name="a8d5163f0a52664a300eb5de163312624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5163f0a52664a300eb5de163312624">&#9670;&#160;</a></span>setReferenceSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::setReferenceSurface </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="class_acts_1_1_surface.html">Surface</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>srf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a new reference surface for this track. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srf</td><td>The surface to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bdfdf46f79cd44cd40b3066ef8bfc3d" name="a1bdfdf46f79cd44cd40b3066ef8bfc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdfdf46f79cd44cd40b3066ef8bfc3d">&#9670;&#160;</a></span>stemIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::stemIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the stem, i.e. </p>
<p>the innermost track state of the track. This might be invalid, signifying that the track state is not forward-linked. </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>mutable reference to the stem index </dd></dl>

</div>
</div>
<a id="ac0ee0f6dabaa02110a59e22cc57bba12" name="ac0ee0f6dabaa02110a59e22cc57bba12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ee0f6dabaa02110a59e22cc57bba12">&#9670;&#160;</a></span>stemIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::stemIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the stem, i.e. </p>
<p>the innermost track state of the track. This might be invalid, signifying that the track state is not forward-linked. </p><dl class="section return"><dt>Returns</dt><dd>the stem index </dd></dl>

</div>
</div>
<a id="a09077e1b4c809350d3fd66013c292be8" name="a09077e1b4c809350d3fd66013c292be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09077e1b4c809350d3fd66013c292be8">&#9670;&#160;</a></span>theta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::theta </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the theta parameter of the track at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The theta parameter </dd></dl>

</div>
</div>
<a id="a06b446f718c8263ed4d11f2dcaed2df4" name="a06b446f718c8263ed4d11f2dcaed2df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b446f718c8263ed4d11f2dcaed2df4">&#9670;&#160;</a></span>time()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::time </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the time parameter of the track at the reference surface. </p>
<dl class="section return"><dt>Returns</dt><dd>The time parameter </dd></dl>

</div>
</div>
<a id="acccd8c2750199cfb86c687417d5f7f66" name="acccd8c2750199cfb86c687417d5f7f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acccd8c2750199cfb86c687417d5f7f66">&#9670;&#160;</a></span>tipIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> &amp; <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::tipIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a mutable reference to the tip index, i.e. </p>
<p>the entry point into the track container </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>mutable reference to the tip index </dd></dl>

</div>
</div>
<a id="a25e0a66cbacf16a864fac81b954f6971" name="a25e0a66cbacf16a864fac81b954f6971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e0a66cbacf16a864fac81b954f6971">&#9670;&#160;</a></span>tipIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::tipIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tip index, i.e. </p>
<p>the entry point into the track state container </p><dl class="section return"><dt>Returns</dt><dd>the tip index by value </dd></dl>

</div>
</div>
<a id="a60ba80b44ead24411708cf84d8e82b19" name="a60ba80b44ead24411708cf84d8e82b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ba80b44ead24411708cf84d8e82b19">&#9670;&#160;</a></span>trackStates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::trackStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a range over the track states of this track. </p>
<p>Return value is compatible with range based for loop. This overload returns a mutable track state range, which means you can modify the track states obtained in the iteration. </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd>
<dd>
This range is from the inside out! </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This access direction is only possible if the track states are <b>forward-linked</b>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Track state range to iterate over </dd></dl>

</div>
</div>
<a id="a0620fcecb0bdc41cf443812178cb820e" name="a0620fcecb0bdc41cf443812178cb820e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0620fcecb0bdc41cf443812178cb820e">&#9670;&#160;</a></span>trackStates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::trackStates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a range over the track states of this track. </p>
<p>Return value is compatible with range based for loop. This overload returns a const-only track state range, which means you cannot modify the track states obtained in the iteration. </p><dl class="section note"><dt>Note</dt><dd>This range is from the inside out! </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This access direction is only possible if the track states are <b>forward-linked</b>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Track state range to iterate over </dd></dl>

</div>
</div>
<a id="a277a107ef3f64ed98293c179b2d35bd6" name="a277a107ef3f64ed98293c179b2d35bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277a107ef3f64ed98293c179b2d35bd6">&#9670;&#160;</a></span>trackStatesReversed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::trackStatesReversed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a range over the track states of this track. </p>
<p>Return value is compatible with range based for loop. Mutable version </p><dl class="section note"><dt>Note</dt><dd>Only available if the track proxy is not read-only </dd>
<dd>
This range is from the outside inwards! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Track state range to iterate over </dd></dl>

</div>
</div>
<a id="a21b592cb22e3005dd443518e14e65ca8" name="a21b592cb22e3005dd443518e14e65ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b592cb22e3005dd443518e14e65ca8">&#9670;&#160;</a></span>trackStatesReversed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::trackStatesReversed </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a range over the track states of this track. </p>
<p>Return value is compatible with range based for loop. Const version </p><dl class="section note"><dt>Note</dt><dd>This range is from the outside inwards! </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Track state range to iterate over </dd></dl>

</div>
</div>
<a id="a8e0e4252b5aef814d776acb6997dac1e" name="a8e0e4252b5aef814d776acb6997dac1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0e4252b5aef814d776acb6997dac1e">&#9670;&#160;</a></span>transverseMomentum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::transverseMomentum </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the transverse momentum of the track. </p>
<dl class="section return"><dt>Returns</dt><dd>The track transverse momentum value </dd></dl>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a4bd71bbbb663b7b2c52efcfc1df00ccf" name="a4bd71bbbb663b7b2c52efcfc1df00ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd71bbbb663b7b2c52efcfc1df00ccf">&#9670;&#160;</a></span>kInvalid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a53fe18b4659a50f1ff7529423adfd93a">IndexType</a> <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::kInvalid = Container::kInvalid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sentinel value that indicates an invalid index. </p>

</div>
</div>
<a id="a9842c1a3fb418179d94a69c77ac72fda" name="a9842c1a3fb418179d94a69c77ac72fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9842c1a3fb418179d94a69c77ac72fda">&#9670;&#160;</a></span>ReadOnly</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename track_container_t, typename trajectory_t, template&lt; typename &gt; class holder_t, bool read_only = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_acts_1_1_track_proxy.html">Acts::TrackProxy</a>&lt; track_container_t, trajectory_t, holder_t, read_only &gt;::ReadOnly = read_only</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this track proxy is read-only or if it can be modified. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_acts.html">Acts</a></li><li class="navelem"><a href="class_acts_1_1_track_proxy.html">TrackProxy</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
