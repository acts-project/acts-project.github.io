<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTS: Material</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script>
MathJax = {
  tex: {
    inlineMath: {'[+]': [['$', '$']]}
  },
};
</script>
<script id="MathJax-script" async src="tex-mml-chtml.js"></script>
<!-- <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
 -->
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<!-- ACTS Version Manager -->
<link href="acts-version-manager.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="acts-version-manager.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="acts_logo_colored.svg"/></td>
  <td id="projectalign">
   <div id="projectname">ACTS
   </div>
   <div id="projectbrief">Experiment-independent tracking</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__material.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Material <div class="ingroups"><a class="el" href="group__detector__descr.html">Detector Description</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Detector material description and handling. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-groups" class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:material_5Fmapping" id="r_material_5Fmapping"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__material__mapping.html">Material mapping </a></td></tr>
<tr class="memdesc:group__material__mapping"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection procedure to derive mapped material properties. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Acts_3A_3AAtlasBetheHeitlerApprox" id="r_Acts_3A_3AAtlasBetheHeitlerApprox"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">Acts::AtlasBetheHeitlerApprox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class approximates the Bethe-Heitler distribution as a gaussian mixture.  <a href="class_acts_1_1_atlas_bethe_heitler_approx.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3ABetheHeitlerApprox" id="r_Acts_3A_3ABetheHeitlerApprox"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_bethe_heitler_approx.html">Acts::BetheHeitlerApprox</a></td></tr>
<tr class="memitem:Acts_3A_3ABetheHeitlerApproxSingleCmp" id="r_Acts_3A_3ABetheHeitlerApproxSingleCmp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_bethe_heitler_approx_single_cmp.html">Acts::BetheHeitlerApproxSingleCmp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class approximates the Bethe-Heitler with only one component.  <a href="class_acts_1_1_bethe_heitler_approx_single_cmp.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3ABinnedSurfaceMaterial" id="r_Acts_3A_3ABinnedSurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_binned_surface_material.html">Acts::BinnedSurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It extends the <a class="el" href="class_acts_1_1_i_surface_material.html">ISurfaceMaterial</a> base class and is an array pf MaterialSlab.  <a href="class_acts_1_1_binned_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AElementFraction" id="r_Acts_3A_3AElementFraction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_element_fraction.html">Acts::ElementFraction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-efficient storage of the relative fraction of an element.  <a href="class_acts_1_1_element_fraction.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AGloballyIndexedMaterialAccessor" id="r_Acts_3A_3AGloballyIndexedMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_globally_indexed_material_accessor.html">Acts::GloballyIndexedMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor for cases where the material is filled in a global material vector that is accessed from the different material grids.  <a href="struct_acts_1_1_globally_indexed_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AGridMaterialAccessor" id="r_Acts_3A_3AGridMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_grid_material_accessor.html">Acts::GridMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor for cases where the material is directly stored in the grid, it simply forwards the grid entry in const and non-const way.  <a href="struct_acts_1_1_grid_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AGridSurfaceMaterialT_3C_20grid_5Ft_2C_20material_5Faccessor_5Ft_20_3E" id="r_Acts_3A_3AGridSurfaceMaterialT_3C_20grid_5Ft_2C_20material_5Faccessor_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_grid_surface_material_t.html">Acts::GridSurfaceMaterialT&lt; grid_t, material_accessor_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GridSurfaceMaterialT.  <a href="class_acts_1_1_grid_surface_material_t.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AHomogeneousSurfaceMaterial" id="r_Acts_3A_3AHomogeneousSurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_homogeneous_surface_material.html">Acts::HomogeneousSurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It extends the ISurfaceMaterial virtual base class to describe a simple homogeneous material on a surface.  <a href="class_acts_1_1_homogeneous_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AHomogeneousVolumeMaterial" id="r_Acts_3A_3AHomogeneousVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_homogeneous_volume_material.html">Acts::HomogeneousVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">It extends the IVolumeMaterial base class to describe a simple homogeneous material in a volume.  <a href="class_acts_1_1_homogeneous_volume_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AIGridMaterialAccessor" id="r_Acts_3A_3AIGridMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_i_grid_material_accessor.html">Acts::IGridMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for material accessors, this is needed for the I/O of the different grid material types, in the actual implementation the material accessor is a template parameter.  <a href="struct_acts_1_1_i_grid_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AIGridSurfaceMaterial_3C_20grid_5Fvalue_5Ft_20_3E" id="r_Acts_3A_3AIGridSurfaceMaterial_3C_20grid_5Fvalue_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_grid_surface_material.html">Acts::IGridSurfaceMaterial&lt; grid_value_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate interface to the grid surface material given access to the grid and the material accessor.  <a href="class_acts_1_1_i_grid_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AIGridSurfaceMaterialBase" id="r_Acts_3A_3AIGridSurfaceMaterialBase"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_grid_surface_material_base.html">Acts::IGridSurfaceMaterialBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the concrete templated grid surface material types.  <a href="class_acts_1_1_i_grid_surface_material_base.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AIMaterialDecorator" id="r_Acts_3A_3AIMaterialDecorator"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_material_decorator.html">Acts::IMaterialDecorator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for decorators that allow to load material onto a TrackingGeometry.  <a href="class_acts_1_1_i_material_decorator.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AIndexedMaterialAccessor" id="r_Acts_3A_3AIndexedMaterialAccessor"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_indexed_material_accessor.html">Acts::IndexedMaterialAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an accessor for cases where the material is filled in a vector and then indexed by the grid.  <a href="struct_acts_1_1_indexed_material_accessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AInteractionVolume" id="r_Acts_3A_3AInteractionVolume"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_interaction_volume.html">Acts::InteractionVolume</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Material interaction volume struct.  <a href="struct_acts_1_1_interaction_volume.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AInterpolatedMaterialMap_3C_20Mapper_5Ft_20_3E" id="r_Acts_3A_3AInterpolatedMaterialMap_3C_20Mapper_5Ft_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_interpolated_material_map.html">Acts::InterpolatedMaterialMap&lt; Mapper_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate material classification values from material values on a given grid.  <a href="class_acts_1_1_interpolated_material_map.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AISurfaceMaterial" id="r_Acts_3A_3AISurfaceMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_surface_material.html">Acts::ISurfaceMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all surface-based material description.  <a href="class_acts_1_1_i_surface_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AIVolumeMaterial" id="r_Acts_3A_3AIVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_i_volume_material.html">Acts::IVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material associated with a Volume (homogeneous, binned, interpolated).  <a href="class_acts_1_1_i_volume_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AMaterial" id="r_Acts_3A_3AMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material.html">Acts::Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material description for interactions with matter.  <a href="class_acts_1_1_material.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AMaterialMapLookup_3C_20G_20_3E" id="r_Acts_3A_3AMaterialMapLookup_3C_20G_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_acts_1_1_material_map_lookup.html">Acts::MaterialMapLookup&lt; G &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for mapping global 3D positions to material values.  <a href="struct_acts_1_1_material_map_lookup.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AMaterialSlab" id="r_Acts_3A_3AMaterialSlab"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_material_slab.html">Acts::MaterialSlab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material description for an object with defined thickness.  <a href="class_acts_1_1_material_slab.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AProtoSurfaceMaterialT_3C_20BinningType_20_3E" id="r_Acts_3A_3AProtoSurfaceMaterialT_3C_20BinningType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_proto_surface_material_t.html">Acts::ProtoSurfaceMaterialT&lt; BinningType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">proxy to SurfaceMaterial hand over BinUtility or other suitable binning description  <a href="class_acts_1_1_proto_surface_material_t.html#details">More...</a><br /></td></tr>
<tr class="memitem:Acts_3A_3AProtoVolumeMaterial" id="r_Acts_3A_3AProtoVolumeMaterial"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_acts_1_1_proto_volume_material.html">Acts::ProtoVolumeMaterial</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">proxy to VolumeMaterial hand over BinUtility  <a href="class_acts_1_1_proto_volume_material.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac15aff2ad0a7029a89bd903885de3310" id="r_gac15aff2ad0a7029a89bd903885de3310"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:gac15aff2ad0a7029a89bd903885de3310 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac15aff2ad0a7029a89bd903885de3310">Acts::GloballyIndexedSurfaceMaterial</a></td></tr>
<tr class="memdesc:gac15aff2ad0a7029a89bd903885de3310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for surface material indexed by global coordinates.  <br /></td></tr>
<tr class="memitem:ga7f7ecaeb7a0b9e040e5de04892a1e1eb" id="r_ga7f7ecaeb7a0b9e040e5de04892a1e1eb"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:ga7f7ecaeb7a0b9e040e5de04892a1e1eb template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f7ecaeb7a0b9e040e5de04892a1e1eb">Acts::GridSurfaceMaterial</a></td></tr>
<tr class="memdesc:ga7f7ecaeb7a0b9e040e5de04892a1e1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for grid-based surface material.  <br /></td></tr>
<tr class="memitem:gaad5c814e3aa3cfb77dd2dc46abc2099b" id="r_gaad5c814e3aa3cfb77dd2dc46abc2099b"><td class="memTemplParams" colspan="2">template&lt;typename grid_type&gt; </td></tr>
<tr class="memitem:gaad5c814e3aa3cfb77dd2dc46abc2099b template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad5c814e3aa3cfb77dd2dc46abc2099b">Acts::IndexedSurfaceMaterial</a></td></tr>
<tr class="memdesc:gaad5c814e3aa3cfb77dd2dc46abc2099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for surface material indexed by local coordinates.  <br /></td></tr>
<tr class="memitem:gadfa3ab1557fc9f1b6d7227d617a1ef4f" id="r_gadfa3ab1557fc9f1b6d7227d617a1ef4f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadfa3ab1557fc9f1b6d7227d617a1ef4f">Acts::ProtoGridSurfaceMaterial</a></td></tr>
<tr class="memdesc:gadfa3ab1557fc9f1b6d7227d617a1ef4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a prototype surface material using a grid of ProtoAxis A surface material implementation that uses a vector of ProtoAxis for grid-based binning.  <br /></td></tr>
<tr class="memitem:gabad517c3d330be68557175bbe3e71402" id="r_gabad517c3d330be68557175bbe3e71402"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabad517c3d330be68557175bbe3e71402">Acts::ProtoSurfaceMaterial</a> = <a class="el" href="class_acts_1_1_proto_surface_material_t.html">ProtoSurfaceMaterialT</a>&lt;<a class="el" href="class_acts_1_1_bin_utility.html">Acts::BinUtility</a>&gt;</td></tr>
<tr class="memdesc:gabad517c3d330be68557175bbe3e71402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a prototype surface material using BinUtility A surface material implementation that uses BinUtility for binning.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga470f44f3b24dd49d4a1366a6666f67f6" id="r_ga470f44f3b24dd49d4a1366a6666f67f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga470f44f3b24dd49d4a1366a6666f67f6">Acts::makeDefaultBetheHeitlerApprox</a> (bool clampToRange=false)</td></tr>
<tr class="memdesc:ga470f44f3b24dd49d4a1366a6666f67f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a> object based on an ATLAS configuration, that are stored as static data in the source code.  <br /></td></tr>
<tr class="memitem:ga36398a73a93820ca563cdaebf35c8c99" id="r_ga36398a73a93820ca563cdaebf35c8c99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="class_acts_1_1_material.html#ac9b70e6986aef6c7b9569576fcf8a781">Material::ParametersVector</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga36398a73a93820ca563cdaebf35c8c99">Acts::materialMapperRZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;materialVectorToGridMapper, std::vector&lt; double &gt; rPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="class_acts_1_1_material.html">Acts::Material</a> &gt; &amp;material, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>)</td></tr>
<tr class="memdesc:ga36398a73a93820ca563cdaebf35c8c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the MaterialMapper.  <br /></td></tr>
<tr class="memitem:ga58e02a2bfb006720b513203973586084" id="r_ga58e02a2bfb006720b513203973586084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="class_acts_1_1_material.html#ac9b70e6986aef6c7b9569576fcf8a781">Material::ParametersVector</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58e02a2bfb006720b513203973586084">Acts::materialMapperXYZ</a> (const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;materialVectorToGridMapper, std::vector&lt; double &gt; xPos, std::vector&lt; double &gt; yPos, std::vector&lt; double &gt; zPos, const std::vector&lt; <a class="el" href="class_acts_1_1_material.html">Material</a> &gt; &amp;material, double lengthUnit=<a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a>)</td></tr>
<tr class="memdesc:ga58e02a2bfb006720b513203973586084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to setup the MaterialLookup.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="gac15aff2ad0a7029a89bd903885de3310" name="gac15aff2ad0a7029a89bd903885de3310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac15aff2ad0a7029a89bd903885de3310">&#9670;&#160;</a></span>GloballyIndexedSurfaceMaterial</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename grid_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gac15aff2ad0a7029a89bd903885de3310">Acts::GloballyIndexedSurfaceMaterial</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid_surface_material_t.html">GridSurfaceMaterialT&lt;grid_type, GloballyIndexedMaterialAccessor&gt;</a></div>
<div class="ttc" id="aclass_acts_1_1_grid_surface_material_t_html"><div class="ttname"><a href="class_acts_1_1_grid_surface_material_t.html">Acts::GridSurfaceMaterialT</a></div><div class="ttdoc">GridSurfaceMaterialT.</div><div class="ttdef"><b>Definition</b> GridSurfaceMaterial.hpp:215</div></div>
</div><!-- fragment -->
<p>Type alias for surface material indexed by global coordinates. </p>
<p>Surface material implementation that uses global coordinate indexing </p>

</div>
</div>
<a id="ga7f7ecaeb7a0b9e040e5de04892a1e1eb" name="ga7f7ecaeb7a0b9e040e5de04892a1e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7ecaeb7a0b9e040e5de04892a1e1eb">&#9670;&#160;</a></span>GridSurfaceMaterial</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename grid_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ga7f7ecaeb7a0b9e040e5de04892a1e1eb">Acts::GridSurfaceMaterial</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid_surface_material_t.html">GridSurfaceMaterialT&lt;grid_type, GridMaterialAccessor&gt;</a></div>
</div><!-- fragment -->
<p>Type alias for grid-based surface material. </p>
<p>Surface material implementation using a regular grid structure </p>

</div>
</div>
<a id="gaad5c814e3aa3cfb77dd2dc46abc2099b" name="gaad5c814e3aa3cfb77dd2dc46abc2099b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad5c814e3aa3cfb77dd2dc46abc2099b">&#9670;&#160;</a></span>IndexedSurfaceMaterial</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename grid_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gaad5c814e3aa3cfb77dd2dc46abc2099b">Acts::IndexedSurfaceMaterial</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_grid_surface_material_t.html">GridSurfaceMaterialT&lt;grid_type, IndexedMaterialAccessor&gt;</a></div>
</div><!-- fragment -->
<p>Type alias for surface material indexed by local coordinates. </p>
<p>Surface material implementation that uses local coordinate indexing </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">grid_type</td><td>The type of grid used for material mapping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfa3ab1557fc9f1b6d7227d617a1ef4f" name="gadfa3ab1557fc9f1b6d7227d617a1ef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfa3ab1557fc9f1b6d7227d617a1ef4f">&#9670;&#160;</a></span>ProtoGridSurfaceMaterial</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gadfa3ab1557fc9f1b6d7227d617a1ef4f">Acts::ProtoGridSurfaceMaterial</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> </div>
<div class="line">    <a class="code hl_class" href="class_acts_1_1_proto_surface_material_t.html">ProtoSurfaceMaterialT&lt;std::vector&lt;DirectedProtoAxis&gt;</a>&gt;</div>
<div class="ttc" id="aclass_acts_1_1_proto_surface_material_t_html"><div class="ttname"><a href="class_acts_1_1_proto_surface_material_t.html">Acts::ProtoSurfaceMaterialT</a></div><div class="ttdoc">proxy to SurfaceMaterial hand over BinUtility or other suitable binning description</div><div class="ttdef"><b>Definition</b> ProtoSurfaceMaterial.hpp:34</div></div>
</div><!-- fragment -->
<p>Type alias for a prototype surface material using a grid of ProtoAxis A surface material implementation that uses a vector of ProtoAxis for grid-based binning. </p>

</div>
</div>
<a id="gabad517c3d330be68557175bbe3e71402" name="gabad517c3d330be68557175bbe3e71402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad517c3d330be68557175bbe3e71402">&#9670;&#160;</a></span>ProtoSurfaceMaterial</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#gabad517c3d330be68557175bbe3e71402">Acts::ProtoSurfaceMaterial</a> = <a class="el" href="class_acts_1_1_proto_surface_material_t.html">ProtoSurfaceMaterialT</a>&lt;<a class="el" href="class_acts_1_1_bin_utility.html">Acts::BinUtility</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias for a prototype surface material using BinUtility A surface material implementation that uses BinUtility for binning. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga470f44f3b24dd49d4a1366a6666f67f6" name="ga470f44f3b24dd49d4a1366a6666f67f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga470f44f3b24dd49d4a1366a6666f67f6">&#9670;&#160;</a></span>makeDefaultBetheHeitlerApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a> Acts::makeDefaultBetheHeitlerApprox </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clampToRange</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="class_acts_1_1_atlas_bethe_heitler_approx.html">AtlasBetheHeitlerApprox</a> object based on an ATLAS configuration, that are stored as static data in the source code. </p>
<p>This may not be an optimal configuration, but should allow to run the GSF without the need to load files </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clampToRange</td><td>Whether to clamp values to the valid range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AtlasBetheHeitlerApprox with default ATLAS configuration parameters </dd></dl>

</div>
</div>
<a id="ga36398a73a93820ca563cdaebf35c8c99" name="ga36398a73a93820ca563cdaebf35c8c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36398a73a93820ca563cdaebf35c8c99">&#9670;&#160;</a></span>materialMapperRZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="class_acts_1_1_material.html#ac9b70e6986aef6c7b9569576fcf8a781">Material::ParametersVector</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt; Acts::materialMapperRZ </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t(std::array&lt; std::size_t, 2 &gt; binsRZ, std::array&lt; std::size_t, 2 &gt; nBinsRZ)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>materialVectorToGridMapper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>rPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>zPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_acts_1_1_material.html">Acts::Material</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>material</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lengthUnit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to setup the MaterialMapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">materialVectorToGridMapper</td><td>Function mapping the vector of material to the map of material values</td></tr>
  </table>
  </dd>
</dl>
<p>e.g.: we have small grid with the values: r={2,3}, z ={4,5}, the corresponding indices are i (belonging to r) and j (belonging to z), the globalIndex is M (belonging to the values of the Material) and the map is: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">r  </th><th class="markdownTableHeadCenter">i  </th><th class="markdownTableHeadCenter">z  </th><th class="markdownTableHeadCenter">j  </th><th class="markdownTableHeadLeft">M  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyLeft">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyLeft">2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">3  </td></tr>
</table>
<p>In this case the function would look like: </p><div class="fragment"><div class="line">[](std::array&lt;std::size_t, 2&gt; binsRZ, std::array&lt;std::size_t, 2&gt; nBinsRZ) {</div>
<div class="line">   <span class="keywordflow">return</span> (binsRZ.at(0) * nBinsRZ.at(1) + binsRZ.at(1));</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rPos</td><td>Values of the grid points in r </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zPos</td><td>Values of the grid points in z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">material</td><td>The material classification values in r and z for all given grid points stored in a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function localToGlobalBin determines how the material was stored in the vector in respect to the grid values </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthUnit</td><td>The unit of the grid points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A material mapper for RZ coordinate system with equidistant grid </dd></dl>

</div>
</div>
<a id="ga58e02a2bfb006720b513203973586084" name="ga58e02a2bfb006720b513203973586084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58e02a2bfb006720b513203973586084">&#9670;&#160;</a></span>materialMapperXYZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_acts_1_1_material_map_lookup.html">MaterialMapLookup</a>&lt; <a class="el" href="class_acts_1_1_grid.html">Grid</a>&lt; <a class="el" href="class_acts_1_1_material.html#ac9b70e6986aef6c7b9569576fcf8a781">Material::ParametersVector</a>, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt;, <a class="el" href="class_acts_1_1_axis.html">Axis</a>&lt; <a class="el" href="namespace_acts.html#a2472b7e663ee623501edad0bbcd8a32fa4bd2dce3bd186b044b90d37b908c3c52">Acts::AxisType::Equidistant</a> &gt; &gt; &gt; Acts::materialMapperXYZ </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; std::size_t(std::array&lt; std::size_t, 3 &gt; binsXYZ, std::array&lt; std::size_t, 3 &gt; nBinsXYZ)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>materialVectorToGridMapper</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>xPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>yPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>zPos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_acts_1_1_material.html">Material</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>material</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lengthUnit</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="namespace_acts_1_1_unit_constants.html#a44fb500abc41c8b4d2937824ad76f8bd">UnitConstants::mm</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to setup the MaterialLookup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">materialVectorToGridMapper</td><td>Function mapping the vector of material to the map of material values</td></tr>
  </table>
  </dd>
</dl>
<p>e.g.: we have small grid with the values: x={2,3}, y={3,4}, z ={4,5}, the corresponding indices are i (belonging to x), j (belonging to y) and k (belonging to z), the globalIndex is M (belonging to the values of the Material) and the map is: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">x  </th><th class="markdownTableHeadCenter">i  </th><th class="markdownTableHeadCenter">y  </th><th class="markdownTableHeadCenter">j  </th><th class="markdownTableHeadCenter">z  </th><th class="markdownTableHeadCenter">k  </th><th class="markdownTableHeadLeft">M  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyLeft">0  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">1  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyLeft">2  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">3  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyLeft">4  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">3  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">5  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">0  </td><td class="markdownTableBodyLeft">6  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">3  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">4  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyCenter">5  </td><td class="markdownTableBodyCenter">1  </td><td class="markdownTableBodyLeft">7  </td></tr>
</table>
<p>In this case the function would look like: </p><div class="fragment"><div class="line">[](std::array&lt;std::size_t, 3&gt; binsXYZ, std::array&lt;std::size_t, 3&gt; nBinsXYZ)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> (binsXYZ.at(0) * (nBinsXYZ.at(1) * nBinsXYZ.at(2))</div>
<div class="line">       + binsXYZ.at(1) * nBinsXYZ.at(2)</div>
<div class="line">       + binsXYZ.at(2));</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xPos</td><td>Values of the grid points in x </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">yPos</td><td>Values of the grid points in y </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zPos</td><td>Values of the grid points in z </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The values do not need to be sorted or unique (this will be done inside the function) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">material</td><td>The material classification values in x, y and z for all given grid points stored in a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function localToGlobalBin determines how the material was stored in the vector in respect to the grid values </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lengthUnit</td><td>The unit of the grid points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A material mapper for XYZ coordinate system with equidistant grid </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
